/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * ListBuckets
     * @description List all Buckets.
     */
    get: operations['ListBuckets'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/access_ip_address': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all Access IP Addresses */
    get: operations['ListAccessIpAddresses'];
    put?: never;
    /** Create new Access IP Address */
    post: operations['CreateAccessIpAddress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/access_ip_address/{access_ip_address_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve an access IP address */
    get: operations['GetAccessIpAddress'];
    put?: never;
    post?: never;
    /** Delete access IP address */
    delete: operations['DeleteAccessIpAddress'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/access_ip_ranges': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all Access IP Ranges */
    get: operations['ListAccessIpRanges'];
    put?: never;
    /** Create new Access IP Range */
    post: operations['CreateAccessIPRange'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/access_ip_ranges/{access_ip_range_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Delete access IP ranges */
    delete: {
      parameters: {
        query?: never;
        header?: never;
        path: {
          access_ip_range_id: string;
        };
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        /** @description Successful Response */
        200: {
          headers: {
            [name: string]: unknown;
          };
          content: {
            'application/json': components['schemas']['AccessIPRangeResponseSchema'];
          };
        };
      };
    };
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actions/bulk/telephony_credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Creates several credentials
     * @description Creates several credentials in bulk.
     */
    post: operations['CreateBulkTelephonyCredentials'];
    /**
     * Delete several credentials
     * @description Delete several credentials in bulk.
     */
    delete: operations['DeleteTelephonyCredentials'];
    options?: never;
    head?: never;
    /**
     * Update several credentials
     * @description Update several credentials in bulk.
     */
    patch: operations['UpdateBulkTelephonyCredential'];
    trace?: never;
  };
  '/actions/network_preferences/sim_cards': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Bulk Network Preferences for SIM cards
     * @description This API allows dispatching the same operation described for the PUT sim_cards/:id/network_preferences API for multiple SIM cards at once.<br/><br/>
     *     Although, a SIM card network preference may fail individually under any validation triggered as a consequence of its state. For example, a SIM can't have an in-progress OTA update for applying a Network Preference, so they'll fail when requested in this API. In that scenario, the specific error will be present in the response along with the successful definitions in the "errors" response node.
     *
     */
    put: operations['BulkSimCardNetworkPreferences'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actions/purchase/esims': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Purchase eSIMs
     * @description Purchases and registers the specified amount of eSIMs to the current user's account.<br/><br/>
     *     If <code>sim_card_group_id</code> is provided, the eSIMs will be associated with that group. Otherwise, the default group for the current user will be used.<br/><br/>
     *
     */
    post: operations['PurchaseESim'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actions/register/sim_cards': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Register SIM cards
     * @description Register the SIM cards associated with the provided registration codes to the current user's account.<br/><br/>
     *     If <code>sim_card_group_id</code> is provided, the SIM cards will be associated with that group. Otherwise, the default group for the current user will be used.<br/><br/>
     *
     */
    post: operations['RegisterSimCards'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/actions/{action}/telephony_credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Perform activate or deactivate action on all credentials filtered by the provided tag.
     * @description Perform activate or deactivate action on all credentials filtered by the provided tag. Activate action will change the status to active, making it possible to connect calls with the credential. Deactivate action will change the status to inactive, making it impossible to connect calls with the credential.
     */
    post: operations['BulkCredentialAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/addresses': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all addresses
     * @description Returns a list of your addresses.
     */
    get: operations['FindAddresses'];
    put?: never;
    /**
     * Creates an address
     * @description Creates an address.
     */
    post: operations['CreateAddress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/addresses/actions/validate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate an address
     * @description Validates an address for emergency services.
     */
    post: operations['ValidateAddress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/addresses/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an address
     * @description Retrieves the details of an existing address.
     */
    get: operations['GetAddress'];
    put?: never;
    post?: never;
    /**
     * Deletes an address
     * @description Deletes an existing address.
     */
    delete: operations['DeleteAddress'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/addresses/{id}/actions/accept_suggestions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Accepts this address suggestion as a new emergency address for Operator Connect and finishes the uploads of the numbers associated with it to Microsoft. */
    post: operations['acceptAddressSuggestions'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/assistants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List assistants
     * @description Retrieve a list of all AI Assistants configured by the user.
     */
    get: operations['get_assistants_public_assistants_get'];
    put?: never;
    /**
     * Create an assistant
     * @description Create a new AI Assistant.
     */
    post: operations['create_new_assistant_public_assistants_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/assistants/{assistant_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get an assistant
     * @description Retrieve an AI Assistant configuration by `assistant_id`.
     */
    get: operations['get_assistant_public_assistants__assistant_id__get'];
    put?: never;
    /**
     * Update an assistant
     * @description Update an AI Assistant's attributes.
     */
    post: operations['update_assistant_public_assistants__assistant_id__post'];
    /**
     * Delete an assistant
     * @description Delete an AI Assistant by `assistant_id`.
     */
    delete: operations['delete_assistant_public_assistants__assistant_id__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/audio/transcriptions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transcribe speech to text (BETA)
     * @description Transcribe speech to text. This endpoint is consistent with the [OpenAI Transcription API](https://platform.openai.com/docs/api-reference/audio/createTranscription) and may be used with the OpenAI JS or Python SDK.
     */
    post: operations['audio_public_audio_transcriptions_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/chat/completions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a chat completion
     * @description Chat with a language model. This endpoint is consistent with the [OpenAI Chat Completions API](https://platform.openai.com/docs/api-reference/chat) and may be used with the OpenAI JS or Python SDK.
     */
    post: operations['chat_public_chat_completions_post'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/embeddings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Tasks by Status
     * @description Retrieve tasks for the user that are either `queued`, `processing`, `failed`, `success` or `partial_success` based on the query string. Defaults to `queued` and `processing`.
     */
    get: operations['GetTasksByStatus'];
    put?: never;
    /**
     * Embed documents
     * @description Perform embedding on a Telnyx Storage Bucket using the a embedding model.
     *     The current supported file types are:
     *     - PDF
     *     - HTML
     *     - txt/unstructured text files
     *     - json
     *     - csv
     *     - audio / video (mp3, mp4, mpeg, mpga, m4a, wav, or webm ) - Max of 100mb file size.
     *
     *     Any files not matching the above types will be attempted to be embedded as unstructured text.
     *
     *     This process can be slow, so it runs in the background and the user can check
     *     the status of the task using the endpoint `/ai/embeddings/{task_id}`.
     *
     *      **Important Note**: When you update documents in a Telnyx Storage bucket, their associated embeddings are automatically kept up to date. If you add or update a file, it is automatically embedded. If you delete a file, the embeddings are deleted for that particular file.
     *
     *     You can also specify a custom `loader` param. Currently the only supported loader value is
     *     `intercom` which loads Intercom article jsons as specified by [the Intercom article API](https://developers.intercom.com/docs/references/rest-api/api.intercom.io/Articles/article/)
     *     This loader will split each article into paragraphs and save additional parameters relevant to Intercom docs, such as
     *     `article_url` and `heading`. These values will be returned by the `/v2/ai/embeddings/similarity-search` endpoint in the `loader_metadata` field.
     */
    post: operations['PostEmbedding'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/embeddings/buckets': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List embedded buckets
     * @description Get all embedding buckets for a user.
     */
    get: operations['GetEmbeddingBuckets'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/embeddings/buckets/{bucket_name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get file-level embedding statuses for a bucket
     * @description Get all embedded files for a given user bucket, including their processing status.
     */
    get: operations['GetBucketName'];
    put?: never;
    post?: never;
    /**
     * Disable AI for an Embedded Bucket
     * @description Deletes an entire bucket's embeddings and disables the bucket for AI-use, returning it to normal storage pricing.
     */
    delete: operations['embedding_bucket_files_public_embedding_buckets__bucket_name__delete'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/embeddings/similarity-search': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Search for documents
     * @description Perform a similarity search on a Telnyx Storage Bucket, returning the most similar `num_docs` document chunks to the query.
     *
     *     Currently the only available distance metric is cosine similarity which will return a `distance` between 0 and 1.
     *     The lower the distance, the more similar the returned document chunks are to the query.
     *     A `certainty` will also be returned, which is a value between 0 and 1 where the higher the certainty, the more similar the document.
     *     You can read more about Weaviate distance metrics here: [Weaviate Docs](https://weaviate.io/developers/weaviate/config-refs/distances)
     *
     *     If a bucket was embedded using a custom loader, such as `intercom`, the additional metadata will be returned in the
     *     `loader_metadata` field.
     */
    post: operations['PostEmbeddingSimilaritySearch'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/embeddings/{task_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get an embedding task's status
     * @description Check the status of a current embedding task. Will be one of the following:
     *     - `queued` - Task is waiting to be picked up by a worker
     *     - `processing` - The embedding task is running
     *     - `success` - Task completed successfully and the bucket is embedded
     *     - `failure` - Task failed and no files were embedded successfully
     *     - `partial_success` - Some files were embedded successfully, but at least one failed
     */
    get: operations['GetEmbeddingTask'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/models': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get available models
     * @description This endpoint returns a list of Open Source and OpenAI models that are available for use. <br /><br /> **Note**: Model `id`'s will be in the form `{source}/{model_name}`. For example `openai/gpt-4` or `mistralai/Mistral-7B-Instruct-v0.1` consistent with HuggingFace naming conventions.
     */
    get: operations['get_models_public_models_get'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ai/summarize': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Summarize file content
     * @description Generate a summary of a file's contents.
     *
     *      Supports the following text formats:
     *     - PDF, HTML, txt, json, csv
     *
     *      Supports the following media formats (billed for both the transcription and summary):
     *     - flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm
     *     - Up to 100 MB
     */
    post: operations['PostSummary'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/audit_events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Audit Logs
     * @description List all audit log entries. Audit logs are a best-effort, eventually consistent record of significant account related changes.
     */
    get: {
      parameters: {
        query?: {
          /** @description The page number to load */
          'page[number]'?: components['parameters']['PageNumber'];
          /** @description The size of the page */
          'page[size]'?: components['parameters']['PageSize'];
        };
        header?: never;
        path?: never;
        cookie?: never;
      };
      requestBody?: never;
      responses: {
        200: components['responses']['ListAuditLogsResponse'];
      };
    };
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/authentication_providers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all SSO authentication providers
     * @description Returns a list of your SSO authentication providers.
     */
    get: operations['FindAuthenticationProviders'];
    put?: never;
    /**
     * Creates an authentication provider
     * @description Creates an authentication provider.
     */
    post: operations['CreateAuthenticationProvider'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/authentication_providers/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an authentication provider
     * @description Retrieves the details of an existing authentication provider.
     */
    get: operations['GetAuthenticationProvider'];
    put?: never;
    post?: never;
    /**
     * Deletes an authentication provider
     * @description Deletes an existing authentication provider.
     */
    delete: operations['DeleteAuthenticationProvider'];
    options?: never;
    head?: never;
    /**
     * Update a authentication provider
     * @description Updates settings of an existing authentication provider.
     */
    patch: operations['UpdateAuthenticationProvider'];
    trace?: never;
  };
  '/available_phone_number_blocks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List available phone number blocks */
    get: operations['ListAvailablePhoneNumberBlocks'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/available_phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List available phone numbers */
    get: operations['ListAvailablePhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/balance': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get user balance details */
    get: operations['GetUserBalance'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/billing_groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all billing groups */
    get: operations['ListBillingGroups'];
    put?: never;
    /** Create a billing group */
    post: operations['CreateBillingGroup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/billing_groups/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a billing group */
    get: operations['GetBillingGroup'];
    put?: never;
    post?: never;
    /** Delete a billing group */
    delete: operations['DeleteBillingGroup'];
    options?: never;
    head?: never;
    /** Update a billing group */
    patch: operations['UpdateBillingGroup'];
    trace?: never;
  };
  '/brand': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Brands
     * @description This endpoint is used to list all brands associated with your organization.
     */
    get: operations['GetBrands'];
    put?: never;
    /**
     * Create Brand
     * @description This endpoint is used to create a new brand. A brand is an entity created by The Campaign Registry (TCR) that represents an organization or a company. It is this entity that TCR created campaigns will be associated with. Each brand creation will entail an upfront, non-refundable $4 expense.
     */
    post: operations['CreateBrandPost'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/brand/feedback/{brandId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Brand Feedback By Id
     * @description Get feedback about a brand by ID. This endpoint can be used after creating or revetting
     *     a brand.
     *
     *     Possible values for `.category[].id`:
     *
     *     * `TAX_ID` - Data mismatch related to tax id and its associated properties.
     *     * `STOCK_SYMBOL` - Non public entity registered as a public for profit entity or
     *       the stock information mismatch.
     *     * `GOVERNMENT_ENTITY` - Non government entity registered as a government entity.
     *       Must be a U.S. government entity.
     *     * `NONPROFIT` - Not a recognized non-profit entity. No IRS tax-exempt status
     *       found.
     *     * `OTHERS` - Details of the data misrepresentation if any.
     */
    get: operations['GetBrandFeedbackById'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/brand/{brandId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Brand
     * @description Retrieve a brand by `brandId`.
     */
    get: operations['GetBrand'];
    /**
     * Update Brand
     * @description Update a brand's attributes by `brandId`.
     */
    put: operations['UpdateBrand'];
    post?: never;
    /**
     * Delete Brand
     * @description Delete Brand. This endpoint is used to delete a brand. Note the brand cannot be deleted if it contains one or more active campaigns, the campaigns need to be inactive and at least 3 months old due to billing purposes.
     */
    delete: operations['DeleteBrand'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/brand/{brandId}/2faEmail': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Resend brand 2FA email */
    post: operations['ResendBrand2faEmail'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/brand/{brandId}/externalVetting': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List External Vettings
     * @description Get list of valid external vetting record for a given brand
     */
    get: operations['ListExternalVettings'];
    /**
     * Import External Vetting Record
     * @description This operation can be used to import an external vetting record from a TCR-approved
     *     vetting provider. If the vetting provider confirms validity of the record, it will be
     *     saved with the brand and will be considered for future campaign qualification.
     */
    put: operations['PutExternalVettingRecord'];
    /**
     * Order Brand External Vetting
     * @description Order new external vetting for a brand
     */
    post: operations['PostOrderExternalVetting'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/brand/{brandId}/revet': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Revet Brand
     * @description This operation allows you to revet the brand. However, revetting is allowed once after the successful brand registration and thereafter limited to once every 3 months.
     */
    put: operations['RevetBrand'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bulk_sim_card_actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List bulk SIM card actions
     * @description This API lists a paginated collection of bulk SIM card actions. A bulk SIM card action contains details about a collection of individual SIM card actions.
     */
    get: operations['ListBulkSimCardActions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/bulk_sim_card_actions/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get bulk SIM card action details
     * @description This API fetches information about a bulk SIM card action. A bulk SIM card action contains details about a collection of individual SIM card actions.
     */
    get: operations['GetBulkSimCardAction'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/call_control_applications': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List call control applications
     * @description Return a list of call control applications.
     */
    get: operations['ListCallControlApplications'];
    put?: never;
    /**
     * Create a call control application
     * @description Create a call control application.
     */
    post: operations['CreateCallControlApplication'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/call_control_applications/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a call control application
     * @description Retrieves the details of an existing call control application.
     */
    get: operations['RetrieveCallControlApplication'];
    put?: never;
    post?: never;
    /**
     * Delete a call control application
     * @description Deletes a call control application.
     */
    delete: operations['DeleteCallControlApplication'];
    options?: never;
    head?: never;
    /**
     * Update a call control application
     * @description Updates settings of an existing call control application.
     */
    patch: operations['UpdateCallControlApplication'];
    trace?: never;
  };
  '/call_events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List call events
     * @description Filters call events by given filter parameters. Events are ordered by `event_timestamp`. If filter for `call_leg_id` or `call_session_id` is not present, it only filters events from the last 24 hours.
     *
     *     **Note**: Only one `filter[event_timestamp]` can be passed.
     *
     */
    get: operations['ListCallEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Dial
     * @description Dial a number or SIP URI from a given connection. A successful response will include a `call_leg_id` which can be used to correlate the command with subsequent webhooks.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.initiated`
     *     - `call.answered` or `call.hangup`
     *     - `call.machine.detection.ended` if `answering_machine_detection` was requested
     *     - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end of machine greeting
     *     - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
     *     - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and a beep was detected
     *     - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set
     *
     */
    post: operations['DialCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a call status
     * @description Returns the status of a call (data is available 10 minutes after call ended).
     */
    get: operations['RetrieveCallStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/answer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Answer call
     * @description Answer an incoming call. You must issue this command before executing subsequent commands on an incoming call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.answered`
     *     - `streaming.started`, `streaming.stopped` or `streaming.failed` if `stream_url` was set
     *
     */
    post: operations['AnswerCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/bridge': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Bridge calls
     * @description Bridge two call control calls.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.bridged` for Leg A
     *     - `call.bridged` for Leg B
     *
     */
    post: operations['BridgeCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/client_state_update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    /**
     * Update client state
     * @description Updates client state
     */
    put: operations['UpdateClientState'];
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/enqueue': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Enqueue call
     * @description Put the call in a queue.
     */
    post: operations['EnqueueCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/fork_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Forking start
     * @description Call forking allows you to stream the media from a call to a specific target in realtime.
     *     This stream can be used to enable realtime audio analysis to support a
     *     variety of use cases, including fraud detection, or the creation of AI-generated audio responses.
     *     Requests must specify either the `target` attribute or the `rx` and `tx` attributes.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.fork.started`
     *     - `call.fork.stopped`
     *
     *     **Simple Telnyx RTP Encapsulation Protocol (STREP)**
     *
     *     *Note: This header/encapsulation is not used when the `rx` and `tx`
     *     parameters have been specified; it only applies when media is forked
     *     using the `target` attribute.*
     *
     *     If the destination for forked media is specified using the "target"
     *     attribute, the RTP will be encapsulated in an extra Telnyx protocol,
     *     which adds a 24 byte header to the RTP payload in each packet. The STREP
     *     header includes the Call Control `call_leg_id` for stream
     *     identification, along with bits that represent the direction (inbound or
     *     outbound) of the media. This 24-byte header sits between the UDP header
     *     and the RTP header.
     *
     *     The STREP header makes it possible to fork RTP for multiple calls (or
     *     two RTP streams for the same call) to the same IP:port, where the
     *     streams can be demultiplexed by your application using the information
     *     in the header. Of course, it's still possible to ignore this header
     *     completely, for example, if sending forked media for different calls to
     *     different ports or IP addresses. In this case, simply strip 24 bytes
     *     (or use the second byte to find the header length) from the received UDP
     *     payload to get the RTP (RTP header and payload).
     *
     *     ```
     *     STREP Specification
     *
     *       0                   1                   2                   3
     *       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *      |1 1|Version|L|D|    HeaderLen  |  reserved (2 bytes)           |
     *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *      |       reserved (4 bytes, for UDP ports or anything else)      |
     *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *      |               The call_leg_id                                 |
     *      |                   from Call Control                           |
     *      |                       (128 bits / 16 bytes)                   |
     *      |                           (this is binary data)               |
     *      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     *
     *      11
     *        Static bits 11, always set to 11 to easily distinguish forked media
     *        from RTP (10) and T.38 media (usually 00) and SIP (which begins
     *        with a capital letter, so begins with bits 01). This is a magic number.
     *
     *      Version
     *        Four bits to indicate the version number of the protocol, starting at 0001.
     *
     *      L
     *        One bit to represent the leg of the call (A or B).
     *        0 represents the A (first) leg of the call.
     *        1 represents the B (second) leg of the call.
     *
     *      D
     *        One bit to represent the direction of this RTP stream.
     *        0 represents media received by Telnyx.
     *        1 represents media transmitted by Telnyx.
     *
     *      HeaderLen (1 byte)
     *        The length of the header in bytes.
     *        Note that this value does not include the length of the payload. The total
     *        size of the RTP can be calculated by subtracting the HeaderLen from the UDP
     *        length (minus 8 for the UDP header).
     *        In version 1, this value will always be 24.
     *
     *      Reserved (6 bytes)
     *        Reserved for future use and to make sure that the header is a multiple of 32 bits
     *
     *      Call Leg ID
     *        A 128-bit identifier for the call leg.
     *        This is the call_leg_id from Call Control.
     *     ```
     *
     */
    post: operations['StartCallFork'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/fork_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Forking stop
     * @description Stop forking a call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.fork.stopped`
     *
     */
    post: operations['StopCallFork'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/gather': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Gather
     * @description Gather DTMF signals to build interactive menus.
     *
     *     You can pass a list of valid digits. The `Answer` command must be issued before the `gather` command.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.dtmf.received` (you may receive many of these webhooks)
     *     - `call.gather.ended`
     *
     */
    post: operations['GatherCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/gather_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Gather stop
     * @description Stop current gather.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.gather.ended`
     *
     */
    post: operations['StopCallGather'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/gather_using_ai': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Gather using AI (BETA)
     * @description **BETA** Gather parameters defined in the request payload using a voice assistant.
     *
     *      You can pass parameters described as a JSON Schema object and the voice assistant will attempt to gather these informations. At the moment only English is supported.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.ai_gather.ended`
     *
     */
    post: operations['callGatherUsingAI'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/gather_using_audio': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Gather using audio
     * @description Play an audio file on the call until the required DTMF signals are gathered to build interactive menus.
     *
     *     You can pass a list of valid digits along with an 'invalid_audio_url', which will be played back at the beginning of each prompt. Playback will be interrupted when a DTMF signal is received. The `Answer command must be issued before the `gather_using_audio` command.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.playback.started`
     *     - `call.playback.ended`
     *     - `call.dtmf.received` (you may receive many of these webhooks)
     *     - `call.gather.ended`
     *
     */
    post: operations['GatherUsingAudio'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/gather_using_speak': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Gather using speak
     * @description Convert text to speech and play it on the call until the required DTMF signals are gathered to build interactive menus.
     *
     *     You can pass a list of valid digits along with an 'invalid_payload', which will be played back at the beginning of each prompt. Speech will be interrupted when a DTMF signal is received. The `Answer` command must be issued before the `gather_using_speak` command.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.dtmf.received` (you may receive many of these webhooks)
     *     - `call.gather.ended`
     *
     */
    post: operations['GatherUsingSpeak'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/hangup': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Hangup call
     * @description Hang up the call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.hangup`
     *     - `call.recording.saved`
     *
     */
    post: operations['HangupCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/leave_queue': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Remove call from a queue
     * @description Removes the call from a queue.
     */
    post: operations['LeaveQueue'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/playback_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Play audio URL
     * @description Play an audio file on the call. If multiple play audio commands are issued consecutively,
     *     the audio files will be placed in a queue awaiting playback.
     *
     *     *Notes:*
     *
     *     - When `overlay` is enabled, `target_legs` is limited to `self`.
     *     - A customer cannot Play Audio with `overlay=true` unless there is a Play Audio with `overlay=false` actively playing.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.playback.started`
     *     - `call.playback.ended`
     *
     */
    post: operations['StartCallPlayback'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/playback_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stop audio playback
     * @description Stop audio being played on the call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.playback.ended` or `call.speak.ended`
     *
     */
    post: operations['StopCallPlayback'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/record_pause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record pause
     * @description Pause recording the call. Recording can be resumed via Resume recording command.
     *
     *     **Expected Webhooks:**
     *
     *     There are no webhooks associated with this command.
     *
     */
    post: operations['PauseCallRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/record_resume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Record resume
     * @description Resume recording the call.
     *
     *     **Expected Webhooks:**
     *
     *     There are no webhooks associated with this command.
     *
     */
    post: operations['ResumeCallRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/record_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Recording start
     * @description Start recording the call. Recording will stop on call hang-up, or can be initiated via the Stop Recording command.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.recording.saved`
     *
     */
    post: operations['StartCallRecord'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/record_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Recording stop
     * @description Stop recording the call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.recording.saved`
     *
     */
    post: operations['StopCallRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/refer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * SIP Refer a call
     * @description Initiate a SIP Refer on a Call Control call. You can initiate a SIP Refer at any point in the duration of a call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.refer.started`
     *     - `call.refer.completed`
     *     - `call.refer.failed`
     *
     */
    post: operations['ReferCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/reject': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Reject a call
     * @description Reject an incoming call.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.hangup`
     *
     */
    post: operations['RejectCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/send_dtmf': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send DTMF
     * @description Sends DTMF tones from this leg. DTMF tones will be heard by the other end of the call.
     *
     *     **Expected Webhooks:**
     *
     *     There are no webhooks associated with this command.
     *
     */
    post: operations['SendDTMF'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/send_sip_info': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send SIP info
     * @description Sends SIP info from this leg.
     *
     *     **Expected Webhooks:**
     *
     *     There are no webhooks associated with this command.
     *
     */
    post: operations['SendSIPInfo'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/speak': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Speak text
     * @description Convert text to speech and play it back on the call. If multiple speak text commands are issued consecutively, the audio files will be placed in a queue awaiting playback.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.speak.started`
     *     - `call.speak.ended`
     *
     */
    post: operations['SpeakCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/streaming_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Streaming start
     * @description Start streaming the media from a call to a specific WebSocket address or Dialogflow connection in near-realtime. Audio will be delivered as base64-encoded RTP payload (raw audio), wrapped in JSON payloads.
     *
     *     **Example: Starting a stream to a Websocket address**
     *
     *      The `stream_url` param is mandatory.
     *
     *     ```
     *     curl -X POST \
     *       --header "Content-Type: application/json" \
     *       --header "Accept: application/json" \
     *       --header "Authorization: Bearer YOUR_API_KEY" \
     *       --data '{
     *      "stream_url": "wss://www.example.com/websocket",\
     *     "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d",\
     *     "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901" \
     *     }' \
     *       https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
     *     ```
     *
     *      **Example: Starting a stream to a Dialogflow connection**
     *
     *      Enable the Dialogflow integration by sending `"enable_dialogflow": true` in the request. You need to have a Dialogflow connection associated with your Call Control application first, [click here for instructions](https://developers.telnyx.com/docs/voice/programmable-voice/dialogflow-es).
     *     ```
     *     curl -X POST \
     *       --header "Content-Type: application/json" \
     *       --header "Accept: application/json" \
     *       --header "Authorization: Bearer YOUR_API_KEY" \
     *       --data '{
     *      "client_state":"aGF2ZSBhIG5pY2UgZGF5ID1d", \
     *     "command_id":"891510ac-f3e4-11e8-af5b-de00688a4901", \
     *     "enable_dialogflow": true \
     *     }' \
     *       https://api.telnyx.com/v2/calls/{call_control_id}/actions/streaming_start
     *     ```
     *
     *     **Expected Webhooks:**
     *
     *     - `streaming.started`
     *     - `streaming.stopped`
     *     - `streaming.failed`
     *
     *     **WebSocket events**
     *
     *     When the WebSocket connection is established, the following event is being sent over it:
     *     ```
     *     {
     *       "event": "connected",
     *       "version": "1.0.0"
     *     }
     *     ```
     *     And when the call is started, an event which contains information about the encoding and `stream_id` that identifies a particular stream:
     *     ```
     *     {
     *       "event": "start",
     *       "sequence_number": "1",
     *       "start": {
     *         "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "media_format": {
     *           "encoding": "audio/x-mulaw",
     *           "sample_rate": 8000,
     *           "channels": 1
     *         }
     *       },
     *       "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
     *     }
     *     ```
     *     The start event is followed by the following media events that contain base64-encoded RTP payload (raw audio, no RTP headers) (:
     *     ```
     *     {
     *       "event": "media",
     *       "sequence_number": "4",
     *       "media": {
     *         "track": "inbound/outbound",
     *         "chunk": "2",
     *         "timestamp": "5",
     *         "payload": "no+JhoaJjpzSHxAKBgYJD...IsSbjomGhoqQn1Ic"
     *       },
     *       "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
     *     }
     *     ```
     *     Please note that the order of events is not guaranteed and the chunk number can be used to reorder the events.
     *
     *     When the call ends, the stop event over WebSockets connection is sent:
     *     ```
     *     {
     *       "event": "stop",
     *       "sequence_number": "5",
     *       "stop": {
     *         "user_id": "3e6f995f-85f7-4705-9741-53b116d28237",
     *         "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ"
     *        },
     *         "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc"
     *      }
     *     ```
     *
     *     **Bidirectional Media Streaming**
     *
     *     Media can be sent back to the call through the websocket as well. This is done in a way very similar to the [playback_start](https://developers.telnyx.com/api/call-control/start-call-playback)
     *     command, when using a base64 encoded mp3 file in the payload. Simply send a packet to the websocket connection as follows:
     *
     *     ```
     *     {
     *       "event": "media",
     *       "media": {
     *         "payload" : <your base64 encoded mp3 file>
     *       }
     *     }
     *     ```
     *
     *     The payload, which is a base64-encoded mp3 file, will be played on the call.
     *
     *     Some limitations to be aware of:
     *
     *     - Media payloads can only be submitted once per second.
     *     - Media _must_ be base64 encoded mp3
     *
     *     **Stream Errors**
     *
     *     Any errors in the media packet, including when a rate limit is reached, will result in an error frame being
     *     sent to your websocket server. The error frame will appear as follows:
     *
     *     ```
     *     {
     *       "stream_id": "32de0dea-53cb-4b21-89a4-9e1819c043bc",
     *       "event": "error",
     *       "sequence_number": "6",
     *       "error": {
     *         "title": "rate_limit_reached",
     *         "code": "100005",
     *         "detail": "Too many requests"
     *       }
     *     }
     *     ```
     *
     *     Possible errors are as follows:
     *
     *     - Error 100002: `"unknown_error"`
     *     - Error 100003: `"malformed_frame"`
     *     - Error 100004: `"invalid_media"`
     *     - Error 100005: `"rate_limit_reached"`
     *
     */
    post: operations['StartCallStreaming'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/streaming_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Streaming stop
     * @description Stop streaming a call to a WebSocket.
     *
     *     **Expected Webhooks:**
     *
     *     - `streaming.stopped`
     *
     */
    post: operations['StopCallStreaming'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/suppression_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Noise Suppression Start (BETA) */
    post: operations['noiseSuppressionStart'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/suppression_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Noise Suppression Stop (BETA) */
    post: operations['noiseSuppressionStop'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/transcription_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transcription start
     * @description Start real-time transcription. Transcription will stop on call hang-up, or can be initiated via the Transcription stop command.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.transcription`
     *
     */
    post: operations['StartCallTranscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/transcription_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transcription stop
     * @description Stop real-time transcription.
     */
    post: operations['StopCallTranscription'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/calls/{call_control_id}/actions/transfer': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Transfer call
     * @description Transfer a call to a new destination. If the transfer is unsuccessful, a `call.hangup` webhook for the other call (Leg B) will be sent indicating that the transfer could not be completed. The original call will remain active and may be issued additional commands, potentially transfering the call to an alternate destination.
     *
     *     **Expected Webhooks:**
     *
     *     - `call.initiated`
     *     - `call.bridged` to Leg B
     *     - `call.answered` or `call.hangup`
     *     - `call.machine.detection.ended` if `answering_machine_detection` was requested
     *     - `call.machine.greeting.ended` if `answering_machine_detection` was requested to detect the end of machine greeting
     *     - `call.machine.premium.detection.ended` if `answering_machine_detection=premium` was requested
     *     - `call.machine.premium.greeting.ended` if `answering_machine_detection=premium` was requested and a beep was detected
     *
     */
    post: operations['TransferCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Campaigns
     * @description Retrieve a list of campaigns associated with a supplied `brandId`.
     */
    get: operations['GetCampaigns'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/acceptSharing/{campaignId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Accept Shared Campaign
     * @description Manually accept a campaign shared with Telnyx
     */
    post: operations['AcceptCampaign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/usecase/cost': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Campaign Cost */
    get: operations['GetCampaignCost'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/{campaignId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get My Campaign
     * @description Retrieve campaign details by `campaignId`.
     */
    get: operations['GetCampaign'];
    /**
     * Update My Campaign
     * @description Update a campaign's properties by `campaignId`. **Please note:** only sample messages are editable.
     */
    put: operations['UpdateCampaign'];
    post?: never;
    /**
     * Deactivate My Campaign
     * @description Terminate a campaign. Note that once deactivated, a campaign cannot be restored.
     */
    delete: operations['DeactivateCampaign'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/{campaignId}/mnoMetadata': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Campaign Mno Metadata
     * @description Get the campaign metadata for each MNO it was submitted to.
     */
    get: operations['GetCampaignMnoMetadata'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/{campaignId}/operationStatus': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get My Campaign Operation Status
     * @description Retrieve campaign's operation status at MNO level.
     */
    get: operations['GetCampaignOperationStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/{campaignId}/osr/attributes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get My Osr Campaign Attributes */
    get: operations['GetCampaignOsrAttributes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaign/{campaignId}/sharing': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Sharing Status */
    get: operations['GetCampaignSharingStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaignBuilder': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Submit Campaign
     * @description Before creating a campaign, use the [Qualify By Usecase endpoint](https://developers.telnyx.com/api/messaging/10dlc/get-usecase-qualification) to ensure that the brand you want to assign a new campaign to is qualified for the desired use case of that campaign. **Please note:** After campaign creation, you'll only be able to edit the campaign's sample messages. Creating a campaign will entail an upfront, non-refundable three month's cost that will depend on the campaign's use case ([see 10DLC Costs section for details](https://developers.telnyx.com/docs/messaging/10dlc/concepts#10dlc-costs)).
     */
    post: operations['PostCampaign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/campaignBuilder/brand/{brandId}/usecase/{usecase}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Qualify By Usecase
     * @description This endpoint allows you to see whether or not the supplied brand is suitable for your desired campaign use case.
     */
    get: operations['GetUsecaseQualification'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/channel_zones': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get list of channel zones
     * @description List of channel zones with their countries
     */
    get: operations['GetChannelZones'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/channel_zones/{channel_zone_id}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
      };
      cookie?: never;
    };
    /**
     * Get a specific channel zone
     * @description Get a specific channel zone
     */
    get: operations['GetChannelZone'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Patch a channel zone
     * @description Change the amount of reserved channels at a given channel zone
     */
    patch: operations['PatchChannelZone'];
    trace?: never;
  };
  '/channel_zones/{channel_zone_id}/channel_zone_phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
      };
      cookie?: never;
    };
    /**
     * Get the list of phone numbers assigned to a channel zone
     * @description Retrieve the assigned phone numbers in a channel zone. Phone numbers assigned to a channel zone can receive concurrent calls up to the quantity reserved in that channel zone. Additional concurrent calls are rejected with a busy signal.
     */
    get: operations['GetPhoneNumbers'];
    put?: never;
    /**
     * Assign a phone number to a channel zone
     * @description You should own the phone number being assigned to the channel zone. Remember that you should reserve channels in this channel zone, otherwise you won't be able to receive incoming calls.
     */
    post: operations['AssignPhoneNumber'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/channel_zones/{channel_zone_id}/channel_zone_phone_numbers/{phone_number}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
        /** @description The phone number to be looked up */
        phone_number: components['parameters']['GcbPhoneNumber'];
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Unassign a phone number from a channel zone */
    delete: operations['UnassignPhoneNumber'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/comments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve all comments */
    get: operations['ListComments'];
    put?: never;
    /** Create a comment */
    post: operations['CreateComment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/comments/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a comment */
    get: operations['RetrieveComment'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/comments/{id}/read': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** Mark a comment as read */
    patch: operations['MarkCommentRead'];
    trace?: never;
  };
  '/conferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List conferences
     * @description Lists conferences. Conferences are created on demand, and will expire after all participants have left the conference or after 4 hours regardless of the number of active participants. Conferences are listed in descending order by `expires_at`.
     */
    get: operations['ListConferences'];
    put?: never;
    /**
     * Create conference
     * @description Create a conference from an existing call leg using a `call_control_id` and a conference name. Upon creating the conference, the call will be automatically bridged to the conference. Conferences will expire after all participants have left the conference or after 4 hours regardless of the number of active participants.
     *
     *     **Expected Webhooks:**
     *
     *     - `conference.created`
     *     - `conference.participant.joined`
     *     - `conference.participant.left`
     *     - `conference.ended`
     *     - `conference.recording.saved`
     *     - `conference.floor.changed`
     *
     */
    post: operations['CreateConference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{conference_id}/participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List conference participants
     * @description Lists conference participants
     */
    get: operations['ListConferenceParticipants'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a conference
     * @description Retrieve an existing conference
     */
    get: operations['RetrieveConference'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/hold': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Hold conference participants
     * @description Hold a list of participants in a conference call
     */
    post: operations['HoldConferenceParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/join': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Join a conference
     * @description Join an existing call leg to a conference. Issue the Join Conference command with the conference ID in the path and the `call_control_id` of the leg you wish to join to the conference as an attribute. The conference can have up to a certain amount of active participants, as set by the `max_participants` parameter in conference creation request.
     *
     *     **Expected Webhooks:**
     *
     *     - `conference.participant.joined`
     *     - `conference.participant.left`
     *
     */
    post: operations['JoinConference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/leave': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Leave a conference
     * @description Removes a call leg from a conference and moves it back to parked state. **Expected Webhooks:**
     *
     *     - `conference.participant.left`
     *
     */
    post: operations['LeaveConference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/mute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Mute conference participants
     * @description Mute a list of participants in a conference call
     */
    post: operations['MuteConferenceParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/play': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Play audio to conference participants
     * @description Play audio to all or some participants on a conference call.
     */
    post: operations['PlayConferenceAudio'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/record_pause': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Conference recording pause
     * @description Pause conference recording.
     */
    post: operations['PauseConferenceRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/record_resume': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Conference recording resume
     * @description Resume conference recording.
     */
    post: operations['ResumeConferenceRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/record_start': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Conference recording start
     * @description Start recording the conference. Recording will stop on conference end, or via the Stop Recording command.
     *
     *     **Expected Webhooks:**
     *
     *     - `conference.recording.saved`
     */
    post: operations['StartConferenceRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/record_stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Conference recording stop
     * @description Stop recording the conference.
     *
     *     **Expected Webhooks:**
     *
     *     - `conference.recording.saved`
     *
     */
    post: operations['StopConferenceRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/speak': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Speak text to conference participants
     * @description Convert text to speech and play it to all or some participants.
     */
    post: operations['SpeakTextToConference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Stop audio being played on the conference
     * @description Stop audio being played to all or some participants on a conference call.
     */
    post: operations['StopConferenceAudio'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/unhold': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unhold conference participants
     * @description Unhold a list of participants in a conference call
     */
    post: operations['UnholdConferenceParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/unmute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Unmute conference participants
     * @description Unmute a list of participants in a conference call
     */
    post: operations['UnmuteConferenceParticipants'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/conferences/{id}/actions/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update conference participant
     * @description Update conference participant supervisor_role
     */
    post: operations['UpdateConference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/connections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List connections
     * @description Returns a list of your connections irrespective of type.
     */
    get: operations['ListConnections'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/connections/{connection_id}/active_calls': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all active calls for given connection
     * @description Lists all active calls for given connection. Acceptable connections are either SIP connections with webhook_url or xml_request_url, call control or texml. Returned results are cursor paginated.
     *
     */
    get: operations['ListConnectionActiveCalls'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/connections/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a connection
     * @description Retrieves the high-level details of an existing connection. To retrieve specific authentication information, use the endpoint for the specific connection type.
     */
    get: operations['RetrieveConnection'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/country_coverage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get country coverage
     * @description Get country coverage
     */
    get: operations['retreiveCountryCoverage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/country_coverage/countries/{country_code}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get coverage for a specific country
     * @description Get coverage for a specific country
     */
    get: operations['retreiveSpecificCountryCoverage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/credential_connections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List credential connections
     * @description Returns a list of your credential connections.
     */
    get: operations['ListCredentialConnections'];
    put?: never;
    /**
     * Create a credential connection
     * @description Creates a credential connection.
     */
    post: operations['CreateCredentialConnection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/credential_connections/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a credential connection
     * @description Retrieves the details of an existing credential connection.
     */
    get: operations['RetrieveCredentialConnection'];
    put?: never;
    post?: never;
    /**
     * Delete a credential connection
     * @description Deletes an existing credential connection.
     */
    delete: operations['DeleteCredentialConnection'];
    options?: never;
    head?: never;
    /**
     * Update a credential connection
     * @description Updates settings of an existing credential connection.
     */
    patch: operations['UpdateCredentialConnection'];
    trace?: never;
  };
  '/credential_connections/{id}/actions/check_registration_status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a credential connection registration status
     * @description Updates the registration_status for a credential connection, this endpoint also updates the `registration_status` and `registration_status_updated_at` fields in the credential connection
     */
    post: operations['CheckRegistrationStatus'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/custom_storage_credentials/{connection_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a stored credential
     * @description Returns the information about custom storage credentials.
     */
    get: operations['GetCustomStorageCredentials'];
    /**
     * Update a stored credential
     * @description Updates a stored custom credentials configuration.
     */
    put: operations['UpdateCustomStorageCredentials'];
    /**
     * Create a custom storage credential
     * @description Creates a custom storage credentials configuration.
     */
    post: operations['CreateCustomStorageCredentials'];
    /**
     * Delete a stored credential
     * @description Deletes a stored custom credentials configuration.
     */
    delete: operations['DeleteCustomStorageCredentials'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/customer_service_records': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List customer service records
     * @description List customer service records.
     */
    get: operations['ListCustomerServiceRecords'];
    put?: never;
    /**
     * Create a customer service record
     * @description Create a new customer service record for the provided phone number.
     */
    post: operations['CreateCustomerServiceRecord'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/customer_service_records/phone_number_coverages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify CSR phone number coverage
     * @description Verify the coverage for a list of phone numbers.
     */
    post: operations['VerifyPhoneNumberCoverage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/customer_service_records/{customer_service_record_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a customer service record
     * @description Get a specific customer service record.
     */
    get: operations['GetCustomerServiceRecord'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/detail_records': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Search detail records
     * @description Search for any detail record across the Telnyx Platform
     */
    get: operations['SearchDetailRecords'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/dialogflow_connections/{connection_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve stored Dialogflow Connection
     * @description Return details of the Dialogflow connection associated with the given CallControl connection.
     */
    get: operations['GetDialogflowConnection'];
    /**
     * Update stored Dialogflow Connection
     * @description Updates a stored Dialogflow Connection.
     */
    put: operations['UpdateDialogflowConnection'];
    /**
     * Create a Dialogflow Connection
     * @description Save Dialogflow Credentiails to Telnyx, so it can be used with other Telnyx services.
     */
    post: operations['CreateDialogflowConnection'];
    /**
     * Delete stored Dialogflow Connection
     * @description Deletes a stored Dialogflow Connection.
     */
    delete: operations['DeleteDialogflowConnection'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/document_links': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all document links
     * @description List all documents links ordered by created_at descending.
     */
    get: operations['ListDocumentLinks'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documents': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all documents
     * @description List all documents ordered by created_at descending.
     */
    get: operations['ListDocuments'];
    put?: never;
    /**
     * Upload a document
     * @description Upload a document.<br /><br />Uploaded files must be linked to a service within 30 minutes or they will be automatically deleted.
     */
    post: operations['CreateDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/documents/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a document
     * @description Retrieve a document.
     */
    get: operations['RetrieveDocument'];
    put?: never;
    post?: never;
    /**
     * Delete a document
     * @description Delete a document.<br /><br />A document can only be deleted if it's not linked to a service. If it is linked to a service, it must be unlinked prior to deleting.
     */
    delete: operations['DeleteDocument'];
    options?: never;
    head?: never;
    /**
     * Update a document
     * @description Update a document.
     */
    patch: operations['UpdateDocument'];
    trace?: never;
  };
  '/documents/{id}/download': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Download a document
     * @description Download a document.
     */
    get: operations['DownloadDocument'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/dynamic_emergency_addresses': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List dynamic emergency addresses
     * @description Returns the dynamic emergency addresses according to filters
     */
    get: operations['ListDynamicEmergencyAddresses'];
    put?: never;
    /**
     * Create a dynamic emergency address.
     * @description Creates a dynamic emergency address.
     */
    post: operations['CreateDynamicEmergencyAddress'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/dynamic_emergency_addresses/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a dynamic emergency address
     * @description Returns the dynamic emergency address based on the ID provided
     */
    get: operations['GetDynamicEmergencyAddress'];
    put?: never;
    post?: never;
    /**
     * Delete a dynamic emergency address
     * @description Deletes the dynamic emergency address based on the ID provided
     */
    delete: operations['DeleteDynamicEmergencyAddress'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/dynamic_emergency_endpoints': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List dynamic emergency endpoints
     * @description Returns the dynamic emergency endpoints according to filters
     */
    get: operations['ListDynamicEmergencyEndpoints'];
    put?: never;
    /**
     * Create a dynamic emergency endpoint.
     * @description Creates a dynamic emergency endpoints.
     */
    post: operations['CreateDynamicEmergencyEndpoint'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/dynamic_emergency_endpoints/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a dynamic emergency endpoint
     * @description Returns the dynamic emergency endpoint based on the ID provided
     */
    get: operations['GetDynamicEmergencyEndpoint'];
    put?: never;
    post?: never;
    /**
     * Delete a dynamic emergency endpoint
     * @description Deletes the dynamic emergency endpoint based on the ID provided
     */
    delete: operations['DeleteDynamicEmergencyEndpoint'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/enum/{endpoint}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Enum */
    get: operations['GetEnumEndpoint'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all External Connections
     * @description This endpoint returns a list of your External Connections inside the 'data' attribute of the response. External Connections are used by Telnyx customers to seamless configure SIP trunking integrations with Telnyx Partners, through External Voice Integrations in Mission Control Portal.
     */
    get: operations['ListExternalConnections'];
    put?: never;
    /**
     * Creates an External Connection
     * @description Creates a new External Connection based on the parameters sent in the request. The external_sip_connection and outbound voice profile id are required. Once created, you can assign phone numbers to your application using the `/phone_numbers` endpoint.
     */
    post: operations['CreateExternalConnection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/log_messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all log messages
     * @description Retrieve a list of log messages for all external connections associated with your account.
     */
    get: operations['ListExternalConnectionLogMessages'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/log_messages/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a log message
     * @description Retrieve a log message for an external connection associated with your account.
     */
    get: operations['GetExternalConnectionLogMessage'];
    put?: never;
    post?: never;
    /**
     * Dismiss a log message
     * @description Dismiss a log message for an external connection associated with your account.
     */
    delete: operations['DeleteExternalConnectionLogMessage'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an External Connection
     * @description Return the details of an existing External Connection inside the 'data' attribute of the response.
     */
    get: operations['GetExternalConnection'];
    put?: never;
    post?: never;
    /**
     * Deletes an External Connection
     * @description Permanently deletes an External Connection. Deletion may be prevented if the application is in use by phone numbers, is active, or if it is an Operator Connect connection. To remove an Operator Connect integration please contact Telnyx support.
     */
    delete: operations['DeleteExternalConnection'];
    options?: never;
    head?: never;
    /**
     * Update an External Connection
     * @description Updates settings of an existing External Connection based on the parameters of the request.
     */
    patch: operations['UpdateExternalConnection'];
    trace?: never;
  };
  '/external_connections/{id}/civic_addresses': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all civic addresses and locations
     * @description Returns the civic addresses and locations from Microsoft Teams.
     */
    get: operations['ListCivicAddresses'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/civic_addresses/{address_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Civic Address
     * @description Return the details of an existing Civic Address with its Locations inside the 'data' attribute of the response.
     */
    get: operations['GetExternalConnectionCivicAddress'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all phone numbers
     * @description Returns a list of all active phone numbers associated with the given external connection.
     */
    get: operations['ListExternalConnectionPhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/phone_numbers/{phone_number_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a phone number
     * @description Return the details of a phone number associated with the given external connection.
     */
    get: operations['GetExternalConnectionPhoneNumber'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a phone number
     * @description Asynchronously update settings of the phone number associated with the given external connection.
     */
    patch: operations['UpdateExternalConnectionPhoneNumber'];
    trace?: never;
  };
  '/external_connections/{id}/releases': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Releases
     * @description Returns a list of your Releases for the given external connection. These are automatically created when you change the `connection_id` of a phone number that is currently on Microsoft Teams.
     */
    get: operations['ListExternalConnectionReleases'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/releases/{release_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Release request
     * @description Return the details of a Release request and its phone numbers.
     */
    get: operations['GetExternalConnectionRelease'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/uploads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Upload requests
     * @description Returns a list of your Upload requests for the given external connection.
     */
    get: operations['ListExternalConnectionUploads'];
    put?: never;
    /**
     * Creates an Upload request
     * @description Creates a new Upload request to Microsoft teams with the included phone numbers. Only one of civic_address_id or location_id must be provided, not both. The maximum allowed phone numbers for the numbers_ids array is 1000.
     */
    post: operations['CreateExternalConnectionUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/uploads/refresh': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Refresh the status of all Upload requests
     * @description Forces a recheck of the status of all pending Upload requests for the given external connection in the background.
     */
    post: operations['RefreshExternalConnectionUploads'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/uploads/status': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get the count of pending upload requests
     * @description Returns the count of all pending upload requests for the given external connection.
     */
    get: operations['GetExternalConnectionUploadsStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/uploads/{ticket_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an Upload request
     * @description Return the details of an Upload request and its phone numbers.
     */
    get: operations['GetExternalConnectionUpload'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/external_connections/{id}/uploads/{ticket_id}/retry': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retry an Upload request
     * @description If there were any errors during the upload process, this endpoint will retry the upload request. In some cases this will reattempt the existing upload request, in other cases it may create a new upload request. Please check the ticket_id in the response to determine if a new upload request was created.
     */
    post: operations['RetryUpload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/fax_applications': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Fax Applications
     * @description This endpoint returns a list of your Fax Applications inside the 'data' attribute of the response. You can adjust which applications are listed by using filters. Fax Applications are used to configure how you send and receive faxes using the Programmable Fax API with Telnyx.
     */
    get: operations['ListFaxApplications'];
    put?: never;
    /**
     * Creates a Fax Application
     * @description Creates a new Fax Application based on the parameters sent in the request. The application name and webhook URL are required. Once created, you can assign phone numbers to your application using the `/phone_numbers` endpoint.
     */
    post: operations['CreateFaxApplication'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/fax_applications/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Fax Application
     * @description Return the details of an existing Fax Application inside the 'data' attribute of the response.
     */
    get: operations['GetFaxApplication'];
    put?: never;
    post?: never;
    /**
     * Deletes a Fax Application
     * @description Permanently deletes a Fax Application. Deletion may be prevented if the application is in use by phone numbers.
     */
    delete: operations['DeleteFaxApplication'];
    options?: never;
    head?: never;
    /**
     * Update a Fax Application
     * @description Updates settings of an existing Fax Application based on the parameters of the request.
     */
    patch: operations['UpdateFaxApplication'];
    trace?: never;
  };
  '/faxes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of faxes */
    get: operations['ListFaxes'];
    put?: never;
    /**
     * Send a fax
     * @description Send a fax. Files have size limits and page count limit validations. If a file is bigger than 50MB or has more than 350 pages it will fail with `file_size_limit_exceeded` and `page_count_limit_exceeded` respectively.
     *
     *     **Expected Webhooks:**
     *
     *     - `fax.queued`
     *     - `fax.media.processed`
     *     - `fax.sending.started`
     *     - `fax.delivered`
     *     - `fax.failed`
     *
     */
    post: operations['SendFax'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faxes/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a fax */
    get: operations['ViewFax'];
    put?: never;
    post?: never;
    /** Delete a fax */
    delete: operations['DeleteFax'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faxes/{id}/actions/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a fax
     * @description Cancel the outbound fax that is in one of the following states: `queued`, `media.processed`, `originated` or `sending`
     */
    post: operations['CancelFax'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/faxes/{id}/actions/refresh': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Refresh a fax
     * @description Refreshes the inbound fax's media_url when it has expired
     */
    post: operations['RefreshFax'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/fqdn_connections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List FQDN connections
     * @description Returns a list of your FQDN connections.
     */
    get: operations['ListFqdnConnections'];
    put?: never;
    /**
     * Create an FQDN connection
     * @description Creates a FQDN connection.
     */
    post: operations['CreateFqdnConnection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/fqdn_connections/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an FQDN connection
     * @description Retrieves the details of an existing FQDN connection.
     */
    get: operations['RetrieveFqdnConnection'];
    put?: never;
    post?: never;
    /**
     * Delete an FQDN connection
     * @description Deletes an FQDN connection.
     */
    delete: operations['DeleteFqdnConnection'];
    options?: never;
    head?: never;
    /**
     * Update an FQDN connection
     * @description Updates settings of an existing FQDN connection.
     */
    patch: operations['UpdateFqdnConnection'];
    trace?: never;
  };
  '/fqdns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List FQDNs
     * @description Get all FQDNs belonging to the user that match the given filters.
     */
    get: operations['ListFqdns'];
    put?: never;
    /**
     * Create an FQDN
     * @description Create a new FQDN object.
     */
    post: operations['CreateFqdn'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/fqdns/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an FQDN
     * @description Return the details regarding a specific FQDN.
     */
    get: operations['RetrieveFqdn'];
    put?: never;
    post?: never;
    /**
     * Delete an FQDN
     * @description Delete an FQDN.
     */
    delete: operations['DeleteFqdn'];
    options?: never;
    head?: never;
    /**
     * Update an FQDN
     * @description Update the details of a specific FQDN.
     */
    patch: operations['UpdateFqdn'];
    trace?: never;
  };
  '/global_ip_allowed_ports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Global IP Allowed Ports
     * @description List all Global IP Allowed Ports
     */
    get: operations['ListGlobalIpAllowedPorts'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_assignment_health': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['GetGlobalIpAssignmentHealth'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_assignments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Global IP assignments
     * @description List all Global IP assignments.
     */
    get: operations['ListGlobalIpAssignments'];
    put?: never;
    /**
     * Create a Global IP assignment
     * @description Create a Global IP assignment.
     */
    post: operations['CreateGlobalIpAssignment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_assignments/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Global IP
     * @description Retrieve a Global IP assignment.
     */
    get: operations['GetGlobalIpAssignment'];
    put?: never;
    post?: never;
    /**
     * Delete a Global IP assignment
     * @description Delete a Global IP assignment.
     */
    delete: operations['DeleteGlobalIpAssignment'];
    options?: never;
    head?: never;
    /**
     * Update a Global IP assignment
     * @description Update a Global IP assignment.
     */
    patch: operations['UpdateGlobalIpAssignment'];
    trace?: never;
  };
  '/global_ip_assignments_usage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['GetGlobalIpAssignmentUsage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_health_check_types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Global IP Health check types
     * @description List all Global IP Health check types.
     */
    get: operations['ListGlobalIpHealthCheckTypes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_health_checks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Global IP health checks
     * @description List all Global IP health checks.
     */
    get: operations['ListGlobalIpHealthChecks'];
    put?: never;
    /**
     * Create a Global IP health check
     * @description Create a Global IP health check.
     */
    post: operations['CreateGlobalIpHealthCheck'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_health_checks/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Global IP health check
     * @description Retrieve a Global IP health check.
     */
    get: operations['GetGlobalIpHealthCheck'];
    put?: never;
    post?: never;
    /**
     * Delete a Global IP health check
     * @description Delete a Global IP health check.
     */
    delete: operations['DeleteGlobalIpHealthCheck'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_latency': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['GetGlobalIpLatency'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_protocols': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Global IP Protocols
     * @description List all Global IP Protocols
     */
    get: operations['ListGlobalIpProtocols'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ip_usage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get: operations['GetGlobalIpUsage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ips': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Global IPs
     * @description List all Global IPs.
     */
    get: operations['ListGlobalIps'];
    put?: never;
    /**
     * Create a Global IP
     * @description Create a Global IP.
     */
    post: operations['CreateGlobalIp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/global_ips/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Global IP
     * @description Retrieve a Global IP.
     */
    get: operations['GetGlobalIp'];
    put?: never;
    post?: never;
    /**
     * Delete a Global IP
     * @description Delete a Global IP.
     */
    delete: operations['DeleteGlobalIp'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/inventory_coverage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Create an inventory coverage request
     * @description Creates an inventory coverage request. If locality, npa or national_destination_code is used in groupBy, and no region or locality filters are used, the whole paginated set is returned.
     */
    get: operations['CreateInventoryCoverage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ip_connections': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Ip connections
     * @description Returns a list of your IP connections.
     */
    get: operations['ListIpConnections'];
    put?: never;
    /**
     * Create an Ip connection
     * @description Creates an IP connection.
     */
    post: operations['CreateIpConnection'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ip_connections/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an Ip connection
     * @description Retrieves the details of an existing ip connection.
     */
    get: operations['RetrieveIpConnection'];
    put?: never;
    post?: never;
    /**
     * Delete an Ip connection
     * @description Deletes an existing IP connection.
     */
    delete: operations['DeleteIpConnection'];
    options?: never;
    head?: never;
    /**
     * Update an Ip connection
     * @description Updates settings of an existing IP connection.
     */
    patch: operations['UpdateIpConnection'];
    trace?: never;
  };
  '/ips': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Ips
     * @description Get all IPs belonging to the user that match the given filters.
     */
    get: operations['ListIps'];
    put?: never;
    /**
     * Create an Ip
     * @description Create a new IP object.
     */
    post: operations['CreateIp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ips/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an Ip
     * @description Return the details regarding a specific IP.
     */
    get: operations['RetrieveIp'];
    put?: never;
    post?: never;
    /**
     * Delete an Ip
     * @description Delete an IP.
     */
    delete: operations['DeleteIp'];
    options?: never;
    head?: never;
    /**
     * Update an Ip
     * @description Update the details of a specific IP.
     */
    patch: operations['UpdateIp'];
    trace?: never;
  };
  '/ledger_billing_group_reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Create a ledger billing group report */
    post: operations['CreateBillingGroupReport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ledger_billing_group_reports/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a ledger billing group report */
    get: operations['GetBillingGroupReport'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/managed_accounts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Lists accounts managed by the current user.
     * @description Lists the accounts managed by the current user. Users need to be explictly approved by Telnyx in order to become manager accounts.
     */
    get: operations['ListManagedAccounts'];
    put?: never;
    /**
     * Create a new managed account.
     * @description Create a new managed account owned by the authenticated user. You need to be explictly approved by Telnyx in order to become a manager account.
     */
    post: operations['CreateManagedAccount'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/managed_accounts/allocatable_global_outbound_channels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Display information about allocatable global outbound channels for the current user.
     * @description Display information about allocatable global outbound channels for the current user. Only usable by account managers.
     */
    get: operations['ListAllocatableGlobalOutboundChannels'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/managed_accounts/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a managed account
     * @description Retrieves the details of a single managed account.
     */
    get: operations['RetrieveManagedAccount'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a managed account
     * @description Update a single managed account.
     */
    patch: operations['UpdateManagedAccount'];
    trace?: never;
  };
  '/managed_accounts/{id}/actions/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Disables a managed account
     * @description Disables a managed account, forbidding it to use Telnyx services, including sending or receiving phone calls and SMS messages. Ongoing phone calls will not be affected. The managed account and its sub-users will no longer be able to log in via the mission control portal.
     */
    post: operations['DisableManagedAccount'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/managed_accounts/{id}/actions/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Enables a managed account
     * @description Enables a managed account and its sub-users to use Telnyx services.
     */
    post: operations['EnableManagedAccount'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/managed_accounts/{id}/update_global_channel_limit': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update the amount of allocatable global outbound channels allocated to a specific managed account.
     * @description Update the amount of allocatable global outbound channels allocated to a specific managed account.
     */
    patch: operations['UpdateManagedAccountGlobalChannelLimit'];
    trace?: never;
  };
  '/media': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List uploaded media
     * @description Returns a list of stored media files.
     */
    get: operations['ListMediaStorage'];
    put?: never;
    /**
     * Upload media
     * @description Upload media file to Telnyx so it can be used with other Telnyx services
     */
    post: operations['CreateMediaStorage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/media/{media_name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve stored media
     * @description Returns the information about a stored media file.
     */
    get: operations['GetMediaStorage'];
    /**
     * Update stored media
     * @description Updates a stored media file.
     */
    put: operations['UpdateMediaStorage'];
    post?: never;
    /**
     * Deletes stored media
     * @description Deletes a stored media file.
     */
    delete: operations['DeleteMediaStorage'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/media/{media_name}/download': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Download stored media
     * @description Downloads a stored media file.
     */
    get: operations['DownloadMedia'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messages': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send a message
     * @description Send a message with a Phone Number, Alphanumeric Sender ID, Short Code or Number Pool.
     *
     *     This endpoint allows you to send a message with any messaging resource.
     *     Current messaging resources include: long-code, short-code, number-pool, and
     *     alphanumeric-sender-id.
     *
     */
    post: operations['SendMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messages/group_mms': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send a group MMS message */
    post: operations['CreateGroupMmsMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messages/long_code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send a long code message */
    post: operations['CreateLongCodeMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messages/number_pool': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send a message using number pool */
    post: operations['CreateNumberPoolMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messages/short_code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Send a short code message */
    post: operations['CreateShortCodeMessage'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messages/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a message
     * @description Note: This API endpoint can only retrieve messages that are no older than 10 days since their creation. If you require messages older than this, please generate an [MDR report.](https://developers.telnyx.com/api/v1/mission-control/add-mdr-request)
     */
    get: operations['GetMessage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_hosted_number_orders': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List messaging hosted number orders */
    get: operations['ListMessagingHostedNumberOrders'];
    put?: never;
    /** Create a messaging hosted number order */
    post: operations['CreateMessagingHostedNumberOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_hosted_number_orders/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a messaging hosted number order */
    get: operations['GetMessagingHostedNumberOrder'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_hosted_number_orders/{id}/actions/file_upload': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Upload file required for a messaging hosted number order */
    post: operations['UploadMessagingHostedNumberOrderFile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_hosted_numbers/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /** Delete a messaging hosted number */
    delete: operations['DeleteMessagingHostedNumber'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_numbers_bulk_updates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Update the messaging profile of multiple phone numbers */
    post: operations['BulkUpdateMessagingSettingsOnPhoneNumbers'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_numbers_bulk_updates/{order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve bulk update status */
    get: operations['GetBulkUpdateMessagingSettingsOnPhoneNumbersStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profile_metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List messaging profile metrics */
    get: operations['ListProfileMetrics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profiles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List messaging profiles */
    get: operations['ListMessagingProfiles'];
    put?: never;
    /** Create a messaging profile */
    post: operations['CreateMessagingProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profiles/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a messaging profile */
    get: operations['RetrieveMessagingProfile'];
    put?: never;
    post?: never;
    /** Delete a messaging profile */
    delete: operations['DeleteMessagingProfile'];
    options?: never;
    head?: never;
    /** Update a messaging profile */
    patch: operations['UpdateMessagingProfile'];
    trace?: never;
  };
  '/messaging_profiles/{id}/metrics': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve messaging profile metrics */
    get: operations['GetMessagingProfileMetrics'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profiles/{id}/phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List phone numbers associated with a messaging profile */
    get: operations['ListProfilePhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profiles/{id}/short_codes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List short codes associated with a messaging profile */
    get: operations['ListProfileShortCodes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profiles/{profile_id}/autoresp_configs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Auto-Response Settings */
    get: operations['GetAutorespConfigs'];
    put?: never;
    /** Create Auto-Reponse Setting */
    post: operations['CreateAutorespConfig'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_profiles/{profile_id}/autoresp_configs/{autoresp_cfg_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Auto-Response Setting */
    get: operations['GetAutorespConfig'];
    /** Update Auto-Response Setting */
    put: operations['UpdateAutoRespConfig'];
    post?: never;
    /** Delete Auto-Response Setting */
    delete: operations['DeleteAutorespConfig'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_tollfree/verification/requests': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Verification Requests
     * @description Get a list of previously-submitted tollfree verification requests
     */
    get: operations['ListVerificationRequests'];
    put?: never;
    /**
     * Submit Verification Request
     * @description Submit a new tollfree verification request
     */
    post: operations['SubmitVerificationRequest'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/messaging_tollfree/verification/requests/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Verification Request
     * @description Get a single verification request by its ID.
     */
    get: operations['GetVerificationRequest'];
    put?: never;
    post?: never;
    /**
     * Delete Verification Request
     * @description Delete a verification request
     *
     *     A request may only be deleted when when the request is in the "rejected" state.
     *
     *     * `HTTP 200`: request successfully deleted
     *     * `HTTP 400`: request exists but can't be deleted (i.e. not rejected)
     *     * `HTTP 404`: request unknown or already deleted
     */
    delete: operations['DeleteVerificationRequest'];
    options?: never;
    head?: never;
    /**
     * Update Verification Request
     * @description Update an existing tollfree verification request. This is particularly useful when there are pending customer actions to be taken.
     */
    patch: operations['UpdateVerificationRequest'];
    trace?: never;
  };
  '/messaging_url_domains': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List messaging URL domains */
    get: operations['ListMessagingUrlDomains'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mobile_network_operators': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List mobile network operators
     * @description Telnyx has a set of GSM mobile operators partners that are available through our mobile network roaming. This resource is entirely managed by Telnyx and may change over time. That means that this resource won't allow any write operations for it. Still, it's available so it can be used as a support resource that can be related to other resources or become a configuration option.
     */
    get: operations['GetMobileNetworkOperators'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mobile_push_credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List mobile push credentials
     * @description List mobile push credentials
     */
    get: operations['ListPushCredentials'];
    put?: never;
    /**
     * Creates a new mobile push credential
     * @description Creates a new mobile push credential
     */
    post: operations['CreatePushCredential'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/mobile_push_credentials/{push_credential_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieves a mobile push credential
     * @description Retrieves mobile push credential based on the given `push_credential_id`
     */
    get: operations['GetPushCredentialById'];
    put?: never;
    post?: never;
    /**
     * Deletes a mobile push credential
     * @description Deletes a mobile push credential based on the given `push_credential_id`
     */
    delete: operations['DeletePushCredentialById'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/network_coverage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List network coverage locations
     * @description List all locations and the interfaces that region supports
     */
    get: operations['ListNetworkCoverage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/networks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Networks
     * @description List all Networks.
     */
    get: operations['ListNetworks'];
    put?: never;
    /**
     * Create a Network
     * @description Create a new Network.
     */
    post: operations['CreateNetwork'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/networks/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Network
     * @description Retrieve a Network.
     */
    get: operations['GetNetwork'];
    put?: never;
    post?: never;
    /**
     * Delete a Network
     * @description Delete a Network.
     */
    delete: operations['DeleteNetwork'];
    options?: never;
    head?: never;
    /**
     * Update a Network
     * @description Update a Network.
     */
    patch: operations['UpdateNetwork'];
    trace?: never;
  };
  '/networks/{id}/default_gateway': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Default Gateway status.
     * @description Get Default Gateway status.
     */
    get: operations['GetDefaultGateway'];
    put?: never;
    /**
     * Create Default Gateway.
     * @description Create Default Gateway.
     */
    post: operations['CreateDefaultGateway'];
    /**
     * Delete Default Gateway.
     * @description Delete Default Gateway.
     */
    delete: operations['DeleteDefaultGateway'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/networks/{id}/network_interfaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Interfaces for a Network.
     * @description List all Interfaces for a Network.
     */
    get: operations['ListNetworkInterfaces'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification_channels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List notification channels
     * @description List notification channels.
     */
    get: operations['ListNotificationChannels'];
    put?: never;
    /**
     * Create a notification channel
     * @description Create a notification channel.
     */
    post: operations['CreateNotificationChannels'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification_channels/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a notification channel
     * @description Get a notification channel.
     */
    get: operations['GetNotificationChannel'];
    put?: never;
    post?: never;
    /**
     * Delete a notification channel
     * @description Delete a notification channel.
     */
    delete: operations['DeleteNotificationChannel'];
    options?: never;
    head?: never;
    /**
     * Update a notification channel
     * @description Update a notification channel.
     */
    patch: operations['UpdateNotificationChannel'];
    trace?: never;
  };
  '/notification_event_conditions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Notifications Events Conditions
     * @description Returns a list of your notifications events conditions.
     */
    get: operations['FindNotificationsEventsConditions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification_events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Notifications Events
     * @description Returns a list of your notifications events.
     */
    get: operations['FindNotificationsEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification_profiles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Notifications Profiles
     * @description Returns a list of your notifications profiles.
     */
    get: operations['FindNotificationsProfiles'];
    put?: never;
    /**
     * Create a notification profile
     * @description Create a notification profile.
     */
    post: operations['CreateNotificationProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification_profiles/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a notification profile
     * @description Get a notification profile.
     */
    get: operations['GetNotificationProfile'];
    put?: never;
    post?: never;
    /**
     * Delete a notification profile
     * @description Delete a notification profile.
     */
    delete: operations['DeleteNotificationProfile'];
    options?: never;
    head?: never;
    /**
     * Update a notification profile
     * @description Update a notification profile.
     */
    patch: operations['UpdateNotificationProfile'];
    trace?: never;
  };
  '/notification_settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List notification settings
     * @description List notification settings.
     */
    get: operations['ListNotificationSettings'];
    put?: never;
    /**
     * Add a Notification Setting
     * @description Add a notification setting.
     */
    post: operations['CreateNotificationSetting'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/notification_settings/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a notification setting
     * @description Get a notification setting.
     */
    get: operations['GetNotificationSetting'];
    put?: never;
    post?: never;
    /**
     * Delete a notification setting
     * @description Delete a notification setting.
     */
    delete: operations['DeleteNotificationSetting'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_block_orders': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List number block orders
     * @description Get a paginated list of number block orders.
     */
    get: operations['ListNumberBlockOrders'];
    put?: never;
    /**
     * Create a number block order
     * @description Creates a phone number block order.
     */
    post: operations['CreateNumberBlockOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_block_orders/{number_block_order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a number block order
     * @description Get an existing phone number block order.
     */
    get: operations['RetrieveNumberBlockOrder'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_lookup/{phone_number}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Lookup phone number data
     * @description Returns information about the provided phone number.
     */
    get: operations['LookupNumber'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_order_documents': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List number order documents
     * @description Gets a paginated list of number order documents.
     */
    get: operations['ListNumberOrderDocuments'];
    put?: never;
    /**
     * Create a number order document
     * @description Upload a phone number order document.
     */
    post: operations['CreateNumberOrderDocument'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_order_documents/{number_order_document_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a number order document
     * @description Gets a single number order document.
     */
    get: operations['RetrieveNumberOrderDocument'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a number order document
     * @description Updates a number order document.
     */
    patch: operations['UpdateNumberOrderDocument'];
    trace?: never;
  };
  '/number_order_phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a list of phone numbers associated to orders
     * @description Get a list of phone numbers associated to orders.
     */
    get: operations['RetrieveOrderPhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_order_phone_numbers/{number_order_phone_number_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a single phone number within a number order.
     * @description Get an existing phone number in number order.
     */
    get: operations['GetNumberOrderPhoneNumber'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update requirements for a single phone number within a number order.
     * @description Updates requirements for a single phone number within a number order.
     */
    patch: operations['UpdateNumberOrderPhoneNumber'];
    trace?: never;
  };
  '/number_orders': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List number orders
     * @description Get a paginated list of number orders.
     */
    get: operations['ListNumberOrders'];
    put?: never;
    /**
     * Create a number order
     * @description Creates a phone number order.
     */
    post: operations['CreateNumberOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_orders/{number_order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a number order
     * @description Get an existing phone number order.
     */
    get: operations['RetrieveNumberOrder'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a number order
     * @description Updates a phone number order.
     */
    patch: operations['UpdateNumberOrder'];
    trace?: never;
  };
  '/number_reservations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List number reservations
     * @description Gets a paginated list of phone number reservations.
     */
    get: operations['ListNumberReservations'];
    put?: never;
    /**
     * Create a number reservation
     * @description Creates a Phone Number Reservation for multiple numbers.
     */
    post: operations['CreateNumberReservation'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_reservations/{number_reservation_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a number reservation
     * @description Gets a single phone number reservation.
     */
    get: operations['RetrieveNumberReservation'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/number_reservations/{number_reservation_id}/actions/extend': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Extend a number reservation
     * @description Extends reservation expiry time on all phone numbers.
     */
    post: operations['ExtendNumberReservationExpiryTime'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/numbers_features': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Retrieve the features for a list of numbers
     * @description Retrieve the features for a list of numbers
     */
    post: operations['PostNumbersFeatures'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ota_updates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List OTA updates */
    get: operations['ListOtaUpdates'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/ota_updates/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get OTA update
     * @description This API returns the details of an Over the Air (OTA) update.
     */
    get: operations['GetOtaUpdate'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/outbound_voice_profiles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all outbound voice profiles
     * @description Get all outbound voice profiles belonging to the user that match the given filters.
     */
    get: operations['ListOutboundVoiceProfiles'];
    put?: never;
    /**
     * Create an outbound voice profile
     * @description Create an outbound voice profile.
     */
    post: operations['CreateVoiceProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/outbound_voice_profiles/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve an outbound voice profile
     * @description Retrieves the details of an existing outbound voice profile.
     */
    get: operations['GetOutboundVoiceProfile'];
    put?: never;
    post?: never;
    /**
     * Delete an outbound voice profile
     * @description Deletes an existing outbound voice profile.
     */
    delete: operations['DeleteOutboundVoiceProfile'];
    options?: never;
    head?: never;
    /**
     * Updates an existing outbound voice profile.
     * @description Updates an existing outbound voice profile.
     */
    patch: operations['UpdateOutboundVoiceProfile'];
    trace?: never;
  };
  '/partnerCampaign/sharedByMe': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Partner Campaigns Shared By User
     * @description Get all partner campaigns you have shared to Telnyx in a paginated fashion
     *
     *     This endpoint is currently limited to only returning shared campaigns that Telnyx
     *     has accepted. In other words, shared but pending campaigns are currently omitted
     *     from the response from this endpoint.
     */
    get: operations['GetPartnerCampaignsSharedByUser'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/partnerCampaign/{campaignId}/sharing': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get Sharing Status */
    get: operations['GetPartnerCampaignSharingStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/payment/auto_recharge_prefs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List auto recharge preferences
     * @description Returns the payment auto recharge preferences.
     */
    get: operations['GetAutoRechargePrefs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update auto recharge preferences
     * @description Update payment auto recharge preferences.
     */
    patch: operations['UpdateAutoRechargePrefs'];
    trace?: never;
  };
  '/phoneNumberAssignmentByProfile': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Assign Messaging Profile To Campaign
     * @description This endpoint allows you to link all phone numbers associated with a Messaging Profile to a campaign. **Please note:** if you want to assign phone numbers to a campaign that you did not create with Telnyx 10DLC services, this endpoint allows that provided that you've shared the campaign with Telnyx. In this case, only provide the parameter, `tcrCampaignId`, and not `campaignId`. In all other cases (where the campaign you're assigning was created with Telnyx 10DLC services), only provide `campaignId`, not `tcrCampaignId`.
     */
    post: operations['PostAssignMessagingProfileToCampaign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phoneNumberAssignmentByProfile/{taskId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Assignment Task Status
     * @description Check the status of the task associated with assigning all phone numbers on a messaging profile to a campaign by `taskId`.
     */
    get: operations['GetAssignmentTaskStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phoneNumberAssignmentByProfile/{taskId}/phoneNumbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Phone Number Status
     * @description Check the status of the individual phone number/campaign assignments associated with the supplied `taskId`.
     */
    get: operations['GetPhoneNumberStatus'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phoneNumberCampaign': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve All Phone Number Campaigns
     * @description Retrieve all of your organization's phone number/campaign assignments.
     */
    get: operations['GetAllPhoneNumberCampaignsCamelCase'];
    put?: never;
    /**
     * Create New Phone Number Campaign
     * @description Assign an individual phone number to campaign.
     */
    post: operations['CreatePhoneNumberCampaignCamelCase'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phoneNumberCampaign/{phoneNumber}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Single Phone Number Campaign
     * @description Retrieve an individual phone number/campaign assignment by `phoneNumber`.
     */
    get: operations['GetPhoneNumberCampaign'];
    /**
     * Create New Phone Number Campaign
     * @description This endpoint allows you to assign a different campaign to a supplied `phoneNumber`.
     */
    put: operations['CreatePhoneNumberCampaignCamelCasePut'];
    post?: never;
    /**
     * Delete Phone Number Campaign
     * @description This endpoint allows you to remove a campaign assignment from the supplied `phoneNumber`.
     */
    delete: operations['DeletePhoneNumberCampaignCamelCase'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_number_blocks/jobs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists the phone number blocks jobs */
    get: operations['ListPhoneNumberBlocksJobs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_number_blocks/jobs/delete_phone_number_block': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Deletes all numbers associated with a phone number block
     * @description Creates a new background job to delete all the phone numbers associated with the given block. We will only consider the phone number block as deleted after all phone numbers associated with it are removed, so multiple executions of this job may be necessary in case some of the phone numbers present errors during the deletion process.
     */
    post: operations['CreatePhoneNumberBlockDeletionJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_number_blocks/jobs/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieves a phone number blocks job */
    get: operations['GetPhoneNumberBlocksJob'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_number_campaigns': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve All Phone Number Campaigns */
    get: operations['GetAllPhoneNumberCampaigns'];
    put?: never;
    /** Create New Phone Number Campaign */
    post: operations['CreatePhoneNumberCampaign'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_number_campaigns/{phoneNumber}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Single Phone Number Campaign
     * @description Retrieve an individual phone number/campaign assignment by `phoneNumber`.
     */
    get: operations['GetSinglePhoneNumberCampaign'];
    /** Create New Phone Number Campaign */
    put: operations['PutPhoneNumberCampaign'];
    post?: never;
    /**
     * Delete Phone Number Campaign
     * @description This endpoint allows you to remove a campaign assignment from the supplied `phoneNumber`.
     */
    delete: operations['DeletePhoneNumberCampaign'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List phone numbers */
    get: operations['ListPhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/csv_downloads': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List CSV downloads */
    get: operations['ListCsvDownloads'];
    put?: never;
    /** Create a CSV download */
    post: operations['CreateCsvDownload'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/csv_downloads/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a CSV download */
    get: operations['GetCsvDownload'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/inbound_channels': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List your inbound channels
     * @description Returns the inbound channels for your account. Inbound channels allows you to use Channel Billing for calls to your Telnyx phone numbers. Please check the Telnyx Support Articles section for full information and examples of how to utilize Channel Billing.
     */
    get: operations['ListInboundChannels'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update inbound channels
     * @description Update the inbound channels for the account
     */
    patch: operations['UpdateOutboundChannels'];
    trace?: never;
  };
  '/phone_numbers/jobs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Lists the phone numbers jobs */
    get: operations['ListPhoneNumbersJobs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/jobs/delete_phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete a batch of numbers
     * @description Creates a new background job to delete a batch of numbers. At most one thousand numbers can be updated per API call.
     */
    post: operations['CreateDeletePhoneNumbersJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/jobs/update_emergency_settings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update the emergency settings from a batch of numbers
     * @description Creates a background job to update the emergency settings of a collection of phone numbers. At most one thousand numbers can be updated per API call.
     */
    post: operations['CreatePhoneNumbersJobUpdateEmergencySettings'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/jobs/update_phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update a batch of numbers
     * @description Creates a new background job to update a batch of numbers. At most one thousand numbers can be updated per API call. At least one of the updateable fields must be submitted.
     */
    post: operations['CreateUpdatePhoneNumbersJob'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/jobs/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a phone numbers job */
    get: operations['RetrievePhoneNumbersJob'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/messaging': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List phone numbers with messaging settings */
    get: operations['ListPhoneNumbersWithMessagingSettings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/slim': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Slim List phone numbers
     * @description List phone numbers, This endpoint is a lighter version of the /phone_numbers endpoint having higher performance and rate limit.
     */
    get: operations['SlimListPhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/voice': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List phone numbers with voice settings */
    get: operations['ListPhoneNumbersWithVoiceSettings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a phone number */
    get: operations['RetrievePhoneNumber'];
    put?: never;
    post?: never;
    /** Delete a phone number */
    delete: operations['DeletePhoneNumber'];
    options?: never;
    head?: never;
    /** Update a phone number */
    patch: operations['UpdatePhoneNumber'];
    trace?: never;
  };
  '/phone_numbers/{id}/actions/enable_emergency': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Enable emergency for a phone number */
    post: operations['EnablePhoneNumberEmergency'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/phone_numbers/{id}/messaging': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a phone number with messaging settings */
    get: operations['GetPhoneNumberMessagingSettings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** Update the messaging profile and/or messaging product of a phone number */
    patch: operations['UpdatePhoneNumberMessagingSettings'];
    trace?: never;
  };
  '/phone_numbers/{id}/voice': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a phone number with voice settings */
    get: operations['GetPhoneNumberVoiceSettings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** Update a phone number with voice settings */
    patch: operations['UpdatePhoneNumberVoiceSettings'];
    trace?: never;
  };
  '/phone_numbers/{phone_number_id}/voicemail': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The ID of the phone number.
         * @example 123455678900
         */
        phone_number_id: string;
      };
      cookie?: never;
    };
    /**
     * Get voicemail
     * @description Returns the voicemail settings for a phone number
     */
    get: operations['GetVoicemail'];
    put?: never;
    /**
     * Create voicemail
     * @description Create voicemail settings for a phone number
     */
    post: operations['CreateVoicemail'];
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update voicemail
     * @description Update voicemail settings for a phone number
     */
    patch: operations['UpdateVoicemail'];
    trace?: never;
  };
  '/phone_numbers_regulatory_requirements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve regulatory requirements for a list of phone numbers */
    get: operations['ListRegulatoryRequirementsPhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portability_checks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Run a portability check
     * @description Runs a portability check, returning the results immediately.
     */
    post: operations['PostPortabilityCheck'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all porting events
     * @description Returns a list of all porting events.
     */
    get: operations['listPortingEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/events/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Show a porting event
     * @description Show a specific porting event.
     */
    get: operations['showPortingEvent'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/events/{id}/republish': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Republish a porting event
     * @description Republish a specific porting event.
     */
    post: operations['republishPortingEvent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/loa_configuration/preview': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Preview the LOA configuration parameters
     * @description Preview the LOA template that would be generated without need to create LOA configuration.
     */
    post: operations['PreviewLoaConfigurationParams'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/loa_configurations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List LOA configurations
     * @description List the LOA configurations.
     */
    get: operations['ListLoaConfigurations'];
    put?: never;
    /**
     * Create a LOA configuration
     * @description Create a LOA configuration.
     */
    post: operations['CreateLoaConfiguration'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/loa_configurations/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a LOA configuration
     * @description Retrieve a specific LOA configuration.
     */
    get: operations['GetLoaConfiguration'];
    put?: never;
    post?: never;
    /**
     * Delete a LOA configuration
     * @description Delete a specific LOA configuration.
     */
    delete: operations['DeleteLoaConfiguration'];
    options?: never;
    head?: never;
    /**
     * Update a LOA configuration
     * @description Update a specific LOA configuration.
     */
    patch: operations['UpdateLoaConfiguration'];
    trace?: never;
  };
  '/porting/loa_configurations/{id}/preview': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Preview a LOA configuration
     * @description Preview a specific LOA configuration.
     */
    get: operations['PreviewLoaConfiguration'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List porting related reports
     * @description List the reports generated about porting operations.
     */
    get: operations['ListPortingReports'];
    put?: never;
    /**
     * Create a porting related report
     * @description Generate reports about porting operations.
     */
    post: operations['CreatePortingReport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting/reports/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a report
     * @description Retrieve a specific report generated.
     */
    get: operations['GetPortingReport'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all porting orders
     * @description Returns a list of your porting order.
     */
    get: operations['ListPortingOrders'];
    put?: never;
    /**
     * Create a porting order
     * @description Creates a new porting order object.
     */
    post: operations['CreatePortingOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/exception_types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all exception types
     * @description Returns a list of all possible exception types for a porting order.
     */
    get: operations['ListExceptionTypes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/phone_number_configurations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all phone number configurations
     * @description Returns a list of phone number configurations paginated.
     */
    get: operations['ListPhoneNumberConfigurations'];
    put?: never;
    /**
     * Create a list of phone number configurations
     * @description Creates a list of phone number configurations.
     */
    post: operations['CreatePhoneNumberConfigurations'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a porting order
     * @description Retrieves the details of an existing porting order.
     */
    get: operations['GetPortingOrder'];
    put?: never;
    post?: never;
    /**
     * Delete a porting order
     * @description Deletes an existing porting order. This operation is restrict to porting orders in draft state.
     */
    delete: operations['DeletePortingOrder'];
    options?: never;
    head?: never;
    /**
     * Edit a porting order
     * @description Edits the details of an existing porting order.
     *
     *     Any or all of a porting orders attributes may be included in the resource object included in a PATCH request.
     *
     *     If a request does not include all of the attributes for a resource, the system will interpret the missing attributes as if they were included with their current values. To explicitly set something to null, it must be included in the request with a null value.
     */
    patch: operations['UpdatePortingOrder'];
    trace?: never;
  };
  '/porting_orders/{id}/actions/activate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Activate every number in a porting order asynchronously.
     * @description Activate each number in a porting order asynchronously. This operation is limited to US FastPort orders only.
     */
    post: operations['ActivatePortingOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/actions/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Cancel a porting order
     * @description Cancel a porting order
     */
    post: operations['CancelPortingOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/actions/confirm': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Submit a porting order.
     * @description Confirm and submit your porting order.
     */
    post: operations['ConfirmPortingOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/actions/share': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Share a porting order
     * @description Creates a sharing token for a porting order. The token can be used to share the porting order with non-Telnyx users.
     */
    post: operations['SharePortingOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/activation_jobs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all porting activation jobs
     * @description Returns a list of your porting activation jobs.
     */
    get: operations['ListPortingOrderActivationJobs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/activation_jobs/{activationJobId}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a porting activation job
     * @description Returns a porting activation job.
     */
    get: operations['GetPortingOrdersActivationJob'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a porting activation job
     * @description Updates the activation time of a porting activation job.
     */
    patch: operations['UpdatePortingOrdersActivationJob'];
    trace?: never;
  };
  '/porting_orders/{id}/additional_documents': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List additional documents
     * @description Returns a list of additional documents for a porting order.
     */
    get: operations['ListAdditionalDocuments'];
    put?: never;
    /**
     * Create a list of additional documents
     * @description Creates a list of additional documents for a porting order.
     */
    post: operations['CreateAdditionalDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/additional_documents/{additional_document_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete an additional document
     * @description Deletes an additional document for a porting order.
     */
    delete: operations['DeleteAdditionalDocument'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/allowed_foc_windows': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List allowed FOC dates
     * @description Returns a list of allowed FOC dates for a porting order.
     */
    get: operations['ListAllowedFocWindows'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/comments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all comments of a porting order
     * @description Returns a list of all comments of a porting order.
     */
    get: operations['ListPortingOrderComments'];
    put?: never;
    /**
     * Create a comment for a porting order
     * @description Creates a new comment for a porting order.
     */
    post: operations['CreateComment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/loa_template': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Download a porting order loa template
     * @description Download a porting order loa template
     */
    get: operations['GetPortingOrderLoaTemplate'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/requirements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List porting order requirements
     * @description Returns a list of all requirements based on country/number type for this porting order.
     */
    get: operations['ListPortingOrderRequirements'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/sub_request': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve the associated V1 sub_request_id and port_request_id
     * @description Retrieve the associated V1 sub_request_id and port_request_id
     */
    get: operations['GetPortingOrderSubRequest'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/verification_codes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List verification codes
     * @description Returns a list of verification codes for a porting order.
     */
    get: operations['ListVerificationCodes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/verification_codes/send': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Send the verification codes
     * @description Send the verification code for all porting phone numbers.
     */
    post: operations['SendPortingVerificationCodes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{id}/verification_codes/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Verify the verification code for a list of phone numbers
     * @description Verifies the verification code for a list of phone numbers.
     */
    post: operations['VerifyPortingVerificationCodes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{porting_order_id}/phone_number_blocks': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all phone number blocks
     * @description Returns a list of all phone number blocks of a porting order.
     */
    get: operations['listPortingPhoneNumberBlocks'];
    put?: never;
    /**
     * Create a phone number block
     * @description Creates a new phone number block.
     */
    post: operations['createPortingPhoneNumberBlock'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{porting_order_id}/phone_number_blocks/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a phone number block
     * @description Deletes a phone number block.
     */
    delete: operations['deletePortingPhoneNumberBlock'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{porting_order_id}/phone_number_extensions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all phone number extensions
     * @description Returns a list of all phone number extensions of a porting order.
     */
    get: operations['listPortingPhoneNumberExtensions'];
    put?: never;
    /**
     * Create a phone number extension
     * @description Creates a new phone number extension.
     */
    post: operations['createPortingPhoneNumberExtension'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_orders/{porting_order_id}/phone_number_extensions/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a phone number extension
     * @description Deletes a phone number extension.
     */
    delete: operations['deletePortingPhoneNumberExtension'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/porting_phone_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all porting phone numbers
     * @description Returns a list of your porting phone numbers.
     */
    get: operations['ListPortingPhoneNumbers'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portout/events': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all port-out events
     * @description Returns a list of all port-out events.
     */
    get: operations['listPortoutEvents'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portout/events/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Show a port-out event
     * @description Show a specific port-out event.
     */
    get: operations['showPortoutEvent'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portout/events/{id}/republish': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Republish a port-out event
     * @description Republish a specific port-out event.
     */
    post: operations['republishPortoutEvent'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portout/reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List port-out related reports
     * @description List the reports generated about port-out operations.
     */
    get: operations['ListPortoutReports'];
    put?: never;
    /**
     * Create a port-out related report
     * @description Generate reports about port-out operations.
     */
    post: operations['CreatePortoutReport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portout/reports/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a report
     * @description Retrieve a specific report generated.
     */
    get: operations['GetPortingReport'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portouts': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List portout requests
     * @description Returns the portout requests according to filters
     */
    get: operations['ListPortoutRequest'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portouts/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a portout request
     * @description Returns the portout request based on the ID provided
     */
    get: operations['FindPortoutRequest'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portouts/{id}/comments': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all comments for a portout request
     * @description Returns a list of comments for a portout request.
     */
    get: operations['FindPortoutComments'];
    put?: never;
    /**
     * Create a comment on a portout request
     * @description Creates a comment on a portout request.
     */
    post: operations['PostPortRequestComment'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portouts/{id}/supporting_documents': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List supporting documents on a portout request
     * @description List every supporting documents for a portout request.
     */
    get: operations['GetPortRequestSupportingDocuments'];
    put?: never;
    /**
     * Create a list of supporting documents on a portout request
     * @description Creates a list of supporting documents on a portout request.
     */
    post: operations['PostPortRequestSupportingDocuments'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/portouts/{id}/{status}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update Status
     * @description Authorize or reject portout request
     */
    patch: operations['UpdatePortoutStatus'];
    trace?: never;
  };
  '/private_wireless_gateways': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all Private Wireless Gateways
     * @description Get all Private Wireless Gateways belonging to the user.
     */
    get: operations['GetPrivateWirelessGateways'];
    put?: never;
    /**
     * Create a Private Wireless Gateway
     * @description Asynchronously create a Private Wireless Gateway for SIM cards for a previously created network.
     */
    post: operations['CreatePrivateWirelessGateway'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/private_wireless_gateways/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a Private Wireless Gateway
     * @description Retrieve information about a Private Wireless Gateway.
     */
    get: operations['GetPrivateWirelessGateway'];
    put?: never;
    post?: never;
    /**
     * Delete a Private Wireless Gateway
     * @description Deletes the Private Wireless Gateway.
     */
    delete: operations['DeleteWirelessGateway'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/public_internet_gateways': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Public Internet Gateways
     * @description List all Public Internet Gateways.
     */
    get: operations['ListPublicInternetGateways'];
    put?: never;
    /**
     * Create a Public Internet Gateway
     * @description Create a new Public Internet Gateway.
     */
    post: operations['CreatePublicInternetGateway'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/public_internet_gateways/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Public Internet Gateway
     * @description Retrieve a Public Internet Gateway.
     */
    get: operations['GetPublicInternetGateway'];
    put?: never;
    post?: never;
    /**
     * Delete a Public Internet Gateway
     * @description Delete a Public Internet Gateway.
     */
    delete: operations['DeletePublicInternetGateway'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queues/{queue_name}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a call queue
     * @description Retrieve an existing call queue
     */
    get: operations['RetrieveCallQueue'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queues/{queue_name}/calls': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve calls from a queue
     * @description Retrieve the list of calls in an existing queue
     */
    get: operations['ListQueueCalls'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/queues/{queue_name}/calls/{call_control_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a call from a queue
     * @description Retrieve an existing call from an existing queue
     */
    get: operations['RetrieveCallFromQueue'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/recording_transcriptions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all recording transcriptions
     * @description Returns a list of your recording transcriptions.
     */
    get: operations['getRecordingTranscriptions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/recording_transcriptions/{recording_transcription_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a recording transcription
     * @description Retrieves the details of an existing recording transcription
     */
    get: operations['getRecordingTranscription'];
    put?: never;
    post?: never;
    /**
     * Delete a recording transcription
     * @description Permanently deletes a recording transcription.
     */
    delete: operations['deleteRecordingTranscription'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/recordings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all call recordings
     * @description Returns a list of your call recordings.
     */
    get: operations['GetRecordings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/recordings/actions/delete': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    /**
     * Delete a list of call recordings
     * @description Permanently deletes a list of call recordings.
     */
    delete: operations['DeleteRecordings'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/recordings/{recording_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a call recording
     * @description Retrieves the details of an existing call recording.
     */
    get: operations['GetRecording'];
    put?: never;
    post?: never;
    /**
     * Delete a call recording
     * @description Permanently deletes a call recording.
     */
    delete: operations['DeleteRecording'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/regions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Regions
     * @description List all regions and the interfaces that region supports
     */
    get: operations['ListRegions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/regulatory_requirements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve regulatory requirements */
    get: operations['ListRegulatoryRequirements'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reports/cdr_usage_reports/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Generate and fetch voice usage report synchronously. This endpoint will both generate and fetch the voice report over a specified time period. No polling is necessary but the response may take up to a couple of minutes.  */
    get: operations['GetUsageReportSync'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reports/mdr_usage_reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Fetch all messaging usage reports. Usage reports are aggregated messaging data for specified time period and breakdown */
    get: operations['GetUsageReports'];
    put?: never;
    /** @description Submit request for new new messaging usage report. This endpoint will pull and aggregate messaging data in specified time period.  */
    post: operations['SubmitUsageReport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reports/mdr_usage_reports/sync': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Generate and fetch messaging usage report synchronously. This endpoint will both generate and fetch the messaging report over a specified time period. No polling is necessary but the response may take up to a couple of minutes.  */
    get: operations['GetUsageReportSync'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reports/mdr_usage_reports/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Fetch a single messaging usage report by id */
    get: operations['GetUsageReport'];
    put?: never;
    post?: never;
    /** @description Delete messaging usage report by id */
    delete: operations['DeleteUsageReport'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reports/mdrs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Fetch all Mdr records  */
    get: operations['GetPaginatedMdrs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/reports/wdrs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Fetch all Wdr records  */
    get: operations['GetPaginatedWdrs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/requirement_groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List requirement groups */
    get: operations['GetRequirementGroups'];
    put?: never;
    /** Create a new requirement group */
    post: operations['CreateRequirementGroup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/requirement_groups/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a single requirement group by ID */
    get: operations['GetRequirementGroup'];
    put?: never;
    post?: never;
    /** Delete a requirement group by ID */
    delete: operations['DeleteRequirementGroup'];
    options?: never;
    head?: never;
    /** Update requirement values in requirement group */
    patch: operations['UpdateRequirementGroup'];
    trace?: never;
  };
  '/requirement_types': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all requirement types
     * @description List all requirement types ordered by created_at descending
     */
    get: operations['ListRequirementTypes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/requirement_types/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a requirement types
     * @description Retrieve a requirement type by id
     */
    get: operations['RetrieveRequirementType'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/requirements': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all requirements
     * @description List all requirements with filtering, sorting, and pagination
     */
    get: operations['ListRequirements'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/requirements/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a document requirement
     * @description Retrieve a document requirement record
     */
    get: operations['RetrieveDocumentRequirements'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_compositions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of room compositions. */
    get: operations['ListRoomCompositions'];
    put?: never;
    /**
     * Create a room composition.
     * @description Asynchronously create a room composition.
     */
    post: operations['CreateRoomComposition'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_compositions/{room_composition_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a room composition. */
    get: operations['ViewRoomComposition'];
    put?: never;
    post?: never;
    /**
     * Delete a room composition.
     * @description Synchronously delete a room composition.
     */
    delete: operations['DeleteRoomComposition'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of room participants. */
    get: operations['ListRoomParticipants'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_participants/{room_participant_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a room participant. */
    get: operations['ViewRoomParticipant'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_recordings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of room recordings. */
    get: operations['ListRoomRecordings'];
    put?: never;
    post?: never;
    /** Delete several room recordings in a bulk. */
    delete: operations['DeleteRoomRecordings'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_recordings/{room_recording_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a room recording. */
    get: operations['ViewRoomRecording'];
    put?: never;
    post?: never;
    /**
     * Delete a room recording.
     * @description Synchronously delete a Room Recording.
     */
    delete: operations['DeleteRoomRecording'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of room sessions. */
    get: operations['ListRoomSessions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions/{room_session_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a room session. */
    get: operations['ViewRoomSession'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions/{room_session_id}/actions/end': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * End a room session.
     * @description Note: this will also kick all participants currently present in the room
     */
    post: operations['EndSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions/{room_session_id}/actions/kick': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Kick participants from a room session. */
    post: operations['KickParticipantInSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions/{room_session_id}/actions/mute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Mute participants in room session. */
    post: operations['MuteParticipantInSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions/{room_session_id}/actions/unmute': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Unmute participants in room session. */
    post: operations['UnmuteParticipantInSession'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/room_sessions/{room_session_id}/participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of room participants. */
    get: operations['ListRoomParticipants'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rooms': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of rooms. */
    get: operations['ListRooms'];
    put?: never;
    /**
     * Create a room.
     * @description Synchronously create a Room.
     */
    post: operations['CreateRoom'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rooms/{room_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a room. */
    get: operations['ViewRoom'];
    put?: never;
    post?: never;
    /**
     * Delete a room.
     * @description Synchronously delete a Room. Participants from that room will be kicked out, they won't be able to join that room anymore, and you won't be charged anymore for that room.
     */
    delete: operations['DeleteRoom'];
    options?: never;
    head?: never;
    /**
     * Update a room.
     * @description Synchronously update a Room.
     */
    patch: operations['UpdateRoom'];
    trace?: never;
  };
  '/rooms/{room_id}/actions/generate_join_client_token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create Client Token to join a room.
     * @description Synchronously create an Client Token to join a Room. Client Token is necessary to join a Telnyx Room. Client Token will expire after `token_ttl_secs`, a Refresh Token is also provided to refresh a Client Token, the Refresh Token expires after `refresh_token_ttl_secs`.
     */
    post: operations['CreateRoomClientToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rooms/{room_id}/actions/refresh_client_token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Refresh Client Token to join a room.
     * @description Synchronously refresh an Client Token to join a Room. Client Token is necessary to join a Telnyx Room. Client Token will expire after `token_ttl_secs`.
     */
    post: operations['RefreshRoomClientToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/rooms/{room_id}/sessions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** View a list of room sessions. */
    get: operations['ListRoomSessions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/short_codes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List short codes */
    get: operations['ListShortCodes'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/short_codes/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a short code */
    get: operations['RetrieveShortCode'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update short code
     * @description Update the settings for a specific short code. To unbind a short code from a profile, set the `messaging_profile_id` to `null` or an empty string.
     */
    patch: operations['UpdateShortCode'];
    trace?: never;
  };
  '/sim_card_actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List SIM card actions
     * @description This API lists a paginated collection of SIM card actions. It enables exploring a collection of existing asynchronous operations using specific filters.
     */
    get: operations['ListSimCardActions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_actions/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get SIM card action details
     * @description This API fetches detailed information about a SIM card action to follow-up on an existing asynchronous operation.
     */
    get: operations['GetSimCardAction'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_data_usage_notifications': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List SIM card data usage notifications
     * @description Lists a paginated collection of SIM card data usage notifications. It enables exploring the collection using specific filters.
     */
    get: operations['ListDataUsageNotifications'];
    put?: never;
    /**
     * Create a new SIM card data usage notification
     * @description Creates a new SIM card data usage notification.
     */
    post: operations['PostSimCardDataUsageNotification'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_data_usage_notifications/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single SIM card data usage notification
     * @description Get a single SIM Card Data Usage Notification.
     */
    get: operations['GetSimCardDataUsageNotification'];
    put?: never;
    post?: never;
    /**
     * Delete SIM card data usage notifications
     * @description Delete the SIM Card Data Usage Notification.
     */
    delete: operations['DeleteSimCardDataUsageNotifications'];
    options?: never;
    head?: never;
    /**
     * Updates information for a SIM Card Data Usage Notification
     * @description Updates information for a SIM Card Data Usage Notification.
     */
    patch: operations['PatchSimCardDataUsageNotification'];
    trace?: never;
  };
  '/sim_card_group_actions': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List SIM card group actions
     * @description This API allows listing a paginated collection a SIM card group actions. It allows to explore a collection of existing asynchronous operation using specific filters.
     */
    get: operations['GetSimCardGroupActions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_group_actions/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get SIM card group action details
     * @description This API allows fetching detailed information about a SIM card group action resource to make follow-ups in an existing asynchronous operation.
     */
    get: operations['GetSimCardGroupAction'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_groups': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all SIM card groups
     * @description Get all SIM card groups belonging to the user that match the given filters.
     */
    get: operations['GetAllSimCardGroups'];
    put?: never;
    /**
     * Create a SIM card group
     * @description Creates a new SIM card group object
     */
    post: operations['CreateSimCardGroup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_groups/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get SIM card group
     * @description Returns the details regarding a specific SIM card group
     */
    get: operations['GetSimCardGroup'];
    put?: never;
    post?: never;
    /**
     * Delete a SIM card group
     * @description Permanently deletes a SIM card group
     */
    delete: operations['DeleteSimCardGroup'];
    options?: never;
    head?: never;
    /**
     * Update a SIM card group
     * @description Updates a SIM card group
     */
    patch: operations['UpdateSimCardGroup'];
    trace?: never;
  };
  '/sim_card_groups/{id}/actions/remove_private_wireless_gateway': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request Private Wireless Gateway removal from SIM card group
     * @description This action will asynchronously remove an existing Private Wireless Gateway definition from a SIM card group. Completing this operation defines that all SIM cards in the SIM card group will get their traffic handled by Telnyx's default mobile network configuration.
     */
    post: operations['RemoveSimCardGroupPrivateWirelessGateway'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_groups/{id}/actions/set_private_wireless_gateway': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request Private Wireless Gateway assignment for SIM card group
     * @description This action will asynchronously assign a provisioned Private Wireless Gateway to the SIM card group. Completing this operation defines that all SIM cards in the SIM card group will get their traffic controlled by the associated Private Wireless Gateway. This operation will also imply that new SIM cards assigned to a group will inherit its network definitions. If it's moved to a different group that doesn't have a Private Wireless Gateway, it'll use Telnyx's default mobile network configuration.
     */
    post: operations['SetPrivateWirelessGatewayForSimCardGroup'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_order_preview': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Preview SIM card orders
     * @description Preview SIM card order purchases.
     */
    post: operations['PreviewSimCardOrders'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_orders': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all SIM card orders
     * @description Get all SIM card orders according to filters.
     */
    get: operations['GetSimCardOrders'];
    put?: never;
    /**
     * Create a SIM card order
     * @description Creates a new order for SIM cards.
     */
    post: operations['CreateSimCardOrder'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_card_orders/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a single SIM card order
     * @description Get a single SIM card order by its ID.
     */
    get: operations['GetSimCardOrder'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all SIM cards
     * @description Get all SIM cards belonging to the user that match the given filters.
     */
    get: operations['GetSimCards'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/actions/bulk_set_network_preferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request bulk setting of network preferences for SIM cards.
     * @description This API triggers an asynchronous operation to set network preferences for each of the specified SIM cards.<br/>
     *     For each SIM Card a SIM Card Action will be generated. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['SetNetworkPreferencesBulk'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/actions/bulk_set_public_ips': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request bulk setting SIM card public IPs.
     * @description This API triggers an asynchronous operation to set a public IP for each of the specified SIM cards.<br/>
     *     For each SIM Card a SIM Card Action will be generated. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['SetPublicIPsBulk'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/actions/validate_registration_codes': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Validate SIM cards registration codes
     * @description It validates whether SIM card registration codes are valid or not.
     */
    post: operations['ValidateRegistrationCodes'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get SIM card
     * @description Returns the details regarding a specific SIM card.
     */
    get: operations['GetSimCard'];
    put?: never;
    post?: never;
    /**
     * Deletes a SIM card
     * @description The SIM card will be decommissioned, removed from your account and you will stop being charged.<br />The SIM card won't be able to connect to the network after the deletion is completed, thus making it impossible to consume data.<br/>
     *     Transitioning to the disabled state may take a period of time.
     *     Until the transition is completed, the SIM card status will be disabling <code>disabling</code>.<br />In order to re-enable the SIM card, you will need to re-register it.
     */
    delete: operations['DeleteSimCard'];
    options?: never;
    head?: never;
    /**
     * Update a SIM card
     * @description Updates SIM card data
     */
    patch: operations['UpdateSimCard'];
    trace?: never;
  };
  '/sim_cards/{id}/actions/delete_network_preferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Delete network preferences for a SIM card
     * @description This API deletes network preferences for a SIM card.<br/>
     *     The API will trigger an asynchronous operation called a SIM Card Action. Creating network preferences may take a period of time. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['DeleteNetworkPreferences'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/actions/disable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request a SIM card disable
     * @description This API disables a SIM card, disconnecting it from the network and making it impossible to consume data.<br/>
     *     The API will trigger an asynchronous operation called a SIM Card Action. Transitioning to the disabled state may take a period of time. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['DisableSimCard'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/actions/enable': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request a SIM card enable
     * @description This API enables a SIM card, connecting it to the network and making it possible to consume data.<br/>
     *     To enable a SIM card, it must be associated with a SIM card group.<br/>
     *     The API will trigger an asynchronous operation called a SIM Card Action. Transitioning to the enabled state may take a period of time. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['EnableSimCard'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/actions/remove_public_ip': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request removing a SIM card public IP
     * @description This API removes an existing public IP from a SIM card. <br/><br/>
     *      The API will trigger an asynchronous operation called a SIM Card Action. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     */
    post: operations['RemoveSimCardPublicIp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/actions/set_network_preferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create or update network preferences for a SIM card
     * @description This API sets network preferences for a SIM card.<br/>
     *     Every SIM card has default network preferences defined on Telnyx. These preferences will determine how a SIMCard will connect to the network by considering a list of preferable operators.<br/><br/>
     *     The SIM card needs to be attached to the network so this can connect and SMS must be available, otherwise, the operation will fail. This preference will only be respected if the network is available, otherwise the strongest signal will be used. <br/><br/>
     *     The API will trigger an asynchronous operation called a SIM Card Action. Creating network preferences may take a period of time. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['SetNetworkPreference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/actions/set_public_ip': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request setting a SIM card public IP
     * @description This API makes a SIM card reachable on the public internet by mapping a random public IP to the SIM card. <br/><br/>
     *      The API will trigger an asynchronous operation called a SIM Card Action. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API. <br/><br/>
     *      Setting a Public IP to a SIM Card incurs a charge and will only succeed if the account has sufficient funds.
     */
    post: operations['SetSimCardPublicIp'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/actions/set_standby': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Request setting a SIM card to standby
     * @description The SIM card will be able to connect to the network once the process to set it to standby has been completed, thus making it possible to consume data.<br/>
     *     To set a SIM card to standby, it must be associated with SIM card group.<br/>
     *     The API will trigger an asynchronous operation called a SIM Card Action. Transitioning to the standby state may take a period of time. The status of the SIM Card Action can be followed through the [List SIM Card Action](https://developersdev.telnyx.com/docs/api/v2/wireless/SIM-Card-Actions#ListSIMCardActions) API.
     *
     */
    post: operations['SetSimCardStandby'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/activation_code': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get activation QR code for an eSIM
     * @description It returns the contents for the activation QR code for an eSIM.<br/><br/>
     *      This API is only available for eSIMs. If the given SIM is a physical SIM card, or has already been installed, an error will be returned.
     *
     */
    get: operations['GetSimCardActivationCode'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/device_details': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get SIM card device details
     * @description It returns the device details where a SIM card is currently being used.
     *
     */
    get: operations['GetSimCardDeviceDetails'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/network_preferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get network preferences
     * @description It returns the network preferences currently applied in the SIM card.
     *
     */
    get: operations['GetSimCardNetworkPreferences'];
    /**
     * Set network preferences
     * @description This API allows setting or updating a SIM card network preference. <br/><br/>
     *     Every SIM card has default network preferences defined on Telnyx. These preferences will determine how a SIMCard will connect to the network by considering a list of preferable operators.<br/><br/>
     *     There can be multiple scenarios where an operator can be preferred over another, for example, when a specific mobile operator can provide better network latency or better pricing.
     *
     */
    put: operations['PutSimCardNetworkPreferences'];
    post?: never;
    /**
     * Delete network preferences
     * @description This API asynchronously removes the custom-defined network preferences settings. After this operation is done the Telnyx default settings, the same applied for an unaltered SIM card, will be in place.
     *
     */
    delete: operations['DeleteSIMCardNetworkPreferences'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/public_ip': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get SIM card public IP definition
     * @description It returns the public IP requested for a SIM card.
     *
     */
    get: operations['GetSimCardPublicIp'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sim_cards/{id}/wireless_connectivity_logs': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List wireless connectivity logs
     * @description This API allows listing a paginated collection of Wireless Connectivity Logs associated with a SIM Card, for troubleshooting purposes.
     */
    get: operations['GetWirelessConnectivityLogs'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/buckets/{bucketName}/ssl_certificate': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Bucket SSL Certificate
     * @description Returns the stored certificate detail of a bucket, if applicable.
     */
    get: operations['GetStorageSSLCertificates'];
    /**
     * Add SSL Certificate
     * @description Uploads an SSL certificate and its matching secret so that you can use Telnyx’s storage as your CDN.
     */
    put: operations['AddStorageSSLCertificate'];
    post?: never;
    /**
     * Remove SSL Certificate
     * @description Deletes an SSL certificate and its matching secret.
     */
    delete: operations['RemoveStorageSSLCertificate'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/buckets/{bucketName}/usage/api': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get API Usage
     * @description Returns the detail on API usage on a bucket of a particular time period, group by method category.
     */
    get: operations['GetStorageAPIUsage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/buckets/{bucketName}/usage/storage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Bucket Usage
     * @description Returns the amount of storage space and number of files a bucket takes up.
     */
    get: operations['GetBucketUsage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/buckets/{bucketName}/{objectName}/presigned_url': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create Presigned Object URL
     * @description Returns a timed and authenticated URL to get an object. This is the equivalent to AWS S3’s “presigned” URL. Please note that Telnyx performs authentication differently from AWS S3 and you MUST NOT use the presign method of AWS s3api CLI or sdk to generate the presigned URL.
     *
     *     Refer to: https://developers.telnyx.com/docs/cloud-storage/presigned-urls
     *
     */
    post: operations['CreatePresignedObjectUrl'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/migration_source_coverage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List Migration Source coverage */
    get: operations['ListMigrationSourceCoverage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/migration_sources': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all Migration Sources */
    get: operations['ListMigrationSources'];
    put?: never;
    /**
     * Create a Migration Source
     * @description Create a source from which data can be migrated from.
     */
    post: operations['CreateMigrationSource'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/migration_sources/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a Migration Source */
    get: operations['GetMigrationSource'];
    put?: never;
    post?: never;
    /** Delete a Migration Source */
    delete: operations['DeleteMigrationSource'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/migrations': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List all Migrations */
    get: operations['ListMigrations'];
    put?: never;
    /**
     * Create a Migration
     * @description Initiate a migration of data from an external provider into Telnyx Cloud Storage. Currently, only S3 is supported.
     */
    post: operations['CreateMigration'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/migrations/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Get a Migration */
    get: operations['GetMigration'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/storage/migrations/{id}/actions/stop': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Stop a Migration */
    post: operations['StopMigration'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sub_number_orders': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List sub number orders
     * @description Get a paginated list of sub number orders.
     */
    get: operations['ListSubNumberOrders'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/sub_number_orders/{sub_number_order_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a sub number order
     * @description Get an existing sub number order.
     */
    get: operations['GetSubNumberOrder'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Update a sub number order's requirements
     * @description Updates a sub number order.
     */
    patch: operations['UpdateSubNumberOrder'];
    trace?: never;
  };
  '/sub_number_orders/{sub_number_order_id}/cancel': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /**
     * Cancel a sub number order
     * @description Allows you to cancel a sub number order in 'pending' status.
     */
    patch: operations['CancelSubNumberOrder'];
    trace?: never;
  };
  '/telephony_credentials': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all credentials
     * @description List all On-demand Credentials.
     */
    get: operations['FindTelephonyCredentials'];
    put?: never;
    /**
     * Create a credential
     * @description Create a credential.
     */
    post: operations['CreateTelephonyCredential'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/telephony_credentials/tags': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all tags
     * @description Returns a list of tags used on Credentials
     */
    get: operations['ListTags'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/telephony_credentials/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a credential
     * @description Get the details of an existing On-demand Credential.
     */
    get: operations['GetTelephonyCredential'];
    put?: never;
    post?: never;
    /**
     * Delete a credential
     * @description Delete an existing credential.
     */
    delete: operations['DeleteTelephonyCredential'];
    options?: never;
    head?: never;
    /**
     * Update a credential
     * @description Update an existing credential.
     */
    patch: operations['UpdateTelephonyCredential'];
    trace?: never;
  };
  '/telephony_credentials/{id}/actions/{action}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Perform activate or deactivate action on provided Credential
     * @description Perform activate or deactivate action on provided Credential. Activate action will change the status to active, making it possible to connect calls with the credential. Deactivate action will change the status to inactive, making it impossible to connect calls with the credential.
     */
    post: operations['PerformCredentialAction'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/telephony_credentials/{id}/token': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create an Access Token.
     * @description Create an Access Token (JWT) for the credential.
     */
    post: operations['CreateTelephonyCredentialToken'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Calls': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch multiple call resources
     * @description Returns multiple call resouces for an account. This endpoint is eventually consistent.
     */
    get: operations['GetTexmlCalls'];
    put?: never;
    /**
     * Initiate an outbound call
     * @description Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for the connection in the Mission Control Portal.
     */
    post: operations['InitiateTexmlCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Calls/{call_sid}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch a call
     * @description Returns an individual call identified by its CallSid. This endpoint is eventually consistent.
     */
    get: operations['GetTexmlCall'];
    put?: never;
    /**
     * Update call
     * @description Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase as specified in the example.
     */
    post: operations['UpdateTexmlCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch recordings for a call
     * @description Returns recordings for a call identified by call_sid.
     */
    get: operations['FetchTeXMLCallRecordings'];
    put?: never;
    /**
     * Request recording for a call
     * @description Starts recording with specified parameters for call idientified by call_sid.
     */
    post: operations['StartTeXMLCallRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Calls/{call_sid}/Recordings/{recording_sid}.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update recording on a call
     * @description Updates recording resource for particular call.
     */
    post: operations['UpdateTeXMLCallRecording'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Calls/{call_sid}/Streams.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Start streaming media from a call.
     * @description Starts streaming media from a call to a specific WebSocket address.
     */
    post: operations['StartTeXMLCallStreaming'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Calls/{call_sid}/Streams/{streaming_sid}.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update streaming on a call
     * @description Updates streaming resource for particular call.
     */
    post: operations['UpdateTeXMLCallStreaming'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Conferences': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List conference resources
     * @description Lists conference resources.
     */
    get: operations['GetTexmlConferences'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Conferences/{conference_sid}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch a conference resource
     * @description Returns a conference resource.
     */
    get: operations['GetTexmlConference'];
    put?: never;
    /**
     * Update a conference resource
     * @description Updates a conference resource.
     */
    post: operations['UpdateTexmlConference'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List conference participants
     * @description Lists conference participants
     */
    get: operations['GetTexmlConferenceParticipants'];
    put?: never;
    /**
     * Dial a new conference participant
     * @description Dials a new conference participant
     */
    post: operations['DialTexmlConferenceParticipant'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Participants/{call_sid}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get conference participant resource
     * @description Gets conference participant resource
     */
    get: operations['GetTexmlConferenceParticipant'];
    put?: never;
    /**
     * Update a conference participant
     * @description Updates a conference participant
     */
    post: operations['UpdateTexmlConferenceParticipant'];
    /**
     * Delete a conference participant
     * @description Deletes a conference participant
     */
    delete: operations['DeleteTexmlConferenceParticipant'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List conference recordings
     * @description Lists conference recordings
     */
    get: operations['GetTexmlConferenceRecordings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Conferences/{conference_sid}/Recordings.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch recordings for a conference
     * @description Returns recordings for a conference identified by conference_sid.
     */
    get: operations['FetchTeXMLConferenceRecordings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Recordings.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch multiple recording resources
     * @description Returns multiple recording resources for an account.
     */
    get: operations['GetTeXMLCallRecordings'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Recordings/{recording_sid}.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch recording resource
     * @description Returns recording resource identified by recording id.
     */
    get: operations['GetTeXMLCallRecording'];
    put?: never;
    post?: never;
    /**
     * Delete recording resource
     * @description Deletes recording resource identified by recording id.
     */
    delete: operations['DeleteTeXMLCallRecording'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Transcriptions.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List recording transcriptions
     * @description Returns multiple recording transcription resources for an account.
     */
    get: operations['GetTeXMLRecordingTranscriptions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/Accounts/{account_sid}/Transcriptions/{recording_transcription_sid}.json': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Fetch a recording transcription resource
     * @description Returns the recording transcription resource identified by its ID.
     */
    get: operations['GetTeXMLRecordingTranscription'];
    put?: never;
    post?: never;
    /**
     * Delete a recording transcription
     * @description Permanently deletes a recording transcription.
     */
    delete: operations['DeleteTeXMLRecordingTranscription'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/calls/{application_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Initiate an outbound call
     * @description Initiate an outbound TeXML call. Telnyx will request TeXML from the XML Request URL configured for the connection in the Mission Control Portal.
     */
    post: operations['InitiateTexmlCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/calls/{call_sid}/update': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Update call
     * @description Update TeXML call. Please note that the keys present in the payload MUST BE formatted in CamelCase as specified in the example.
     */
    post: operations['UpdateTexmlCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml/secrets': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /**
     * Create a TeXML secret
     * @description Create a TeXML secret which can be later used as a Dynamic Parameter for TeXML when using Mustache Templates in your TeXML. In your TeXML you will be able to use your secret name, and this name will be replaced by the actual secret value when processing the TeXML on Telnyx side.  The secrets are not visible in any logs.
     */
    post: operations['CreateTexmlSecret'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml_applications': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all TeXML Applications
     * @description Returns a list of your TeXML Applications.
     */
    get: operations['FindTexmlApplications'];
    put?: never;
    /**
     * Creates a TeXML Application
     * @description Creates a TeXML Application.
     */
    post: operations['CreateTexmlApplication'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/texml_applications/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a TeXML Application
     * @description Retrieves the details of an existing TeXML Application.
     */
    get: operations['GetTexmlApplication'];
    put?: never;
    post?: never;
    /**
     * Deletes a TeXML Application
     * @description Deletes a TeXML Application.
     */
    delete: operations['DeleteTexmlApplication'];
    options?: never;
    head?: never;
    /**
     * Update a TeXML Application
     * @description Updates settings of an existing TeXML Application.
     */
    patch: operations['UpdateTexmlApplication'];
    trace?: never;
  };
  '/usage_reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Telnyx product usage data (BETA)
     * @description Get Telnyx usage data by product, broken out by the specified dimensions
     */
    get: operations['GetUsageReport'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/usage_reports/options': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get Usage Reports query options (BETA)
     * @description Get the Usage Reports options for querying usage, including the products available and their respective metrics and dimensions
     */
    get: operations['ListUsageReportsOptions'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/v2/external_connections/{id}/locations/{location_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    /** Update a location's static emergency address */
    patch: operations['updateLocation'];
    trace?: never;
  };
  '/verifications/by_phone_number/{phone_number}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** List verifications by phone number */
    get: operations['ListVerifications'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verifications/by_phone_number/{phone_number}/actions/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify verification code by phone number */
    post: operations['VerifyVerificationCodeByPhoneNumber'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verifications/call': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Trigger Call verification */
    post: operations['CreateVerificationCall'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verifications/flashcall': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Trigger Flash call verification */
    post: operations['CreateFlashcallVerification'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verifications/sms': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Trigger SMS verification */
    post: operations['CreateVerificationSms'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verifications/{verification_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve verification */
    get: operations['RetrieveVerification'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verifications/{verification_id}/actions/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Verify verification code by ID */
    post: operations['VerifyVerificationCodeById'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verified_numbers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Verified Numbers
     * @description Gets a paginated list of Verified Numbers.
     */
    get: operations['ListVerifiedNumbers'];
    put?: never;
    /**
     * Request phone number verification
     * @description Initiates phone number verification procedure.
     */
    post: operations['CreateVerifiedNumber'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verified_numbers/{phone_number}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** Retrieve a verified number */
    get: operations['GetVerifiedNumber'];
    put?: never;
    post?: never;
    /** Delete a verified number */
    delete: operations['DeleteVerifiedNumber'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verified_numbers/{phone_number}/actions/verify': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    get?: never;
    put?: never;
    /** Submit verification code */
    post: operations['VerifyVerificationCode'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verify_profiles': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Verify profiles
     * @description Gets a paginated list of Verify profiles.
     */
    get: operations['ListProfiles'];
    put?: never;
    /**
     * Create a Verify profile
     * @description Creates a new Verify profile to associate verifications with.
     */
    post: operations['CreateVerifyProfile'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verify_profiles/templates': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Verify profile message templates
     * @description List all Verify profile message templates.
     */
    get: operations['ListProfileMessageTemplates'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/verify_profiles/{verify_profile_id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Verify profile
     * @description Gets a single Verify profile.
     */
    get: operations['GetVerifyProfile'];
    put?: never;
    post?: never;
    /** Delete Verify profile */
    delete: operations['DeleteProfile'];
    options?: never;
    head?: never;
    /** Update Verify profile */
    patch: operations['UpdateVerifyProfile'];
    trace?: never;
  };
  '/virtual_cross_connects': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all Virtual Cross Connects
     * @description List all Virtual Cross Connects.
     */
    get: operations['ListVirtualCrossConnects'];
    put?: never;
    /**
     * Create a Virtual Cross Connect
     * @description Create a new Virtual Cross Connect.<br /><br />For AWS and GCE, you have the option of creating the primary connection first and the secondary connection later. You also have the option of disabling the primary and/or secondary connections at any time and later re-enabling them. With Azure, you do not have this option. Azure requires both the primary and secondary connections to be created at the same time and they can not be independantly disabled.
     */
    post: operations['CreateVirtualCrossConnect'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/virtual_cross_connects/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a Virtual Cross Connect
     * @description Retrieve a Virtual Cross Connect.
     */
    get: operations['GetVirtualCrossConnect'];
    put?: never;
    post?: never;
    /**
     * Delete a Virtual Cross Connect
     * @description Delete a Virtual Cross Connect.
     */
    delete: operations['DeleteVirtualCrossConnect'];
    options?: never;
    head?: never;
    /**
     * Update the Virtual Cross Connect
     * @description Update the Virtual Cross Connect.<br /><br />Cloud IPs can only be patched during the `created` state, as GCE will only inform you of your generated IP once the pending connection requested has been accepted. Once the Virtual Cross Connect has moved to `provisioning`, the IPs can no longer be patched.<br /><br />Once the Virtual Cross Connect has moved to `provisioned` and you are ready to enable routing, you can toggle the routing announcements to `true`.
     */
    patch: operations['UpdateVirtualCrossConnect'];
    trace?: never;
  };
  '/virtual_cross_connects_coverage': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List Virtual Cross Connect Cloud Coverage
     * @description List Virtual Cross Connects Cloud Coverage.<br /><br />This endpoint shows which cloud regions are available for the `location_code` your Virtual Cross Connect will be provisioned in.
     */
    get: operations['ListVirtualCrossConnectCoverage'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/webhook_deliveries': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List webhook deliveries
     * @description Lists webhook_deliveries for the authenticated user
     */
    get: operations['GetWebhookDeliveries'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/webhook_deliveries/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Find webhook_delivery details by ID
     * @description Provides webhook_delivery debug data, such as timestamps, delivery status and attempts.
     */
    get: operations['GetWebhookDelivery'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/wireguard_interfaces': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all WireGuard Interfaces
     * @description List all WireGuard Interfaces.
     */
    get: operations['ListWireguardInterfaces'];
    put?: never;
    /**
     * Create a WireGuard Interface
     * @description Create a new WireGuard Interface. Current limitation of 10 interfaces per user can be created.
     */
    post: operations['CreateWireguardInterface'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/wireguard_interfaces/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve a WireGuard Interfaces
     * @description Retrieve a WireGuard Interfaces.
     */
    get: operations['GetWireguardInterface'];
    put?: never;
    post?: never;
    /**
     * Delete a WireGuard Interface
     * @description Delete a WireGuard Interface.
     */
    delete: operations['DeleteWireguardInterface'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/wireguard_peers': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * List all WireGuard Peers
     * @description List all WireGuard peers.
     */
    get: operations['ListWireguardPeers'];
    put?: never;
    /**
     * Create a WireGuard Peer
     * @description Create a new WireGuard Peer. Current limitation of 5 peers per interface can be created.
     */
    post: operations['CreateWireguardPeer'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/wireguard_peers/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve the WireGuard Peer
     * @description Retrieve the WireGuard peer.
     */
    get: operations['GetWireguardPeer'];
    put?: never;
    post?: never;
    /**
     * Delete the WireGuard Peer
     * @description Delete the WireGuard peer.
     */
    delete: operations['DeleteWireguardPeer'];
    options?: never;
    head?: never;
    /**
     * Update the WireGuard Peer
     * @description Update the WireGuard peer.
     */
    patch: operations['UpdateWireguardPeer'];
    trace?: never;
  };
  '/wireguard_peers/{id}/config': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Retrieve Wireguard config template for Peer
     * @description Retrieve Wireguard config template for Peer
     */
    get: operations['GetWireguardPeerConfig'];
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/wireless/detail_records_reports': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get all Wireless Detail Records (WDRs) Reports
     * @description Returns the WDR Reports that match the given parameters.
     */
    get: operations['GetWdrReports'];
    put?: never;
    /**
     * Create a Wireless Detail Records (WDRs) Report
     * @description Asynchronously create a report containing Wireless Detail Records (WDRs) for the SIM cards that consumed wireless data in the given time period.
     *
     */
    post: operations['CreateWdrReport'];
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/wireless/detail_records_reports/{id}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * Get a Wireless Detail Record (WDR) Report
     * @description Returns one specific WDR report
     */
    get: operations['GetWdrReport'];
    put?: never;
    post?: never;
    /**
     * Delete a Wireless Detail Record (WDR) Report
     * @description Deletes one specific WDR report.
     */
    delete: operations['DeleteWdrReport'];
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
  '/{bucketName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * ListObjectsV2
     * @description List all objects contained in a given bucket.
     */
    get: operations['ListObjects'];
    /**
     * CreateBucket
     * @description Create a bucket.
     */
    put: operations['CreateBucket'];
    /**
     * DeleteObjects
     * @description Deletes one or multiple objects from a given bucket.
     */
    post: operations['DeleteObjects'];
    /**
     * DeleteBucket
     * @description Deletes a bucket. The bucket must be empty for it to be deleted.
     */
    delete: operations['DeleteBucket'];
    options?: never;
    /**
     * HeadBucket
     * @description Determines if a bucket exists and you have permission to access it.
     */
    head: operations['HeadBucket'];
    patch?: never;
    trace?: never;
  };
  '/{bucketName}/{objectName}': {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /**
     * GetObject
     * @description Retrieves an object from a given bucket.
     */
    get: operations['GetObject'];
    /**
     * PutObject
     * @description Add an object to a bucket.
     */
    put: operations['PutObject'];
    post?: never;
    /**
     * DeleteObject
     * @description Delete an object from a given bucket.
     */
    delete: operations['DeleteObject'];
    options?: never;
    /**
     * HeadObject
     * @description Retrieves metadata from an object without returning the object itself.
     */
    head: operations['HeadObject'];
    patch?: never;
    trace?: never;
  };
  '/{bucketName}/{objectName}/uploads/{uploadID}': {
    parameters: {
      query?: never;
      header?: never;
      path: {
        bucketName: string;
        objectName: string;
        uploadID: string;
      };
      cookie?: never;
    };
    get?: never;
    put?: never;
    post?: never;
    delete?: never;
    options?: never;
    head?: never;
    patch?: never;
    trace?: never;
  };
}
export type webhooks = Record<string, never>;
export interface components {
  schemas: {
    /** AWS Voice Settings */
    AWSVoiceSettings: Record<string, never>;
    AcceptSuggestionsRequest: {
      /** @description The ID of the address. */
      id?: string;
    };
    /** AccessIPAddressListResponseSchema */
    AccessIPAddressListResponseSchema: {
      /** Data */
      data: components['schemas']['AccessIPAddressResponseSchema'][];
      meta: components['schemas']['PaginationMeta'];
    };
    /** AccessIPAddressPOST */
    AccessIPAddressPOST: {
      /** Ip Address */
      ip_address: string;
      /** Description */
      description?: string;
    };
    /** AccessIPAddressResponseSchema */
    AccessIPAddressResponseSchema: {
      /** Id */
      id: string;
      /** Ip Address */
      ip_address: string;
      /** Source */
      source: string;
      status: components['schemas']['CloudflareSyncStatus'];
      /** Description */
      description?: string;
      /** User Id */
      user_id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at?: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at?: string;
    };
    /** AccessIPRangeListResponseSchema */
    AccessIPRangeListResponseSchema: {
      /** Data */
      data: components['schemas']['AccessIPRangeResponseSchema'][];
      meta: components['schemas']['PaginationMeta'];
    };
    /** AccessIPRangePOST */
    AccessIPRangePOST: {
      /** Cidr Block */
      cidr_block: string;
      /** Description */
      description?: string;
    };
    /** AccessIPRangeResponseSchema */
    AccessIPRangeResponseSchema: {
      /** Id */
      id: string;
      /** Cidr Block */
      cidr_block: string;
      status: components['schemas']['CloudflareSyncStatus'];
      /** Description */
      description?: string;
      /** User Id */
      user_id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at?: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at?: string;
    };
    /** @example 61bf923e-5e4d-4595-a110-56190ea18a1b */
    AccountSid: string;
    ActionsParticipantsRequest: {
      /** @description Either a list of participant id to perform the action on, or the keyword "all" to perform the action on all participant. */
      participants?: 'all' | string[];
      /** @description List of participant id to exclude from the action. */
      exclude?: string[];
    };
    /**
     * Active Call
     * @example {
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "call_leg_id": "2dc6fc34-f9e0-11ea-b68e-02420a0f7768",
     *       "call_session_id": "2dc1b3c8-f9e0-11ea-bc5a-02420a0f7768",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "call_duration": 50,
     *       "record_type": "call"
     *     }
     */
    ActiveCall: {
      /**
       * @example call
       * @enum {string}
       */
      record_type: 'call';
      /**
       * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call
       * @example 428c31b6-7af4-4bcb-b68e-5013ef9657c1
       */
      call_session_id: string;
      /**
       * @description ID that is unique to the call and can be used to correlate webhook events
       * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
       */
      call_leg_id: string;
      /**
       * @description Unique identifier and token for controlling the call.
       * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
       */
      call_control_id: string;
      /**
       * @description State received from a command.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state: string;
      /**
       * @description Indicates the duration of the call in seconds
       * @example 50
       */
      call_duration: number;
    };
    /** Address */
    Address: {
      /**
       * Format: int64
       * @description Uniquely identifies the address.
       * @example 1293384261075731499
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example address
       */
      record_type?: string;
      customer_reference?: components['schemas']['customer_reference'];
      first_name?: components['schemas']['first_name'];
      last_name?: components['schemas']['last_name'];
      business_name?: components['schemas']['business_name'];
      phone_number?: components['schemas']['phone_number'];
      street_address?: components['schemas']['street_address'];
      extended_address?: components['schemas']['extended_address'];
      locality?: components['schemas']['locality'];
      administrative_area?: components['schemas']['administrative_area'];
      neighborhood?: components['schemas']['neighborhood'];
      borough?: components['schemas']['borough'];
      postal_code?: components['schemas']['postal_code'];
      country_code?: components['schemas']['country_code'];
      address_book?: components['schemas']['address_book'];
      validate_address?: components['schemas']['validate_address'];
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    AddressCreate: {
      customer_reference?: components['schemas']['customer_reference'];
      first_name: components['schemas']['first_name'];
      last_name: components['schemas']['last_name'];
      business_name: components['schemas']['business_name'];
      phone_number?: components['schemas']['phone_number'];
      street_address: components['schemas']['street_address'];
      extended_address?: components['schemas']['extended_address'];
      locality: components['schemas']['locality'];
      administrative_area?: components['schemas']['administrative_area'];
      neighborhood?: components['schemas']['neighborhood'];
      borough?: components['schemas']['borough'];
      postal_code?: components['schemas']['postal_code'];
      country_code: components['schemas']['country_code'];
      address_book?: components['schemas']['address_book'];
      validate_address?: components['schemas']['validate_address'];
    };
    AddressSuggestionResponse: {
      data?: {
        /** @description Indicates if the address suggestions are accepted. */
        accepted?: boolean;
        /**
         * Format: uuid
         * @description The UUID of the location.
         */
        id?: string;
        /** @enum {string} */
        record_type?: 'address_suggestion';
      };
    };
    /**
     * AltBusinessIdType
     * @description An enumeration.
     * @enum {unknown}
     */
    AltBusinessIdType: 'NONE' | 'DUNS' | 'GIIN' | 'LEI';
    AmdDetailRecord: {
      /**
       * @description Feature invocation id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      id?: string;
      /**
       * Format: date-time
       * @description Feature invocation time
       * @example 2020-07-01T00:00:00Z
       */
      invoked_at?: string;
      /**
       * @description Feature name
       * @enum {string}
       */
      feature?: 'PREMIUM';
      /**
       * @description User-provided tags
       * @example tag1,tag2
       */
      tags?: string;
      /**
       * @description Billing Group id
       * @example 01977831-abdd-4894-84f3-244385621424
       */
      billing_group_id?: string;
      /**
       * @description Name of the Billing Group specified in billing_group_id
       * @example Billing group name
       */
      billing_group_name?: string;
      /**
       * @description Connection id
       * @example 1684947189014463919
       */
      connection_id?: string;
      /**
       * @description Connection name
       * @example Name of the connection with id specified in connection_id field
       */
      connection_name?: string;
      /**
       * @description Telnyx UUID that identifies the related call leg
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      call_leg_id?: string;
      /**
       * @description Telnyx UUID that identifies the related call session
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      call_session_id?: string;
      /**
       * @description Indicates whether Telnyx billing charges might be applicable
       * @example true
       */
      is_telnyx_billable?: boolean;
      /**
       * @description Currency amount per billing unit used to calculate the Telnyx billing cost
       * @example 0.002
       */
      rate?: string;
      /**
       * @description Billing unit used to calculate the Telnyx billing cost
       * @example invocations
       */
      rate_measured_in?: string;
      /**
       * @description Currency amount for Telnyx billing cost
       * @example 0.004
       */
      cost?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'AmdDetailRecord';
    };
    /**
     * Anchorsite Override
     * @description `Latency` directs Telnyx to route media through the site with the lowest round-trip time to the user's connection. Telnyx calculates this time using ICMP ping messages. This can be disabled by specifying a site to handle all media.
     * @default Latency
     * @example Amsterdam, Netherlands
     * @enum {string}
     */
    AnchorsiteOverride:
      | 'Latency'
      | 'Chicago, IL'
      | 'Ashburn, VA'
      | 'San Jose, CA'
      | 'Sydney, Australia'
      | 'Amsterdam, Netherlands'
      | 'London, UK'
      | 'Toronto, Canada'
      | 'Vancouver, Canada'
      | 'Frankfurt, Germany';
    /**
     * Answer Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "webhook_url": "https://www.example.com/server-b/",
     *       "webhook_url_method": "POST",
     *       "send_silence_when_idle": true
     *     }
     */
    AnswerRequest: {
      /**
       * Format: uuid
       * @description Use this field to set the Billing Group ID for the call. Must be a valid and existing Billing Group ID.
       * @example f5586561-8ff0-4291-a0ac-84fe544797bd
       */
      billing_group_id?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Custom headers to be added to the SIP INVITE response.
       * @example [
       *       {
       *         "name": "head_1",
       *         "value": "val_1"
       *       },
       *       {
       *         "name": "head_2",
       *         "value": "val_2"
       *       }
       *     ]
       */
      custom_headers?: components['schemas']['CustomSipHeader'][];
      /**
       * @description The list of comma-separated codecs in a preferred order for the forked media to be received.
       * @example G722,PCMU,PCMA,G729,OPUS,VP8,H264
       * @enum {string}
       */
      preferred_codecs?: 'G722,PCMU,PCMA,G729,OPUS,VP8,H264';
      /**
       * @description SIP headers to be added to the SIP INVITE response. Currently only User-to-User header is supported.
       * @example [
       *       {
       *         "name": "User-to-User",
       *         "value": "value"
       *       }
       *     ]
       */
      sip_headers?: components['schemas']['SipHeader'][];
      sound_modifications?: components['schemas']['SoundModifications'];
      /**
       * @description The destination WebSocket address where the stream is going to be delivered.
       * @example wss://www.example.com/websocket
       */
      stream_url?: string;
      /**
       * @description Specifies which track should be streamed.
       * @default inbound_track
       * @example both_tracks
       * @enum {string}
       */
      stream_track: 'inbound_track' | 'outbound_track' | 'both_tracks';
      stream_bidirectional_mode?: components['schemas']['StreamBidirectionalMode'];
      stream_bidirectional_codec?: components['schemas']['StreamBidirectionalCodec'];
      /**
       * @description Generate silence RTP packets when no transmission available.
       * @default false
       * @example true
       */
      send_silence_when_idle: boolean;
      /**
       * @description Use this field to override the URL for which Telnyx will send subsequent webhooks to for this call.
       * @example https://www.example.com/server-b/
       */
      webhook_url?: string;
      /**
       * @description HTTP request type used for `webhook_url`.
       * @default POST
       * @example GET
       * @enum {string}
       */
      webhook_url_method: 'POST' | 'GET';
      /**
       * @description Enable transcription upon call answer. The default value is false.
       * @default false
       * @example true
       */
      transcription: boolean;
      transcription_config?: components['schemas']['TranscriptionStartRequest'];
    };
    /**
     * Application Name
     * @description A user-assigned name to help manage the application.
     * @example call-router
     */
    ApplicationName: string;
    /** AssignProfileToCampaignRequest */
    AssignProfileToCampaignRequest: {
      /**
       * Messagingprofileid
       * @description The ID of the messaging profile that you want to link to the specified campaign.
       * @example 4001767e-ce0f-4cae-9d5f-0d5e636e7809
       */
      messagingProfileId: string;
      /**
       * Tcrcampaignid
       * @description The TCR ID of the shared campaign you want to link to the specified messaging profile (for campaigns not created using Telnyx 10DLC services only). If you supply this ID in the request, do not also include a campaignId.
       * @example CWZTFH1
       */
      tcrCampaignId?: string;
      /**
       * Campaignid
       * @description The ID of the campaign you want to link to the specified messaging profile. If you supply this ID in the request, do not also include a tcrCampaignId.
       * @example 4b300178-131c-d902-d54e-72d90ba1620j
       */
      campaignId?: string;
    };
    /** AssignProfileToCampaignResponse */
    AssignProfileToCampaignResponse: {
      /**
       * Messagingprofileid
       * @description The ID of the messaging profile that you want to link to the specified campaign.
       * @example 4001767e-ce0f-4cae-9d5f-0d5e636e7809
       */
      messagingProfileId: string;
      /**
       * Tcrcampaignid
       * @description The TCR ID of the shared campaign you want to link to the specified messaging profile (for campaigns not created using Telnyx 10DLC services only). If you supply this ID in the request, do not also include a campaignId.
       * @example CWZTFH1
       */
      tcrCampaignId?: string;
      /**
       * Campaignid
       * @description The ID of the campaign you want to link to the specified messaging profile. If you supply this ID in the request, do not also include a tcrCampaignId.
       * @example 4b300178-131c-d902-d54e-72d90ba1620j
       */
      campaignId?: string;
      /**
       * Taskid
       * @description The ID of the task associated with assigning a messaging profile to a campaign.
       * @example 667a80f8-b0a9-49d0-b9ab-a7a1bcc45086
       */
      taskId: string;
    };
    /**
     * AssignmentStatus
     * @description An enumeration.
     * @enum {string}
     */
    AssignmentStatus: 'pending' | 'assigned' | 'failed';
    /** AssignmentTaskStatusResponse */
    AssignmentTaskStatusResponse: {
      /** Taskid */
      taskId: string;
      /**
       * @description The status of the task associated with assigning a messaging profile to a campaign.
       * @example pending
       */
      status: string & components['schemas']['TaskStatus'];
      /**
       * Createdat
       * Format: date-time
       */
      createdAt?: string;
      /**
       * Updatedat
       * Format: date-time
       */
      updatedAt?: string;
    };
    /** Assistant */
    Assistant: {
      /** Id */
      id: string;
      /** Name */
      name: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Description
       * @default
       */
      description: string;
      /** Model */
      model: string;
      /** Instructions */
      instructions: string;
      /**
       * Tools
       * @default [
       *       {
       *         "type": "retrieval",
       *         "retrieval": {
       *           "bucket_ids": [
       *             "my_bucket_id_1"
       *           ]
       *         }
       *       }
       *     ]
       */
      tools: (
        | components['schemas']['ChatCompletionToolParam']
        | components['schemas']['Retrieval']
      )[];
    };
    /**
     * AssistantDeletedResponse
     * @description Aligns with the OpenAI API:
     *     https://platform.openai.com/docs/api-reference/assistants/deleteAssistant
     */
    AssistantDeletedResponse: {
      /** Id */
      id: string;
      /** Object */
      object: string;
      /** Deleted */
      deleted: boolean;
    };
    /** AssistantsListData */
    AssistantsListData: {
      /** Data */
      data: components['schemas']['Assistant'][];
    };
    AudioTranscriptionRequest: {
      /**
       * Format: binary
       * @description The audio file object to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm. File uploads are limited to 100 MB.
       */
      file: string;
      /**
       * @description ID of the model to use. Only `distil-whisper/distil-large-v2` is currently available.
       * @example distil-whisper/distil-large-v2
       * @enum {string}
       */
      model: 'distil-whisper/distil-large-v2';
      /**
       * @description The format of the transcript output. Use `verbose_json` to take advantage of timestamps.
       * @default json
       * @example json
       * @enum {string}
       */
      response_format: 'json' | 'verbose_json';
      /**
       * @description The timestamp granularities to populate for this transcription. `response_format` must be set verbose_json to use timestamp granularities. Currently `segment` is supported.
       * @example json
       * @enum {string}
       */
      'timestamp_granularities[]'?: 'segment';
    };
    AudioTranscriptionResponse: {
      /** @description The transcribed text for the audio file. */
      text: string;
      /** @description The duration of the audio file in seconds. This is only included if `response_format` is set to `verbose_json`. */
      duration?: number;
      /** @description Segments of the transcribed text and their corresponding details. This is only included if `response_format` is set to `verbose_json`. */
      segments?: components['schemas']['AudioTranscriptionResponseSegments'][];
    };
    AudioTranscriptionResponseSegments: {
      /** @description Unique identifier of the segment. */
      id: number;
      /** @description Start time of the segment in seconds. */
      start: number;
      /** @description End time of the segment in seconds. */
      end: number;
      /** @description Text content of the segment. */
      text: string;
    };
    AuditLogEntry: {
      /**
       * Format: uuid
       * @description Unique identifier for the audit log entry
       */
      id?: string;
      /**
       * Format: uuid
       * @description Unique identifier for the user who made the change
       */
      user_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example audit_event
       */
      record_type?: string;
      /** @description Unique identifier for the resource that was changed */
      resource_id?: string;
      /**
       * Format: uuid
       * @description Unique identifier for the organization that owns the resource
       */
      organization_id?: string;
      changes?:
        | {
            /**
             * @description Identifies the name of the field that was changed
             * @example inbound.timeout_1xx_secs
             */
            field?: string;
            /** @description Value of the field before the change was made. This field can be any JSON type. */
            from?: unknown;
            /** @description Value of the field after the change was made. This field can be any JSON type. */
            to?: unknown;
          }[]
        | null;
      /**
       * @description Indicates what type of user made the change
       * @enum {string}
       */
      change_made_by?:
        | 'account_owner'
        | 'organization_member'
        | 'account_manager'
        | 'telnyx';
      /** @description Identifies the type of the resource that was changed */
      resource_type?: string;
      /** @description Identifies the type of change that was made */
      change_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the change was made
       * @example 2020-01-01T00:00:00Z
       */
      created_at?: string;
    };
    /** AuthenticationProvider */
    AuthenticationProvider: {
      /**
       * Format: uuid
       * @description Uniquely identifies the authentication provider.
       * @example 35146afd-df93-4963-b1e9-1a085e2ae874
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example authentication_provider
       */
      record_type?: string;
      name?: components['schemas']['name'];
      short_name?: components['schemas']['short_name'];
      organization_id?: components['schemas']['organization_id'];
      active?: components['schemas']['active'];
      /** @description The settings associated with the authentication provider. */
      settings?: {
        /**
         * @description The Assertion Consumer Service URL for the service provider (Telnyx).
         * @example https://api.telnyx.com/sso/saml/auth/myorg
         */
        assertion_consumer_service_url?: string;
        /**
         * @description The Entity ID for the service provider (Telnyx).
         * @example https://api.telnyx.com/sso/saml/metadata/myorg
         */
        service_provider_entity_id?: string;
        /**
         * @description The Entity ID for the identity provider (IdP).
         * @example https://myorg.myidp.com/saml/metadata
         */
        idp_entity_id?: string;
        /**
         * @description The SSO target url for the identity provider (IdP).
         * @example https://myorg.myidp.com/trust/saml2/http-post/sso
         */
        idp_sso_target_url?: string;
        /**
         * @description The certificate fingerprint for the identity provider (IdP)
         * @example 13:38:C7:BB:C9:FF:4A:70:38:3A:E3:D9:5C:CD:DB:2E:50:1E:80:A7
         */
        idp_cert_fingerprint?: string;
        /**
         * @description The algorithm used to generate the identity provider's (IdP) certificate fingerprint
         * @default sha1
         * @example sha256
         * @enum {string}
         */
        idp_cert_fingerprint_algorithm: 'sha1' | 'sha256' | 'sha384' | 'sha512';
        /**
         * @description The name identifier format associated with the authentication provider. This must be the same for both the Identity Provider (IdP) and the service provider (Telnyx).
         * @example urn:oasis:names:tc:SAML:1.1:nameid-format
         */
        name_identifier_format?: string;
      };
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    AuthenticationProviderCreate: {
      name: components['schemas']['name'];
      short_name: components['schemas']['short_name'];
      active?: components['schemas']['active'];
      settings: components['schemas']['settings'];
      settings_url?: components['schemas']['settings_url'];
    };
    AutoRechargePref: {
      /**
       * @description The unique identifier for the auto recharge preference.
       * @example 1524126400473204723
       */
      id?: string;
      /**
       * @description The record type.
       * @example auto_recharge_pref
       */
      record_type?: string;
      /**
       * Format: decimal
       * @description The threshold amount at which the account will be recharged.
       * @example 104.00
       */
      threshold_amount?: string;
      /**
       * Format: decimal
       * @description The amount to recharge the account, the actual recharge amount will be the amount necessary to reach the threshold amount plus the recharge amount.
       * @example 104.00
       */
      recharge_amount?: string;
      /**
       * @description Whether auto recharge is enabled.
       * @example true
       */
      enabled?: boolean;
      /** @example true */
      invoice_enabled?: boolean;
      /**
       * @description The payment preference for auto recharge.
       * @example credit_paypal
       * @enum {string}
       */
      preference?: 'credit_paypal' | 'ach';
    };
    AutoRechargePrefRequest: {
      /**
       * Format: decimal
       * @description The threshold amount at which the account will be recharged.
       * @example 104.00
       */
      threshold_amount?: string;
      /**
       * Format: decimal
       * @description The amount to recharge the account, the actual recharge amount will be the amount necessary to reach the threshold amount plus the recharge amount.
       * @example 104.00
       */
      recharge_amount?: string;
      /**
       * @description Whether auto recharge is enabled.
       * @example true
       */
      enabled?: boolean;
      /** @example true */
      invoice_enabled?: boolean;
      /**
       * @description The payment preference for auto recharge.
       * @example credit_paypal
       * @enum {string}
       */
      preference?: 'credit_paypal' | 'ach';
    };
    /** AutoRespConfigCreateSchema */
    AutoRespConfigCreateSchema: {
      /**
       * Op
       * @enum {string}
       */
      op: 'start' | 'stop' | 'info';
      /**
       * Keywords
       * @example [
       *       "keyword1",
       *       "keyword2"
       *     ]
       */
      keywords: string[];
      /**
       * Resp Text
       * @example Thank you for your message
       */
      resp_text?: string;
      /**
       * Country Code
       * @example US
       */
      country_code: string;
    };
    /** AutorespConfigResponseSchema */
    AutorespConfigResponseSchema: {
      data: components['schemas']['AutorespConfigSchema'];
    };
    /** AutorespConfigSchema */
    AutorespConfigSchema: {
      /**
       * Op
       * @example start
       * @enum {string}
       */
      op: 'start' | 'stop' | 'info';
      /**
       * Keywords
       * @example [
       *       "START",
       *       "BEGIN"
       *     ]
       */
      keywords: string[];
      /**
       * Resp Text
       * @example Thank you for subscribing to our service.
       */
      resp_text?: string;
      /**
       * Country Code
       * @example *
       */
      country_code: string;
      /**
       * Id
       * @example b8f9c1c0-5b5a-4b1e-8c1c-0b5a4b1e8c1c
       */
      id: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at: string;
    };
    /**
     * AutorespConfigsResponseSchema
     * @description List of Auto-Response Settings
     */
    AutorespConfigsResponseSchema: {
      /** Data */
      data: components['schemas']['AutorespConfigSchema'][];
      meta: components['schemas']['PaginationMeta'];
    };
    /** @example {
     *       "record_type": "available_phone_number",
     *       "phone_number": "+19705555098",
     *       "vanity_format": "",
     *       "best_effort": false,
     *       "quickship": true,
     *       "reservable": true,
     *       "region_information": [
     *         {
     *           "region_type": "country_code",
     *           "region_name": "US"
     *         }
     *       ],
     *       "cost_information": {
     *         "upfront_cost": "3.21",
     *         "monthly_cost": "6.54",
     *         "currency": "USD"
     *       },
     *       "features": [
     *         {
     *           "name": "sms"
     *         },
     *         {
     *           "name": "voice"
     *         }
     *       ]
     *     } */
    AvailablePhoneNumber: {
      /**
       * @example available_phone_number
       * @enum {string}
       */
      record_type?: 'available_phone_number';
      /** @example +19705555098 */
      phone_number?: string;
      vanity_format?: string;
      /**
       * @description Specifies whether the phone number is an exact match based on the search criteria or not.
       * @example false
       */
      best_effort?: boolean;
      /**
       * @description Specifies whether the phone number can receive calls immediately after purchase or not.
       * @example true
       */
      quickship?: boolean;
      /**
       * @description Specifies whether the phone number can be reserved before purchase or not.
       * @example true
       */
      reservable?: boolean;
      region_information?: components['schemas']['RegionInformation'][];
      cost_information?: components['schemas']['CostInformation'];
      features?: components['schemas']['Feature'][];
    };
    /** @example {
     *       "record_type": "available_phone_number_block",
     *       "phone_number": "+19705555000",
     *       "range": 10,
     *       "region_information": [
     *         {
     *           "region_type": "country_code",
     *           "region_name": "US"
     *         }
     *       ],
     *       "cost_information": {
     *         "upfront_cost": "3.21",
     *         "monthly_cost": "6.54",
     *         "currency": "USD"
     *       },
     *       "features": [
     *         {
     *           "name": "sms"
     *         },
     *         {
     *           "name": "voice"
     *         }
     *       ]
     *     } */
    AvailablePhoneNumberBlock: {
      /**
       * @example available_phone_number_block
       * @enum {string}
       */
      record_type?: 'available_phone_number_block';
      /** @example +19705555000 */
      starting_number?: string;
      /** @example 10 */
      range?: number;
      region_information?: components['schemas']['RegionInformation'][];
      cost_information?: components['schemas']['CostInformation'];
      features?: components['schemas']['Feature'][];
    };
    /** @example {
     *       "total_results": 100,
     *       "best_effort_results": 50
     *     } */
    AvailablePhoneNumbersMetadata: {
      /** @example 1 */
      total_results?: number;
      /** @example 0 */
      best_effort_results?: number;
    };
    /**
     * Available service
     * @enum {string}
     */
    AvailableService:
      | 'cloud_vpn'
      | 'private_wireless_gateway'
      | 'virtual_cross_connect';
    /**
     * @description AWS credentials access key id.
     * @example AKIAIOSFODNN7EXAMPLE
     */
    AwsAccessKeyId: string;
    /**
     * @description AWS secret access key.
     * @example wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
     */
    AwsSecretAccessKey: string;
    /**
     * @description Azure Blob Storage account key
     * @example bPxRfiCYEXAMPLEKEY
     */
    AzureAccountKey: string;
    /**
     * @description Azure Blob Storage account name
     * @example my-account
     */
    AzureAccountName: string;
    /** Azure Blob Storage Configuration Data */
    AzureConfigurationData: {
      bucket?: components['schemas']['Bucket'];
      account_name?: components['schemas']['AzureAccountName'];
      account_key?: components['schemas']['AzureAccountKey'];
    };
    /**
     * BackgroundTaskStatus
     * @description Status of an embeddings task.
     * @enum {string}
     */
    BackgroundTaskStatus:
      | 'queued'
      | 'processing'
      | 'success'
      | 'failure'
      | 'partial_success';
    /** BackgroundTasksQueryResponse */
    BackgroundTasksQueryResponse: {
      /** User Id */
      user_id: string;
      /** Task Id */
      task_id: string;
      /** Task Name */
      task_name: string;
      status: components['schemas']['BackgroundTaskStatus'];
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Finished At
       * Format: date-time
       */
      finished_at?: string;
      /** Bucket */
      bucket?: string;
    };
    /** BackgroundTasksQueryResponseData */
    BackgroundTasksQueryResponseData: {
      /** Data */
      data: components['schemas']['BackgroundTasksQueryResponse'][];
    };
    /** @example {
     *       "record_type": "billing_group",
     *       "id": "f5586561-8ff0-4291-a0ac-84fe544797bd",
     *       "organization_id": "f1486bae-f067-460c-ad43-73a92848f902",
     *       "name": "My billing group name",
     *       "created_at": "2019-10-15T10:07:15.527Z",
     *       "updated_at": "2019-10-15T10:07:15.527Z",
     *       "deleted_at": null
     *     } */
    BillingGroup: {
      /**
       * @description Identifies the type of the resource.
       * @example billing_group
       * @enum {string}
       */
      record_type?: 'billing_group';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example f5586561-8ff0-4291-a0ac-84fe544797bd
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identifies the organization that owns the resource.
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      organization_id?: string;
      /**
       * Format: string
       * @description A user-specified name for the billing group
       * @example My billing group name
       */
      name?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2019-10-15T10:07:15.527Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2019-10-15T10:07:15.527Z
       */
      updated_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was removed.
       * @example null
       */
      deleted_at?: string;
    };
    /** ListedBrand */
    BrandBasic: {
      /**
       * @description Unique identifier assigned to the brand.
       * @example 4b206179-f731-8ab7-f19c-34e19d22ide9
       */
      brandId?: string;
      /**
       * @description Unique identifier assigned to the brand by the registry.
       * @example BBRAND1
       */
      tcrBrandId?: string;
      entityType?: components['schemas']['EntityType'];
      identityStatus?: components['schemas']['BrandIdentityStatus'];
      /**
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example Example Company Inc.
       */
      companyName?: string;
      /**
       * @description Display or marketing name of the brand.
       * @example Example Company
       */
      displayName?: string;
      /**
       * @description Valid email address of brand support contact.
       * @example examplename@examplecompany.com
       */
      email?: string;
      /**
       * @description Brand website URL.
       * @example www.examplecompany.com
       */
      website?: string;
      /**
       * failureReasons
       * @description Failure reasons for brand
       */
      failureReasons?: unknown;
      /**
       * status
       * @description Status of the brand
       * @enum {unknown}
       */
      status?: 'OK' | 'REGISTRATION_PENDING' | 'REGISTRATION_FAILED';
      /**
       * @description Date and time that the brand was created at.
       * @example 2021-03-08T17:57:48.801186
       */
      createAt?: string;
      /**
       * @description Date and time that the brand was last updated at.
       * @example 2021-03-08T17:57:48.801186
       */
      updatedAt?: string;
      /**
       * @description Number of campaigns associated with the brand
       * @example 2
       */
      assignedCampaingsCount?: number;
    };
    /** BrandFeedback */
    BrandFeedback: {
      /**
       * Brandid
       * @description ID of the brand being queried about
       * @example d88dd2aa-1bb9-4ef0-9ec8-1752b80316a5
       */
      brandId: string;
      /**
       * Category
       * @description A list of reasons why brand creation/revetting didn't go as planned
       */
      category: components['schemas']['BrandFeedbackCategory'][];
    };
    /** BrandFeedbackCategory */
    BrandFeedbackCategory: {
      /**
       * Id
       * @description One of `TAX_ID`, `STOCK_SYMBOL`, `GOVERNMENT_ENTITY`, `NONPROFIT`, and `OTHERS`
       * @example TAX_ID
       */
      id: string;
      /**
       * Displayname
       * @description Human-readable version of the `id` field
       * @example Tax Id
       */
      displayName: string;
      /**
       * Description
       * @description Long-form description of the feedback with additional information
       * @example Tax Id does not match with the company name or business type.
       */
      description: string;
      /**
       * Fields
       * @description List of relevant fields in the originally-submitted brand json
       * @example [
       *       "ein",
       *       "companyName",
       *       "entityType"
       *     ]
       */
      fields: string[];
    };
    /**
     * BrandIdentityStatus
     * @description The verification status of an active brand
     * @enum {unknown}
     */
    BrandIdentityStatus:
      | 'VERIFIED'
      | 'UNVERIFIED'
      | 'SELF_DECLARED'
      | 'VETTED_VERIFIED';
    /** BrandOptionalAttributes */
    BrandOptionalAttributes: {
      /**
       * Taxexemptstatus
       * @description The tax exempt status of the brand
       */
      taxExemptStatus?: string;
    };
    /** BrandRecordSetCSP */
    BrandRecordSetCSP: {
      /** Records */
      records?: components['schemas']['BrandBasic'][];
      /**
       * Page
       * @example 1
       */
      page?: number;
      /**
       * Totalrecords
       * @example 1
       */
      totalRecords?: number;
    };
    /**
     * BrandRelationship
     * @description Brand relationship to the CSP.
     * @enum {unknown}
     */
    BrandRelationship:
      | 'BASIC_ACCOUNT'
      | 'SMALL_ACCOUNT'
      | 'MEDIUM_ACCOUNT'
      | 'LARGE_ACCOUNT'
      | 'KEY_ACCOUNT';
    /** Brand */
    BrandRequest: {
      entityType: components['schemas']['EntityType'];
      /**
       * Cspid
       * @description Unique identifier assigned to the csp by the registry.
       */
      cspId?: string;
      /**
       * Brandid
       * @description Unique identifier assigned to the brand.
       * @example 4b206179-f731-8ab7-f19c-34e19d22ide9
       */
      brandId?: string;
      /**
       * Displayname
       * @description Display or marketing name of the brand.
       * @example Example Company
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example Example Company Inc.
       */
      companyName?: string;
      /**
       * Ein
       * @description (Required for Non-profit/private/public) Government assigned corporate tax ID. EIN is 9-digits in U.S. The only entity type which does not require an EIN is a Sole Proprietor.
       * @example 142536893
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +13259390512
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123 Example St.
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example Chicago
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example IL
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 60654
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       * @example examplename@examplecompany.com
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example ABC
       */
      stockSymbol?: string;
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example www.examplecompany.com
       */
      website?: string;
      vertical: components['schemas']['Vertical'];
      /**
       * Altbusinessid
       * @description Alternate business identifier such as DUNS, LEI, or GIIN
       */
      altBusinessId?: string;
      altBusinessIdType?: components['schemas']['AltBusinessIdType'];
      /**
       * Universalein
       * @description Universal EIN of Brand, Read Only.
       */
      universalEin?: string;
    };
    /** Brand */
    BrandResponse: {
      entityType: components['schemas']['EntityType'];
      /**
       * Cspid
       * @description Unique identifier assigned to the csp by the registry.
       */
      cspId?: string;
      /**
       * Brandid
       * @description Unique identifier assigned to the brand.
       * @example 4b206179-f731-8ab7-f19c-34e19d22ide9
       */
      brandId?: string;
      /**
       * Displayname
       * @description Display or marketing name of the brand.
       * @example Example Company
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example Example Company Inc.
       */
      companyName?: string;
      /**
       * Ein
       * @description (Required for Non-profit/private/public) Government assigned corporate tax ID. EIN is 9-digits in U.S. The only entity type which does not require an EIN is a Sole Proprietor.
       * @example 142536893
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +13259390512
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123 Example St.
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example Chicago
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example IL
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 60654
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       * @example examplename@examplecompany.com
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example ABC
       */
      stockSymbol?: string;
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example www.examplecompany.com
       */
      website?: string;
      brandRelationship?: components['schemas']['BrandRelationship'];
      vertical: components['schemas']['Vertical'];
      /**
       * Altbusinessid
       * @description Alternate business identifier such as DUNS, LEI, or GIIN
       */
      altBusinessId?: string;
      altBusinessIdType?: components['schemas']['AltBusinessIdType'];
      /**
       * Universalein
       * @description Universal EIN of Brand, Read Only.
       */
      universalEin?: string;
      /**
       * identityStatus
       * @description TCR assessment of the brand identification status.
       * @example VERIFIED
       */
      identityStatus?: string;
    };
    /** BrandStatus */
    BrandStatus: {
      /**
       * Displayname
       * @description The display name of the brand submitted via bulk creation.
       * @example John's Donuts
       */
      displayName: string;
      /**
       * @description The current status of the brand.
       * @example pending
       */
      status: components['schemas']['CreationStatus'];
      /**
       * Brandid
       * @description The ID of the brand created via bulk creation. This brand will only have a brandId after the brand has been created.
       * @example 4b20017a-2f50-4c90-c9e6-5f67304cbde9
       */
      brandId?: string;
      /**
       * Created At
       * Format: date-time
       * @description The date and time that the brand was created.
       * @example 2021-06-30T10:49:04-07:00
       */
      created_at?: string;
      /**
       * Error
       * @description Errors related to a brand creation failure.
       * @example Missing firstName attribute.
       */
      error?: string;
    };
    /**
     * Bridge Request
     * @example {
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "park_after_unbridge": "self"
     *     }
     */
    BridgeRequest: {
      /**
       * @description The Call Control ID of the call you want to bridge with, can't be used together with queue parameter or video_room_id parameter.
       * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
       */
      call_control_id: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description The name of the queue you want to bridge with, can't be used together with call_control_id parameter or video_room_id parameter. Bridging with a queue means bridging with the first call in the queue. The call will always be removed from the queue regardless of whether bridging succeeds. Returns an error when the queue is empty.
       * @example support
       */
      queue?: string;
      /**
       * Format: uuid
       * @description The ID of the video room you want to bridge with, can't be used together with call_control_id parameter or queue parameter.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      video_room_id?: string;
      /**
       * @description The additional parameter that will be passed to the video conference. It is a text field and the user can decide how to use it. For example, you can set the participant name or pass JSON text. It can be used only with video_room_id parameter.
       * @example Alice
       */
      video_room_context?: string;
      /**
       * @description Specifies behavior after the bridge ends (i.e. the opposite leg either hangs up or is transferred). If supplied with the value `self`, the current leg will be parked after unbridge. If not set, the default behavior is to hang up the leg.
       * @example self
       */
      park_after_unbridge?: string;
      /**
       * @description Specifies whether to play a ringtone if the call you want to bridge with has not yet been answered.
       * @default false
       * @example true
       */
      play_ringtone: boolean;
    };
    /**
     * @description Name of the bucket to be used to store recording files.
     * @example example-bucket
     */
    Bucket: string;
    BucketAPIUsageResponse: {
      categories?: components['schemas']['BucketOps'][];
      total?: components['schemas']['BucketOpsTotal'];
      /**
       * Format: date-time
       * @description The time the usage was recorded
       * @example 2020-01-01T00:00:00Z
       */
      timestamp?: string;
    };
    /** BucketIds */
    BucketIds: {
      /** Bucket Ids */
      bucket_ids: string[];
      /** @description The maximum number of results to retrieve as context for the language model. */
      max_num_results?: number;
    };
    /** HTTPValidationError */
    BucketNotFoundError: {
      /** Detail */
      detail?: components['schemas']['NotFoundError'][];
    };
    BucketOps: {
      /**
       * @description The number of bytes sent
       * @example 123456
       */
      bytes_sent?: number;
      /**
       * @description The number of bytes received
       * @example 123456
       */
      bytes_received?: number;
      /**
       * @description The number of operations
       * @example 123456
       */
      ops?: number;
      /**
       * @description The number of successful operations
       * @example 123456
       */
      successful_ops?: number;
      /**
       * @description The category of the bucket operation
       * @example put_obj
       * @enum {string}
       */
      category?:
        | 'list_bucket'
        | 'list_buckets'
        | 'get-bucket_location'
        | 'create_bucket'
        | 'stat_bucket'
        | 'get_bucket_versioning'
        | 'set_bucket_versioning'
        | 'get_obj'
        | 'put_obj'
        | 'delete_obj';
    };
    BucketOpsTotal: {
      /**
       * @description The number of bytes sent
       * @example 123456
       */
      bytes_sent?: number;
      /**
       * @description The number of bytes received
       * @example 123456
       */
      bytes_received?: number;
      /**
       * @description The number of operations
       * @example 123456
       */
      ops?: number;
      /**
       * @description The number of successful operations
       * @example 123456
       */
      successful_ops?: number;
    };
    BucketUsage: {
      /**
       * @description The size of the bucket in bytes
       * @example 123456
       */
      size?: number;
      /**
       * @description The size of the bucket in kilobytes
       * @example 123456
       */
      size_kb?: number;
      /**
       * @description The number of objects in the bucket
       * @example 123456
       */
      num_objects?: number;
      /**
       * Format: date-time
       * @description The time the snapshot was taken
       * @example 2020-01-01T00:00:00Z
       */
      timestamp?: string;
    };
    /**
     * Bulk Credential Request
     * @example {
     *       "name": "Default Name",
     *       "tag": "My Credentials",
     *       "connection_id": "804252963366242252"
     *     }
     */
    BulkCredentialRequest: {
      /**
       * @description A default name for all credentials.
       * @example Default Credentials
       */
      name?: string;
      /**
       * @description Tags a credential for bulk operations. A single tag can hold at maximum 1000 credentials.
       * @example My Credentials
       */
      tag: string;
      /**
       * @description Amount of credentials to be created. A single tag can hold at maximum 1000 credentials
       * @example 100
       */
      amount?: number;
      /**
       * @description Identifies the connection this credential is associated with.
       * @example 1234567890
       */
      connection_id: string;
    };
    /** @example {
     *       "record_type": "messaging_numbers_bulk_update",
     *       "order_id": "00000000-0000-0000-0000-000000000000",
     *       "success": [
     *         "+18880000000",
     *         "+18880000001",
     *         "+18880000002"
     *       ],
     *       "pending": [],
     *       "failed": []
     *     } */
    BulkMessagingSettingsUpdatePhoneNumbers: {
      /**
       * @description Identifies the type of the resource.
       * @example messaging_numbers_bulk_update
       * @enum {string}
       */
      readonly record_type?: 'messaging_numbers_bulk_update';
      /**
       * Format: uuid
       * @description Order ID to verify bulk update status.
       */
      readonly order_id?: string;
      /** @description Phoned numbers updated successfully. */
      success?: string[];
      /** @description Phone numbers pending to be updated. */
      pending?: string[];
      /** @description Phone numbers that failed to update. */
      failed?: string[];
    };
    /** @example {
     *       "messaging_profile_id": "00000000-0000-0000-0000-000000000000",
     *       "numbers": [
     *         "+18880000000",
     *         "+18880000001",
     *         "+18880000002"
     *       ]
     *     } */
    BulkMessagingSettingsUpdatePhoneNumbersRequest: {
      /** @description Configure the messaging profile these phone numbers are assigned to:
       *
       *     * Set this field to `""` to unassign each number from their respective messaging profile
       *     * Set this field to a quoted UUID of a messaging profile to assign these numbers to that messaging profile */
      messaging_profile_id: string;
      /** @description The list of phone numbers to update. */
      numbers: string[];
    };
    /** @description This object represents a bulk SIM card action. It groups SIM card actions created through a bulk endpoint under a single resource for further lookup. */
    BulkSIMCardAction: {
      id?: components['schemas']['Id'];
      /** @example bulk_sim_card_action */
      readonly record_type?: string;
      /**
       * @description The operation type. It can be one of the following: <br/>
       *     <ul>
       *     <li><code>bulk_set_public_ips</code> - set a public IP for each specified SIM card.</li>
       *     </ul>
       * @example bulk_set_public_ips
       * @enum {string}
       */
      readonly action_type?: 'bulk_set_public_ips';
      /**
       * @description A JSON object representation of the bulk action payload.
       * @example {}
       */
      readonly settings?: Record<string, never>;
      created_at?: components['schemas']['CreatedAt'];
      updated_at?: components['schemas']['UpdatedAt'];
    };
    BulkSIMCardActionDetailed: {
      id?: components['schemas']['Id'];
      /** @example bulk_sim_card_action */
      readonly record_type?: string;
      /**
       * @description The operation type. It can be one of the following: <br/>
       *     <ul>
       *     <li><code>bulk_set_public_ips</code> - set a public IP for each specified SIM card.</li>
       *     </ul>
       * @example bulk_set_public_ips
       * @enum {string}
       */
      readonly action_type?: 'bulk_set_public_ips';
      /**
       * @description A JSON object representation of the bulk action payload.
       * @example {}
       */
      readonly settings?: Record<string, never>;
      sim_card_actions_summary?: components['schemas']['SIMCardActionsSummary'][];
      created_at?: components['schemas']['CreatedAt'];
      updated_at?: components['schemas']['UpdatedAt'];
    };
    /**
     * Call
     * @example {
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "call_leg_id": "2dc6fc34-f9e0-11ea-b68e-02420a0f7768",
     *       "call_session_id": "2dc1b3c8-f9e0-11ea-bc5a-02420a0f7768",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "is_alive": false,
     *       "call_duration": 50,
     *       "record_type": "call"
     *     }
     */
    Call: {
      /**
       * @example call
       * @enum {string}
       */
      record_type: 'call';
      /**
       * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call
       * @example 428c31b6-7af4-4bcb-b68e-5013ef9657c1
       */
      call_session_id: string;
      /**
       * @description ID that is unique to the call and can be used to correlate webhook events
       * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
       */
      call_leg_id: string;
      /**
       * @description Unique identifier and token for controlling the call.
       * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
       */
      call_control_id: string;
      /**
       * @description Indicates whether the call is alive or not. For Dial command it will always be `false` (dialing is asynchronous).
       * @example true
       */
      is_alive: boolean;
      /**
       * @description State received from a command.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Indicates the duration of the call in seconds
       * @example 50
       */
      call_duration?: number;
    };
    /**
     * Call AI Gather Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.ai_gather.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "status": "valid",
     *         "message_history": [
     *           {
     *             "content": "Hello, can you tell me your age and where you live?",
     *             "role": "assistant"
     *           },
     *           {
     *             "content": "Hello, I'm 29 and I live in Paris?",
     *             "role": "user"
     *           }
     *         ],
     *         "result": {
     *           "age": 29,
     *           "city": "Paris"
     *         }
     *       }
     *     }
     */
    CallAIGatherEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.ai_gather.ended
       * @enum {string}
       */
      event_type?: 'call.ai_gather.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQ
         */
        call_control_id?: string;
        /**
         * @description Telnyx connection ID used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /** @description The history of the messages exchanged during the AI gather */
        message_history?: {
          /**
           * @description The content of the message
           * @example Hello, I'm 29 and I live in Paris.
           */
          content?: string;
          /**
           * @description The role of the message sender
           * @example user
           * @enum {string}
           */
          role?: 'assistant' | 'user';
        }[];
        /**
         * @description The result of the AI gather, its type depends of the `parameters` provided in the command
         * @example {
         *       "age": 29,
         *       "city": "Paris"
         *     }
         */
        result?: Record<string, never>;
        /**
         * @description Reflects how command ended.
         * @example valid
         * @enum {string}
         */
        status?: 'valid' | 'invalid';
      };
    };
    /** Call AI Gather Ended Event */
    CallAIGatherEndedEvent: {
      data?: components['schemas']['CallAIGatherEnded'];
    };
    /**
     * Call Answered
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.answered",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "start_time": "2018-02-02T22:25:27.521992Z",
     *         "state": "answered"
     *       }
     *     }
     */
    CallAnswered: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.answered
       * @enum {string}
       */
      event_type?: 'call.answered';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Custom headers set on answer command
         * @example [
         *       {
         *         "name": "head_1",
         *         "value": "val_1"
         *       },
         *       {
         *         "name": "head_2",
         *         "value": "val_2"
         *       }
         *     ]
         */
        custom_headers?: components['schemas']['CustomSipHeader'][];
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the call started.
         * @example 2018-02-02T22:20:27.521992Z
         */
        start_time?: string;
        /**
         * @description State received from a command.
         * @example answered
         * @enum {string}
         */
        state?: 'answered';
      };
    };
    /** Call Answered Event */
    CallAnsweredEvent: {
      data?: components['schemas']['CallAnswered'];
    };
    /**
     * Call Bridged
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.bridged",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "state": "bridged"
     *       }
     *     }
     */
    CallBridged: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.bridged
       * @enum {string}
       */
      event_type?: 'call.bridged';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description State received from a command.
         * @example bridged
         * @enum {string}
         */
        state?: 'bridged';
      };
    };
    /** Call Bridged Event */
    CallBridgedEvent: {
      data?: components['schemas']['CallBridged'];
    };
    /**
     * Call Control Application
     * @example {
     *       "active": false,
     *       "anchorsite_override": "\"Latency\"",
     *       "application_name": "call-router",
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "dtmf_type": "Inband",
     *       "first_command_timeout": true,
     *       "first_command_timeout_secs": 10,
     *       "id": "1293384261075731499",
     *       "inbound": {
     *         "channel_limit": 10,
     *         "shaken_stir_enabled": true,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       },
     *       "record_type": "call_control_application",
     *       "updated_at": "2018-02-02T22:25:27.521Z",
     *       "webhook_api_version": "1",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_timeout_secs": 25
     *     }
     */
    CallControlApplication: {
      /**
       * @description Specifies whether the connection can be used.
       * @default true
       */
      active: boolean;
      /**
       * @description `Latency` directs Telnyx to route media through the site with the lowest round-trip time to the user's connection. Telnyx calculates this time using ICMP ping messages. This can be disabled by specifying a site to handle all media.
       *
       * @default "Latency"
       * @example "Amsterdam, Netherlands"
       * @enum {string}
       */
      anchorsite_override:
        | '"Latency"'
        | '"Chicago, IL"'
        | '"Ashburn, VA"'
        | '"San Jose, CA"';
      /**
       * @description A user-assigned name to help manage the application.
       * @example call-router
       */
      application_name?: string;
      /**
       * @description ISO 8601 formatted date of when the resource was created
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description Sets the type of DTMF digits sent from Telnyx to this Connection. Note that DTMF digits sent to Telnyx will be accepted in all formats.
       * @default RFC 2833
       * @example Inband
       * @enum {string}
       */
      dtmf_type: 'RFC 2833' | 'Inband' | 'SIP INFO';
      /**
       * @description Specifies whether calls to phone numbers associated with this connection should hangup after timing out.
       * @default false
       * @example true
       */
      first_command_timeout: boolean;
      /**
       * @description Specifies how many seconds to wait before timing out a dial command.
       * @default 30
       * @example 10
       */
      first_command_timeout_secs: number;
      /**
       * Format: int64
       * @example 1293384261075731499
       */
      id?: string;
      inbound?: components['schemas']['CallControlApplicationInbound'];
      outbound?: components['schemas']['CallControlApplicationOutbound'];
      /**
       * @default call_control_application
       * @enum {string}
       */
      record_type: 'call_control_application';
      /**
       * @description ISO 8601 formatted date of when the resource was last updated
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as `https`.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as `https`.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
    };
    /** Call Control Application Inbound */
    CallControlApplicationInbound: {
      /**
       * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
       * @default null
       * @example 10
       */
      channel_limit: number;
      /**
       * @description When enabled Telnyx will include Shaken/Stir data in the Webhook for new inbound calls.
       * @default false
       * @example false
       */
      shaken_stir_enabled: boolean;
      /**
       * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
       * @default null
       * @example example
       */
      sip_subdomain: string;
      /**
       * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
       * @default from_anyone
       * @example only_my_connections
       * @enum {string}
       */
      sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
    };
    /** Call Control Application Outbound */
    CallControlApplicationOutbound: {
      /**
       * @description When set, this will limit the total number of outbound calls to phone numbers associated with this connection.
       * @default null
       * @example 10
       */
      channel_limit: number;
      /**
       * Format: int64
       * @description Identifies the associated outbound voice profile.
       * @example 1293384261075731499
       */
      outbound_voice_profile_id?: string;
    };
    /**
     * Call Control Command Result
     * @example {
     *       "result": "ok"
     *     }
     */
    CallControlCommandResult: {
      /** @example ok */
      result?: string;
    };
    /** @example v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA */
    CallControlId: string;
    /** Call Cost Received Event */
    CallCost: {
      /**
       * @description Identifies the type of resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of the event being delivered
       * @example call.cost
       * @enum {string}
       */
      event_type?: 'call.cost';
      /**
       * Format: uuid
       * @description Uniquely identifies a webhook
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      meta?: {
        meta?: {
          /**
           * @description The number of attempts made to deliver the webhook
           * @example 1
           */
          attempt?: number;
          /**
           * @description The URL where webhook was sent
           * @example https://example.com
           */
          delivered_to?: string;
        };
      };
      payload?: {
        /**
         * @description The number of seconds for which this call will be billed
         * @example 0
         */
        billed_duration_secs?: number;
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Identifies the type of resource.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        cost_parts?: {
          /**
           * @description The number of seconds for which this item will be billed
           * @example 0
           */
          billed_duration_secs?: number;
          /**
           * @description The service incurring a charge
           * @example call-control
           */
          call_part?: string;
          /**
           * @description The billed cost of the item, in currency shown in the `currency` field
           * @example 0
           */
          cost?: number;
          /**
           * @description The currency in which `cost` is measured
           * @example USD
           */
          currency?: string;
          /**
           * @description The cost per unit of the item incurring a charge
           * @example 0.001
           */
          rate?: number;
        }[];
        /**
         * @description The billed cost of the call
         * @example 0
         */
        total_cost?: number;
        /**
         * @description Reflects how command ended.
         * @example valid
         * @enum {string}
         */
        status?:
          | 'valid'
          | 'invalid'
          | 'call_hangup'
          | 'cancelled'
          | 'cancelled_amd';
      };
    };
    /**
     * Call DTMF Received
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.dtmf.received",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "digit": "#"
     *       }
     *     }
     */
    CallDtmfReceived: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.dtmf.received
       * @enum {string}
       */
      event_type?: 'call.dtmf.received';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Identifies the type of resource.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description The received DTMF digit or symbol.
         * @example #
         */
        digit?: string;
      };
    };
    /** Call DTMF Received Event */
    CallDtmfReceivedEvent: {
      data?: components['schemas']['CallDtmfReceived'];
    };
    /**
     * Call Enqueued
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.enqueued",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "queue": "support",
     *         "current_position": 5
     *       }
     *     }
     */
    CallEnqueued: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.enqueued
       * @enum {string}
       */
      event_type?: 'call.enqueued';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description The name of the queue
         * @example support
         */
        queue?: string;
        /**
         * @description Current position of the call in the queue.
         * @example 7
         */
        current_position?: number;
      };
    };
    /** Call Enqueued Event */
    CallEnqueuedEvent: {
      data?: components['schemas']['CallEnqueued'];
    };
    /**
     * Call Event
     * @example {
     *       "record_type": "call_event",
     *       "call_leg_id": "308fe500-5213-11e9-ace7-02420a0f0668",
     *       "call_session_id": "308fec30-5213-11e9-9d3f-02420a0f0668",
     *       "event_timestamp": "2019-03-29T11:10:19.127783Z",
     *       "name": "call.hangup",
     *       "type": "webhook",
     *       "metadata": {}
     *     }
     */
    CallEvent: {
      /**
       * @example call_event
       * @enum {string}
       */
      record_type: 'call_event';
      /**
       * @description Uniquely identifies an individual call leg.
       * @example 308fe500-5213-11e9-ace7-02420a0f0668
       */
      call_leg_id: string;
      /**
       * @description Uniquely identifies the call control session. A session may include multiple call leg events.
       * @example 308fec30-5213-11e9-9d3f-02420a0f0668
       */
      call_session_id: string;
      /**
       * @description Event timestamp
       * @example 2019-03-29T11:10:19.127783Z
       */
      event_timestamp: string;
      /**
       * @description Event name
       * @example call.hangup
       */
      name: string;
      /**
       * @description Event type
       * @example webhook
       * @enum {string}
       */
      type: 'command' | 'webhook';
      /** @description Event metadata, which includes raw event, and extra information based on event type */
      metadata: Record<string, never>;
    };
    /**
     * Call Fork Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.fork.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_control_id": "v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "stream_type": "decrypted"
     *       }
     *     }
     */
    CallForkStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.fork.started
       * @enum {string}
       */
      event_type?: 'call.fork.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description Unique ID for controlling the call.
         * @example v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Type of media streamed. It can be either 'raw' or 'decrypted'.
         * @example raw
         * @enum {string}
         */
        stream_type?: 'raw' | 'decrypted';
      };
    };
    /** Call Fork Started Event */
    CallForkStartedEvent: {
      data?: components['schemas']['CallForkStarted'];
    };
    /**
     * Call Fork Stopped
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.fork.stopped",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_control_id": "v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "stream_type": "decrypted"
     *       }
     *     }
     */
    CallForkStopped: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.fork.stopped
       * @enum {string}
       */
      event_type?: 'call.fork.stopped';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description Unique ID for controlling the call.
         * @example v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Type of media streamed. It can be either 'raw' or 'decrypted'.
         * @example raw
         * @enum {string}
         */
        stream_type?: 'raw' | 'decrypted';
      };
    };
    /** Call Fork Stopped Event */
    CallForkStoppedEvent: {
      data?: components['schemas']['CallForkStopped'];
    };
    /**
     * @description The call forwarding settings for a phone number.
     * @example {
     *       "call_forwarding_enabled": true,
     *       "forwards_to": "+13035559123",
     *       "forwarding_type": "always"
     *     }
     */
    CallForwarding: {
      /**
       * @description Indicates if call forwarding will be enabled for this number if forwards_to and forwarding_type are filled in. Defaults to true for backwards compatibility with APIV1 use of numbers endpoints.
       * @default true
       * @example true
       */
      call_forwarding_enabled: boolean;
      /** @description The phone number to which inbound calls to this number are forwarded. Inbound calls will not be forwarded if this field is left blank. If set, must be a +E.164-formatted phone number. */
      forwards_to?: string;
      /**
       * @description Call forwarding type. 'forwards_to' must be set for this to have an effect.
       * @example always
       * @enum {string}
       */
      forwarding_type?: 'always' | 'on_failure';
    };
    /**
     * Call Gather Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.gather.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "digits": "123",
     *         "status": "valid"
     *       }
     *     }
     */
    CallGatherEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.gather.ended
       * @enum {string}
       */
      event_type?: 'call.gather.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description The received DTMF digit or symbol.
         * @example 5503
         */
        digits?: string;
        /**
         * @description Reflects how command ended.
         * @example valid
         * @enum {string}
         */
        status?:
          | 'valid'
          | 'invalid'
          | 'call_hangup'
          | 'cancelled'
          | 'cancelled_amd'
          | 'timeout';
      };
    };
    /** Call Gather Ended Event */
    CallGatherEndedEvent: {
      data?: components['schemas']['CallGatherEnded'];
    };
    /**
     * Call Hangup
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.hangup",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "start_time": "2018-02-02T22:20:27.521992Z",
     *         "state": "hangup",
     *         "hangup_cause": "call_rejected",
     *         "hangup_source": "caller",
     *         "sip_hangup_cause": "603"
     *       }
     *     }
     */
    CallHangup: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.hangup
       * @enum {string}
       */
      event_type?: 'call.hangup';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the call started.
         * @example 2018-02-02T22:20:27.521992Z
         */
        start_time?: string;
        /**
         * @description State received from a command.
         * @example hangup
         * @enum {string}
         */
        state?: 'hangup';
        /**
         * @description The reason the call was ended (`call_rejected`, `normal_clearing`, `originator_cancel`, `timeout`, `time_limit`, `user_busy`, `not_found` or `unspecified`).
         * @example call_rejected
         * @enum {string}
         */
        hangup_cause?:
          | 'call_rejected'
          | 'normal_clearing'
          | 'originator_cancel'
          | 'timeout'
          | 'time_limit'
          | 'user_busy'
          | 'not_found'
          | 'unspecified';
        /**
         * @description The party who ended the call (`callee`, `caller`, `unknown`).
         * @example caller
         * @enum {string}
         */
        hangup_source?: 'caller' | 'callee' | 'unknown';
        /**
         * @description The reason the call was ended (SIP response code). If the SIP response is unavailable (in inbound calls for example) this is set to `unspecified`.
         * @example 603
         */
        sip_hangup_cause?: string;
      };
    };
    /** Call Hangup Event */
    CallHangupEvent: {
      data?: components['schemas']['CallHangup'];
    };
    /**
     * Call Initiated
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.initiated",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "direction": "incoming",
     *         "state": "parked"
     *       }
     *     }
     */
    CallInitiated: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.initiated
       * @enum {string}
       */
      event_type?: 'call.initiated';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description Custom headers from sip invite
         * @example [
         *       {
         *         "name": "head_1",
         *         "value": "val_1"
         *       },
         *       {
         *         "name": "head_2",
         *         "value": "val_2"
         *       }
         *     ]
         */
        custom_headers?: components['schemas']['CustomSipHeader'][];
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description Whether the call is `incoming` or `outgoing`.
         * @example incoming
         * @enum {string}
         */
        direction?: 'incoming' | 'outgoing';
        /**
         * @description State received from a command.
         * @example parked
         * @enum {string}
         */
        state?: 'parked' | 'bridging';
      };
    };
    /** Call Initiated Event */
    CallInitiatedEvent: {
      data?: components['schemas']['CallInitiated'];
    };
    /**
     * Call Left Queue
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.dequeued",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "queue": "support",
     *         "queue_position": 3,
     *         "reason": "leave"
     *       }
     *     }
     */
    CallLeftQueue: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.dequeued
       * @enum {string}
       */
      event_type?: 'call.dequeued';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description The name of the queue
         * @example support
         */
        queue?: string;
        /**
         * @description Last position of the call in the queue.
         * @example 7
         */
        queue_position?: number;
        /**
         * @description The reason for leaving the queue
         * @example bridged
         * @enum {string}
         */
        reason?:
          | 'bridged'
          | 'bridging-in-process'
          | 'hangup'
          | 'leave'
          | 'timeout';
      };
    };
    /** Call Left Queue Event */
    CallLeftQueueEvent: {
      data?: components['schemas']['CallLeftQueue'];
    };
    /**
     * Call Machine Detection Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.machine.detection.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "result": "human"
     *       }
     *     }
     */
    CallMachineDetectionEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.machine.detection.ended
       * @enum {string}
       */
      event_type?: 'call.machine.detection.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description Answering machine detection result.
         * @example machine
         * @enum {string}
         */
        result?: 'human' | 'machine' | 'not_sure';
      };
    };
    /** Call Machine Detection Ended Event */
    CallMachineDetectionEndedEvent: {
      data?: components['schemas']['CallMachineDetectionEnded'];
    };
    /**
     * Call Machine Greeting Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.machine.greeting.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "result": "ended"
     *       }
     *     }
     */
    CallMachineGreetingEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.machine.greeting.ended
       * @enum {string}
       */
      event_type?: 'call.machine.greeting.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description Answering machine greeting ended result.
         * @example ended
         * @enum {string}
         */
        result?: 'ended' | 'not_sure';
      };
    };
    /** Call Machine Greeting Ended Event */
    CallMachineGreetingEndedEvent: {
      data?: components['schemas']['CallMachineGreetingEnded'];
    };
    /**
     * Call Machine Premium Detection Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.machine.premium.detection.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "result": "machine"
     *       }
     *     }
     */
    CallMachinePremiumDetectionEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.machine.premium.detection.ended
       * @enum {string}
       */
      event_type?: 'call.machine.premium.detection.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description Premium Answering Machine Detection result.
         * @example machine
         * @enum {string}
         */
        result?:
          | 'human_residence'
          | 'human_business'
          | 'machine'
          | 'silence'
          | 'fax_detected';
      };
    };
    /** Call Machine Premium Detection Ended Event */
    CallMachinePremiumDetectionEndedEvent: {
      data?: components['schemas']['CallMachinePremiumDetectionEnded'];
    };
    /**
     * Call Machine Premium Greeting Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.machine.premium.greeting.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "from": "+35319605860",
     *         "to": "+35319605860",
     *         "result": "beep_detected"
     *       }
     *     }
     */
    CallMachinePremiumGreetingEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.machine.premium.greeting.ended
       * @enum {string}
       */
      event_type?: 'call.machine.premium.greeting.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
        /**
         * @description Premium Answering Machine Greeting Ended result.
         * @example beep_detected
         * @enum {string}
         */
        result?: 'beep_detected';
      };
    };
    /** Call Machine Premium Greeting Ended Event */
    CallMachinePremiumGreetingEndedEvent: {
      data?: components['schemas']['CallMachinePremiumGreetingEnded'];
    };
    /**
     * Call Playback Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.playback.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "media_name": "my_media_uploaded_to_media_storage_api",
     *         "overlay": false,
     *         "status": "completed"
     *       }
     *     }
     */
    CallPlaybackEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.playback.ended
       * @enum {string}
       */
      event_type?: 'call.playback.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description The audio URL being played back, if audio_url has been used to start.
         * @example http://example.com/audio.wav
         */
        media_url?: string;
        /**
         * @description The name of the audio media file being played back, if media_name has been used to start.
         * @example my_media_uploaded_to_media_storage_api
         */
        media_name?: string;
        /**
         * @description Whether the stopped audio was in overlay mode or not.
         * @example false
         */
        overlay?: boolean;
        /**
         * @description Reflects how command ended.
         * @example completed
         * @enum {string}
         */
        status?:
          | 'file_not_found'
          | 'call_hangup'
          | 'unknown'
          | 'failed'
          | 'cancelled_amd'
          | 'completed'
          | 'failed';
      };
    };
    /** Call Playback Ended Event */
    CallPlaybackEndedEvent: {
      data?: components['schemas']['CallPlaybackEnded'];
    };
    /**
     * Call Playback Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.playback.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "media_url": "http://example.com/audio.wav",
     *         "overlay": false
     *       }
     *     }
     */
    CallPlaybackStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.playback.started
       * @enum {string}
       */
      event_type?: 'call.playback.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description The audio URL being played back, if audio_url has been used to start.
         * @example http://example.com/audio.wav
         */
        media_url?: string;
        /**
         * @description The name of the audio media file being played back, if media_name has been used to start.
         * @example my_media_uploaded_to_media_storage_api
         */
        media_name?: string;
        /**
         * @description Whether the audio is going to be played in overlay mode or not.
         * @example false
         */
        overlay?: boolean;
      };
    };
    /** Call Playback Started Event */
    CallPlaybackStartedEvent: {
      data?: components['schemas']['CallPlaybackStarted'];
    };
    /**
     * @description The call recording settings for a phone number.
     * @example {
     *       "inbound_call_recording_enabled": true,
     *       "inbound_call_recording_format": "wav",
     *       "inbound_call_recording_channels": "single"
     *     }
     */
    CallRecording: {
      /**
       * @description When enabled, any inbound call to this number will be recorded.
       * @default false
       */
      inbound_call_recording_enabled: boolean;
      /**
       * @description The audio file format for calls being recorded.
       * @default wav
       * @enum {string}
       */
      inbound_call_recording_format: 'wav' | 'mp3';
      /**
       * @description When using 'dual' channels, final audio file will be stereo recorded with the first leg on channel A, and the rest on channel B.
       * @default single
       * @enum {string}
       */
      inbound_call_recording_channels: 'single' | 'dual';
    };
    /**
     * Call Recording Saved
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.recording.saved",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "recording_started_at": "2018-02-02T22:20:27.521992Z",
     *         "recording_ended_at": "2018-02-02T22:20:27.521992Z",
     *         "channels": "single",
     *         "recording_urls": {
     *           "mp3": "http://example.com/recording.mp3",
     *           "wav": "http://example.com/recording.wav"
     *         },
     *         "public_recording_urls": {
     *           "mp3": "http://example.com/recording.mp3",
     *           "wav": "http://example.com/recording.wav"
     *         }
     *       }
     *     }
     */
    CallRecordingSaved: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.recording.saved
       * @enum {string}
       */
      event_type?: 'call.recording.saved';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when recording started.
         * @example 2018-02-02T22:20:27.521992Z
         */
        recording_started_at?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when recording ended.
         * @example 2018-02-02T22:25:27.521992Z
         */
        recording_ended_at?: string;
        /**
         * @description Whether recording was recorded in `single` or `dual` channel.
         * @example single
         * @enum {string}
         */
        channels?: 'single' | 'dual';
        /** @description Recording URLs in requested format. These URLs are valid for 10 minutes. After 10 minutes, you may retrieve recordings via API using Reports -> Call Recordings documentation, or via Mission Control under Reporting -> Recordings. */
        recording_urls?: {
          /**
           * @description Recording URL in requested `mp3` format.
           * @example http://example.com/recording.mp3
           */
          mp3?: string | null;
          /**
           * @description Recording URL in requested `wav` format.
           * @example http://example.com/recording.wav
           */
          wav?: string | null;
        };
        /** @description Recording URLs in requested format. The URL is valid for as long as the file exists. For security purposes, this feature is activated on a per request basis.  Please contact customer support with your Account ID to request activation. */
        public_recording_urls?: {
          /**
           * @description Recording URL in requested `mp3` format.
           * @example http://example.com/recording.mp3
           */
          mp3?: string | null;
          /**
           * @description Recording URL in requested `wav` format.
           * @example http://example.com/recording.wav
           */
          wav?: string | null;
        };
      };
    };
    /** Call Recording Saved Event */
    CallRecordingSavedEvent: {
      data?: components['schemas']['CallRecordingSaved'];
    };
    /** @example {
     *       "record_type": "event",
     *       "event_type": "call.refer.completed",
     *       "id": "4ce4366d-8d87-44be-a00b-942154e9c5f5",
     *       "occurred_at": "2020-03-30T13:29:44.650000Z",
     *       "payload": {
     *         "call_control_id": "v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA",
     *         "call_leg_id": "817f7de8-728a-11ea-9ce6-02420a0f8969",
     *         "call_session_id": "817f8c2a-728a-11ea-9cbe-02420a0f8969",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "connection_id": "1289082222292239760",
     *         "from": "+35319605860",
     *         "sip_notify_response": 200,
     *         "to": "+13129457420"
     *       }
     *     } */
    CallReferCompleted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.refer.completed
       * @enum {string}
       */
      event_type?: 'call.refer.completed';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Unique ID for controlling the call.
         * @example v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description SIP NOTIFY event status for tracking the REFER attempt.
         * @example 200
         */
        sip_notify_response?: number;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
      };
    };
    /** Call Refer Completed Event */
    CallReferCompletedEvent: {
      data?: components['schemas']['CallReferCompleted'];
    };
    /** @example {
     *       "record_type": "event",
     *       "event_type": "call.refer.failed",
     *       "id": "fbeb70e0-54eb-4e26-8d19-56b43e66f754",
     *       "occurred_at": "2020-03-30T13:29:42.130013Z",
     *       "payload": {
     *         "call_control_id": "v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA",
     *         "call_leg_id": "817f7de8-728a-11ea-9ce6-02420a0f8969",
     *         "call_session_id": "817f8c2a-728a-11ea-9cbe-02420a0f8969",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "connection_id": "1289082222292239760",
     *         "from": "+35319605860",
     *         "sip_notify_response": 603,
     *         "to": "+13129457420"
     *       }
     *     } */
    CallReferFailed: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.refer.failed
       * @enum {string}
       */
      event_type?: 'call.refer.failed';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Unique ID for controlling the call.
         * @example v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description SIP NOTIFY event status for tracking the REFER attempt.
         * @example 603
         */
        sip_notify_response?: number;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
      };
    };
    /** Call Refer Failed Event */
    CallReferFailedEvent: {
      data?: components['schemas']['CallReferFailed'];
    };
    /**
     * Call Refer Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.refer.started",
     *       "id": "fbeb70e0-54eb-4e26-8d19-56b43e66f754",
     *       "occurred_at": "2020-03-30T13:29:42.130013Z",
     *       "payload": {
     *         "call_control_id": "v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA",
     *         "call_leg_id": "817f7de8-728a-11ea-9ce6-02420a0f8969",
     *         "call_session_id": "817f8c2a-728a-11ea-9cbe-02420a0f8969",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "connection_id": "1289082222292239760",
     *         "from": "+35319605860",
     *         "sip_notify_response": 100,
     *         "to": "+13129457420"
     *       }
     *     }
     */
    CallReferStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.refer.started
       * @enum {string}
       */
      event_type?: 'call.refer.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Unique ID for controlling the call.
         * @example v2:OycMASgvIjsGIAVEx8x3n9rYeKnUJx6a3V8VGhs5futnr17KZhujZA
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Number or SIP URI placing the call.
         * @example +35319605860
         */
        from?: string;
        /**
         * @description SIP NOTIFY event status for tracking the REFER attempt.
         * @example 100
         */
        sip_notify_response?: number;
        /**
         * @description Destination number or SIP URI of the call.
         * @example +13129457420
         */
        to?: string;
      };
    };
    /** Call Refer Started Event */
    CallReferStartedEvent: {
      data?: components['schemas']['CallReferStarted'];
    };
    /**
     * Dial Request
     * @example {
     *       "to": "+18005550100 or sip:username@sip.telnyx.com",
     *       "from": "+18005550101",
     *       "from_display_name": "Company Name",
     *       "connection_id": "7267xxxxxxxxxxxxxx",
     *       "conference_config": {
     *         "conference_name": "telnyx-conference",
     *         "start_conference_on_enter": true
     *       },
     *       "audio_url": "http://www.example.com/sounds/greeting.wav",
     *       "timeout_secs": 60,
     *       "timeout_limit_secs": 60,
     *       "webhook_url": "https://www.example.com/server-b/",
     *       "webhook_url_method": "POST",
     *       "answering_machine_detection": "detect",
     *       "answering_machine_detection_config": {
     *         "total_analysis_time_millis": 5000,
     *         "after_greeting_silence_millis": 1000,
     *         "between_words_silence_millis": 1000,
     *         "greeting_duration_millis": 1000,
     *         "initial_silence_millis": 1000,
     *         "maximum_number_of_words": 1000,
     *         "maximum_word_length_millis": 2000,
     *         "silence_threshold": 512,
     *         "greeting_total_analysis_time_millis": 50000,
     *         "greeting_silence_duration_millis": 2000
     *       },
     *       "custom_headers": [
     *         {
     *           "name": "head_1",
     *           "value": "val_1"
     *         },
     *         {
     *           "name": "head_2",
     *           "value": "val_2"
     *         }
     *       ],
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "link_to": "ilditnZK_eVysupV21KzmzN_sM29ygfauQojpm4BgFtfX5hXAcjotg==",
     *       "media_encryption": "SRTP",
     *       "sip_auth_username": "username",
     *       "sip_auth_password": "password",
     *       "sip_headers": [
     *         {
     *           "name": "User-to-User",
     *           "value": "12345"
     *         }
     *       ],
     *       "sip_transport_protocol": "TLS",
     *       "stream_url": "wss://www.example.com/websocket",
     *       "stream_track": "both_tracks",
     *       "send_silence_when_idle": true,
     *       "enable_dialogflow": false,
     *       "dialogflow_config": {
     *         "analyze_sentiment": false,
     *         "partial_automated_agent_reply": false
     *       }
     *     }
     */
    CallRequest: {
      /** @description The DID or SIP URI to dial out to. Multiple DID or SIP URIs can be provided using an array of strings */
      to: string | string[];
      /**
       * @description The `from` number to be used as the caller id presented to the destination (`to` number). The number should be in +E164 format.
       * @example +18005550101
       */
      from: string;
      /**
       * @description The `from_display_name` string to be used as the caller id name (SIP From Display Name) presented to the destination (`to` number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and -_~!.+ special characters. If ommited, the display name will be the same as the number in the `from` field.
       * @example Company Name
       */
      from_display_name?: string;
      /** @description The ID of the Call Control App (formerly ID of the connection) to be used when dialing the destination. */
      connection_id: string;
      /**
       * @description The URL of a file to be played back to the callee when the call is answered. The URL can point to either a WAV or MP3 file. media_name and audio_url cannot be used together in one request.
       * @example http://example.com/message.wav
       */
      audio_url?: string;
      /**
       * @description The media_name of a file to be played back to the callee when the call is answered. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      media_name?: string;
      /**
       * @description The list of comma-separated codecs in a preferred order for the forked media to be received.
       * @example G722,PCMU,PCMA,G729,OPUS,VP8,H264
       */
      preferred_codecs?: string;
      /**
       * Format: int32
       * @description The number of seconds that Telnyx will wait for the call to be answered by the destination to which it is being called. If the timeout is reached before an answer is received, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `timeout` will be sent. Minimum value is 5 seconds. Maximum value is 120 seconds.
       * @default 30
       * @example 60
       */
      timeout_secs: number;
      /**
       * Format: int32
       * @description Sets the maximum duration of a Call Control Leg in seconds. If the time limit is reached, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `time_limit` will be sent. For example, by setting a time limit of 120 seconds, a Call Leg will be automatically terminated two minutes after being answered. The default time limit is 14400 seconds or 4 hours and this is also the maximum allowed call length.
       * @default 14400
       * @example 600
       */
      time_limit_secs: number;
      /**
       * @description Enables Answering Machine Detection. Telnyx offers Premium and Standard detections. With Premium detection, when a call is answered, Telnyx runs real-time detection and sends a `call.machine.premium.detection.ended` webhook with one of the following results: `human_residence`, `human_business`, `machine`, `silence` or `fax_detected`. If we detect a beep, we also send a `call.machine.premium.greeting.ended` webhook with the result of `beep_detected`. If we detect a beep before `call.machine.premium.detection.ended` we only send `call.machine.premium.greeting.ended`, and if we detect a beep after `call.machine.premium.detection.ended`, we send both webhooks. With Standard detection, when a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an `call.machine.detection.ended` webhook with the analysis result. If `greeting_end` or `detect_words` is used and a `machine` is detected, you will receive another `call.machine.greeting.ended` webhook when the answering machine greeting ends with a beep or silence. If `detect_beep` is used, you will only receive `call.machine.greeting.ended` if a beep is detected.
       * @default disabled
       * @enum {string}
       */
      answering_machine_detection:
        | 'premium'
        | 'detect'
        | 'detect_beep'
        | 'detect_words'
        | 'greeting_end'
        | 'disabled';
      /** @description Optional configuration parameters to modify 'answering_machine_detection' performance. */
      answering_machine_detection_config?: {
        /**
         * Format: int32
         * @description Maximum timeout threshold for overall detection.
         * @default 3500
         * @example 5000
         */
        total_analysis_time_millis: number;
        /**
         * Format: int32
         * @description Silence duration threshold after a greeting message or voice for it be considered human.
         * @default 800
         * @example 1000
         */
        after_greeting_silence_millis: number;
        /**
         * Format: int32
         * @description Maximum threshold for silence between words.
         * @default 50
         * @example 100
         */
        between_words_silence_millis: number;
        /**
         * Format: int32
         * @description Maximum threshold of a human greeting. If greeting longer than this value, considered machine.
         * @default 3500
         * @example 1500
         */
        greeting_duration_millis: number;
        /**
         * Format: int32
         * @description If initial silence duration is greater than this value, consider it a machine.
         * @default 3500
         * @example 1800
         */
        initial_silence_millis: number;
        /**
         * Format: int32
         * @description If number of detected words is greater than this value, consder it a machine.
         * @default 5
         * @example 3
         */
        maximum_number_of_words: number;
        /**
         * Format: int32
         * @description If a single word lasts longer than this threshold, consider it a machine.
         * @default 3500
         * @example 2000
         */
        maximum_word_length_millis: number;
        /**
         * Format: int32
         * @description Minimum noise threshold for any analysis.
         * @default 256
         * @example 512
         */
        silence_threshold: number;
        /**
         * Format: int32
         * @description If machine already detected, maximum timeout threshold to determine the end of the machine greeting.
         * @default 5000
         * @example 7500
         */
        greeting_total_analysis_time_millis: number;
        /**
         * Format: int32
         * @description If machine already detected, maximum threshold for silence between words. If exceeded, the greeting is considered ended.
         * @default 1500
         * @example 2000
         */
        greeting_silence_duration_millis: number;
      };
      /** @description Optional configuration parameters to dial new participant into a conference. */
      conference_config?: {
        /**
         * Format: uuid
         * @description Conference ID to be joined
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        id?: string;
        /**
         * @description Conference name to be joined
         * @example telnyx-conference
         */
        conference_name?: string;
        /**
         * @description Whether the conference should end and all remaining participants be hung up after the participant leaves the conference. Defaults to "false".
         * @example true
         */
        end_conference_on_exit?: boolean;
        /**
         * @description Whether the conference should end after the participant leaves the conference. NOTE this doesn't hang up the other participants. Defaults to "false".
         * @example true
         */
        soft_end_conference_on_exit?: boolean;
        /**
         * @description Whether the participant should be put on hold immediately after joining the conference. Defaults to "false".
         * @example true
         */
        hold?: boolean;
        /**
         * @description The URL of a file to be played to the participant when they are put on hold after joining the conference. hold_media_name and hold_audio_url cannot be used together in one request. Takes effect only when "start_conference_on_create" is set to "false". This property takes effect only if "hold" is set to "true".
         * @example http://example.com/message.wav
         */
        hold_audio_url?: string;
        /**
         * @description The media_name of a file to be played to the participant when they are put on hold after joining the conference. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file. Takes effect only when "start_conference_on_create" is set to "false". This property takes effect only if "hold" is set to "true".
         * @example my_media_uploaded_to_media_storage_api
         */
        hold_media_name?: string;
        /**
         * @description Whether the participant should be muted immediately after joining the conference. Defaults to "false".
         * @example true
         */
        mute?: boolean;
        /**
         * @description Whether the conference should be started after the participant joins the conference. Defaults to "false".
         * @example true
         */
        start_conference_on_enter?: boolean;
        /**
         * @description Whether the conference should be started on creation. If the conference isn't started all participants that join are automatically put on hold. Defaults to "true".
         * @example false
         */
        start_conference_on_create?: boolean;
        /**
         * @description Sets the joining participant as a supervisor for the conference. A conference can have multiple supervisors. "barge" means the supervisor enters the conference as a normal participant. This is the same as "none". "monitor" means the supervisor is muted but can hear all participants. "whisper" means that only the specified "whisper_call_control_ids" can hear the supervisor. Defaults to "none".
         * @example whisper
         * @enum {string}
         */
        supervisor_role?: 'barge' | 'monitor' | 'none' | 'whisper';
        /**
         * @description Array of unique call_control_ids the joining supervisor can whisper to. If none provided, the supervisor will join the conference as a monitoring participant only.
         * @example [
         *       "v2:Sg1xxxQ_U3ixxxyXT_VDNI3xxxazZdg6Vxxxs4-GNYxxxVaJPOhFMRQ",
         *       "v2:qqpb0mmvd-ovhhBr0BUQQn0fld5jIboaaX3-De0DkqXHzbf8d75xkw"
         *     ]
         */
        whisper_call_control_ids?: string[];
        /**
         * @description Whether a beep sound should be played when the participant joins and/or leaves the conference. Can be used to override the conference-level setting.
         * @example on_exit
         * @enum {string}
         */
        beep_enabled?: 'always' | 'never' | 'on_enter' | 'on_exit';
      };
      /**
       * @description Custom headers to be added to the SIP INVITE.
       * @example [
       *       {
       *         "name": "head_1",
       *         "value": "val_1"
       *       },
       *       {
       *         "name": "head_2",
       *         "value": "val_2"
       *       }
       *     ]
       */
      custom_headers?: components['schemas']['CustomSipHeader'][];
      /**
       * Format: uuid
       * @description Use this field to set the Billing Group ID for the call. Must be a valid and existing Billing Group ID.
       * @example f5586561-8ff0-4291-a0ac-84fe544797bd
       */
      billing_group_id?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore others Dial commands with the same `command_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Use another call's control id for sharing the same call session id
       * @example ilditnZK_eVysupV21KzmzN_sM29ygfauQojpm4BgFtfX5hXAcjotg==
       */
      link_to?: string;
      /**
       * @description Defines whether media should be encrypted on the call.
       * @default disabled
       * @enum {string}
       */
      media_encryption: 'disabled' | 'SRTP';
      /** @description SIP Authentication username used for SIP challenges. */
      sip_auth_username?: string;
      /** @description SIP Authentication password used for SIP challenges. */
      sip_auth_password?: string;
      /**
       * @description SIP headers to be added to the SIP INVITE request. Currently only User-to-User header is supported.
       * @example [
       *       {
       *         "name": "User-to-User",
       *         "value": "value"
       *       }
       *     ]
       */
      sip_headers?: components['schemas']['SipHeader'][];
      /**
       * @description Defines SIP transport protocol to be used on the call.
       * @default UDP
       * @enum {string}
       */
      sip_transport_protocol: 'UDP' | 'TCP' | 'TLS';
      sound_modifications?: components['schemas']['SoundModifications'];
      /**
       * @description The destination WebSocket address where the stream is going to be delivered.
       * @example wss://www.example.com/websocket
       */
      stream_url?: string;
      /**
       * @description Specifies which track should be streamed.
       * @default inbound_track
       * @example both_tracks
       * @enum {string}
       */
      stream_track: 'inbound_track' | 'outbound_track' | 'both_tracks';
      stream_bidirectional_mode?: components['schemas']['StreamBidirectionalMode'];
      stream_bidirectional_codec?: components['schemas']['StreamBidirectionalCodec'];
      /**
       * @description Generate silence RTP packets when no transmission available.
       * @default false
       * @example true
       */
      send_silence_when_idle: boolean;
      /**
       * @description Use this field to override the URL for which Telnyx will send subsequent webhooks to for this call.
       * @example https://www.example.com/server-b/
       */
      webhook_url?: string;
      /**
       * @description HTTP request type used for `webhook_url`.
       * @default POST
       * @example GET
       * @enum {string}
       */
      webhook_url_method: 'POST' | 'GET';
      /**
       * @description Start recording automatically after an event. Disabled by default.
       * @example record-from-answer
       * @enum {string}
       */
      record?: 'record-from-answer';
      /**
       * @description Defines which channel should be recorded ('single' or 'dual') when `record` is specified.
       * @default dual
       * @example single
       * @enum {string}
       */
      record_channels: 'single' | 'dual';
      /**
       * @description Defines the format of the recording ('wav' or 'mp3') when `record` is specified.
       * @default mp3
       * @example wav
       * @enum {string}
       */
      record_format: 'wav' | 'mp3';
      /**
       * Format: int32
       * @description Defines the maximum length for the recording in seconds when `record` is specified. The minimum value is 0. The maximum value is 43200. The default value is 0 (infinite).
       * @default 0
       * @example 1000
       */
      record_max_length: number;
      /**
       * Format: int32
       * @description The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected when `record` is specified. The timer only starts when the speech is detected. Please note that call transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite).
       * @default 0
       * @example 100
       */
      record_timeout_secs: number;
      /**
       * @description When set to `trim-silence`, silence will be removed from the beginning and end of the recording.
       * @example trim-silence
       * @enum {string}
       */
      record_trim?: 'trim-silence';
      /**
       * @description The custom recording file name to be used instead of the default `call_leg_id`. Telnyx will still add a Unix timestamp suffix.
       * @example my_recording_file_name
       */
      record_custom_file_name?: string;
      /**
       * @description Enables Dialogflow for the current call. The default value is false.
       * @default false
       * @example true
       */
      enable_dialogflow: boolean;
      dialogflow_config?: components['schemas']['DialogflowConfig'];
      /**
       * @description Enable transcription upon call answer. The default value is false.
       * @default false
       * @example true
       */
      transcription: boolean;
      transcription_config?: components['schemas']['TranscriptionStartRequest'];
    };
    /**
     * Call resource
     * @example {
     *       "account_sid": "61bf923e-5e4d-4595-a110-56190ea18a1b",
     *       "answered_by": null,
     *       "caller_name": "+13122010094",
     *       "date_created": "Thu, 15 Jun 2023 09:56:45 +0000",
     *       "date_updated": "Thu, 15 Jun 2023 09:56:56 +0000",
     *       "direction": "inbound",
     *       "duration": "11",
     *       "end_time": "Thu, 15 Jun 2023 09:56:56 +0000",
     *       "from": "+13123456789",
     *       "from_formatted": "(312) 345-6789",
     *       "price": null,
     *       "price_unit": null,
     *       "sid": "v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA",
     *       "start_time": "Thu, 15 Jun 2023 09:56:45 +0000",
     *       "status": "completed",
     *       "to": "+13987654321",
     *       "to_formatted": "(398) 765-4321",
     *       "uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls/v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA.json"
     *     }
     */
    CallResource: {
      /**
       * @description The id of the account the resource belongs to.
       * @example 61bf923e-5e4d-4595-a110-56190ea18a1b
       */
      account_sid?: string;
      /**
       * @description The value of the answering machine detection result, if this feature was enabled for the call.
       * @example human
       * @enum {string}
       */
      answered_by?: 'human' | 'machine' | 'not_sure';
      /**
       * @description Caller ID, if present.
       * @example CALLER
       */
      caller_name?: string;
      /**
       * @description The timestamp of when the resource was created.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_created?: string;
      /**
       * @description The timestamp of when the resource was last updated.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_updated?: string;
      /**
       * @description The direction of this call.
       * @example inbound
       * @enum {string}
       */
      direction?: 'inbound' | 'outbound';
      /**
       * @description The duration of this call, given in seconds.
       * @example 12
       */
      duration?: string;
      /**
       * @description The end time of this call.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      end_time?: string;
      /**
       * @description The phone number or SIP address that made this call.
       * @example +13123456789
       */
      from?: string;
      /**
       * @description The from number formatted for display.
       * @example (312) 345-6789
       */
      from_formatted?: string;
      /**
       * @description The price of this call, the currency is specified in the price_unit field. Only populated when the call cost feature is enabled for the account.
       * @example 0.10
       */
      price?: string;
      /**
       * @description The unit in which the price is given.
       * @example USD
       */
      price_unit?: string;
      /**
       * @description The identifier of this call.
       * @example v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA
       */
      sid?: string;
      /**
       * @description The start time of this call.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      start_time?: string;
      /**
       * @description The status of this call.
       * @example completed'
       * @enum {string}
       */
      status?:
        | 'ringing'
        | 'in-progress'
        | 'canceled'
        | 'completed'
        | 'failed'
        | 'busy'
        | 'no-answer';
      /**
       * @description The phone number or SIP address that received this call.
       * @example +13987654321
       */
      to?: string;
      /**
       * @description The to number formatted for display.
       * @example (398) 765-4321
       */
      to_formatted?: string;
      /**
       * @description The relative URI for this call.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls/v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA.json
       */
      uri?: string;
    };
    /**
     * Multiple call resources
     * @example {
     *       "calls": [],
     *       "end": 0,
     *       "first_page_uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=0&PageSize=1",
     *       "next_page_uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=1&PageSize=1&PageToken=MTY4AjgyNDkwNzIxMQ",
     *       "page": 0,
     *       "page_size": 1,
     *       "start": 0,
     *       "uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=0&PageSize=1"
     *     }
     */
    CallResourceIndex: {
      calls?: components['schemas']['CallResource'][];
      /**
       * @description The number of the last element on the page, zero-indexed.
       * @example 19
       */
      end?: number;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=0&PageSize=1
       * @example accepted
       */
      first_page_uri?: string;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=1&PageSize=1&PageToken=MTY4AjgyNDkwNzIxMQ
       * @example accepted
       */
      next_page_uri?: string;
      /**
       * @description Current page number, zero-indexed.
       * @example 0
       */
      page?: number;
      /**
       * @description The number of items on the page
       * @example 20
       */
      page_size?: number;
      /**
       * @description The number of the first element on the page, zero-indexed.
       * @example 0
       */
      start?: number;
      /**
       * @description The URI of the current page.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=0&PageSize=1
       */
      uri?: string;
    };
    /**
     * Call Speak Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.speak.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "status": "completed"
     *       }
     *     }
     */
    CallSpeakEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.speak.ended
       * @enum {string}
       */
      event_type?: 'call.speak.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Reflects how the command ended.
         * @example completed
         * @enum {string}
         */
        status?: 'completed' | 'call_hangup' | 'cancelled_amd';
      };
    };
    /** Call Speak Ended Event */
    CallSpeakEndedEvent: {
      data?: components['schemas']['CallSpeakEnded'];
    };
    /**
     * Call Speak Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.speak.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d"
     *       }
     *     }
     */
    CallSpeakStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.speak.started
       * @enum {string}
       */
      event_type?: 'call.speak.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
      };
    };
    /** Call Speak Started Event */
    CallSpeakStartedEvent: {
      data?: components['schemas']['CallSpeakStarted'];
    };
    /**
     * Streaming Failed
     * @example {
     *       "record_type": "event",
     *       "event_type": "streaming.failed",
     *       "id": "25dc3731-e51e-4927-a50d-a61cc25984b1",
     *       "occurred_at": "2021-12-15T14:11:24.613295Z",
     *       "payload": {
     *         "call_control_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "call_session_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "failure_reason": "connection_failed",
     *         "stream_id": "1edb94f9-7ef0-4150-b502-e0ebadfd9491",
     *         "stream_params": {
     *           "stream_url": "wss://www.example.com/websocket",
     *           "stream_track": "inbound_track"
     *         },
     *         "stream_type": "websocket"
     *       }
     *     }
     */
    CallStreamingFailed: {
      /**
       * @description Identifies the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example streaming.failed
       * @enum {string}
       */
      event_type?: 'streaming.failed';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 25dc3731-e51e-4927-a50d-a61cc25984b1
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2021-12-15T14:11:24.613295Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description A short description explaning why the media streaming failed.
         * @example connection_failed
         */
        failure_reason?: string;
        /**
         * Format: uuid
         * @description Identifies the streaming.
         * @example 1edb94f9-7ef0-4150-b502-e0ebadfd9491
         */
        stream_id?: string;
        /** @description Streaming parameters as they were originally given to the Call Control API. */
        stream_params?: {
          /**
           * @description The destination WebSocket address where the stream is going to be delivered.
           * @example wss://www.example.com/websocket
           */
          stream_url?: string;
          /**
           * @description Specifies which track should be streamed.
           * @default inbound_track
           * @example inbound_track
           * @enum {string}
           */
          track: 'inbound_track' | 'outbound_track' | 'both_tracks';
        };
        /**
         * @description The type of stream connection the stream is performing.
         * @example websocket
         * @enum {string}
         */
        stream_type?: 'websocket' | 'dialogflow';
      };
    };
    /** Streaming Failed Event */
    CallStreamingFailedEvent: {
      data?: components['schemas']['CallStreamingFailed'];
    };
    /**
     * Streaming Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "streaming.started",
     *       "id": "7d743d69-f7e8-4761-b7d4-8cacf9d3c031",
     *       "occurred_at": "2021-12-15T14:06:32.059436Z",
     *       "payload": {
     *         "call_control_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "call_session_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "stream_url": "wss://www.example.com/websocket"
     *       }
     *     }
     */
    CallStreamingStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example streaming.started
       * @enum {string}
       */
      event_type?: 'streaming.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2021-12-15T14:06:32.059436Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Destination WebSocket address where the stream is going to be delivered.
         * @example wss://www.example.com/websocket
         */
        stream_url?: string;
      };
    };
    /** Streaming Started Event */
    CallStreamingStartedEvent: {
      data?: components['schemas']['CallStreamingStarted'];
    };
    /**
     * Streaming Stopped
     * @example {
     *       "record_type": "event",
     *       "event_type": "streaming.stopped",
     *       "id": "25dc3731-e51e-4927-a50d-a61cc25984b1",
     *       "occurred_at": "2021-12-15T14:11:24.613295Z",
     *       "payload": {
     *         "call_control_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "call_session_id": "31f19208-5db0-11ec-9ea7-02420a0d3a69",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "stream_url": "wss://www.example.com/websocket"
     *       }
     *     }
     */
    CallStreamingStopped: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example streaming.stopped
       * @enum {string}
       */
      event_type?: 'streaming.stopped';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 25dc3731-e51e-4927-a50d-a61cc25984b1
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2021-12-15T14:11:24.613295Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 31f19208-5db0-11ec-9ea7-02420a0d3a69
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Destination WebSocket address where the stream is going to be delivered.
         * @example wss://www.example.com/websocket
         */
        stream_url?: string;
      };
    };
    /** Streaming Stopped Event */
    CallStreamingStoppedEvent: {
      data?: components['schemas']['CallStreamingStopped'];
    };
    CallbackWebhookMeta: {
      /**
       * @description The number of times the callback webhook has been attempted.
       * @example 1
       */
      attempt?: number;
      /**
       * @description The URL that the callback webhook was delivered to.
       * @example https://example.com/webhook
       */
      delivered_to?: string;
    };
    CallerName: {
      /**
       * @description The name of the requested phone number's owner as per the CNAM database
       * @example TELNYX LLC
       */
      caller_name?: string;
      /**
       * @description A caller-name lookup specific error code, expressed as a stringified 5-digit integer
       * @example 10001
       */
      error_code?: string;
    };
    /** CampaignCSP */
    CampaignCSP: {
      /**
       * Campaignid
       * @description Alphanumeric identifier assigned by the registry for a campaign. This identifier is required by the NetNumber OSR SMS enabling process of 10DLC.
       * @example 4b30017a-15eb-6a25-2e3f-59b6422cud79
       */
      campaignId?: string;
      /**
       * Resellerid
       * @description Alphanumeric identifier of the reseller that you want to associate with this campaign.
       * @example RPQFAOY
       */
      resellerId?: string;
      /** @description Current campaign status. Possible values: ACTIVE, EXPIRED. A newly created campaign defaults to ACTIVE status. */
      status?: components['schemas']['Status'];
      /**
       * Createdate
       * Format: date-time
       * @description Unix timestamp when campaign was created.
       */
      createDate?: string;
      /**
       * Autorenewal
       * @description Campaign subscription auto-renewal status.
       */
      autoRenewal?: boolean;
      /**
       * Billeddate
       * Format: date-time
       * @description Campaign recent billed date.
       */
      billedDate?: string;
      /**
       * Brandid
       * @description Alphanumeric identifier of the brand associated with this campaign.
       * @example 4b206179-f731-8ab7-f19c-34e19d22ide9
       */
      brandId: string;
      vertical: components['schemas']['Vertical'];
      usecase: components['schemas']['Usecase'];
      subUsecases?: components['schemas']['Usecase'];
      /**
       * Description
       * @description Summary description of this campaign.
       * @example Campaign description goes here.
       */
      description: string;
      /**
       * Embeddedlink
       * @description Does message generated by the campaign include URL link in SMS?
       * @default false
       */
      embeddedLink: boolean;
      /**
       * Embeddedphone
       * @description Does message generated by the campaign include phone number in SMS?
       * @default false
       */
      embeddedPhone: boolean;
      /**
       * Affiliatemarketing
       * @description Does message content controlled by affiliate marketing other than the brand?
       */
      affiliateMarketing?: boolean;
      /**
       * Numberpool
       * @description Does campaign utilize pool of phone nubers?
       * @default false
       */
      numberPool: boolean;
      /**
       * Agegated
       * @description Age gated content in campaign.
       */
      ageGated?: boolean;
      /** Directlending */
      directLending?: boolean;
      /**
       * Subscriberoptin
       * @description Does campaign require subscriber to opt-in before SMS is sent to subscriber?
       * @default false
       */
      subscriberOptin: boolean;
      /**
       * Subscriberoptout
       * @description Does campaign support subscriber opt-out keyword(s)?
       * @default false
       */
      subscriberOptout: boolean;
      /**
       * Subscriberhelp
       * @description Does campaign responds to help keyword(s)?
       * @default false
       */
      subscriberHelp: boolean;
      /**
       * Sample1
       * @description Message sample. Some campaign tiers require 1 or more message samples.
       * @example This is a sample message associated with your campaign!
       */
      sample1?: string;
      /**
       * Sample2
       * @description Message sample. Some campaign tiers require 2 or more message samples.
       */
      sample2?: string;
      /**
       * Sample3
       * @description Message sample. Some campaign tiers require 3 or more message samples.
       */
      sample3?: string;
      /**
       * Sample4
       * @description Message sample. Some campaign tiers require 4 or more message samples.
       */
      sample4?: string;
      /**
       * Sample5
       * @description Message sample. Some campaign tiers require 5 or more message samples.
       */
      sample5?: string;
      /**
       * Messageflow
       * @description Message flow description.
       */
      messageFlow?: string;
      /**
       * Helpmessage
       * @description Help message of the campaign.
       */
      helpMessage?: string;
    };
    /** CampaignCost */
    CampaignCost: {
      /** Campaignusecase */
      campaignUsecase: string;
      /** Monthlycost */
      monthlyCost: string;
      /** Upfrontcost */
      upFrontCost: string;
      /** Description */
      description: string;
    };
    /** CampaignDeletionResponse */
    CampaignDeletionResponse: {
      /** Time */
      time: number;
      /** Record Type */
      record_type?: string;
      /** Message */
      message?: string;
    };
    /** CampaignRecordSetCSP */
    CampaignRecordSetCSP: {
      /** Records */
      records?: components['schemas']['CampaignCSP'][];
      /**
       * Page
       * @example 1
       */
      page?: number;
      /**
       * Totalrecords
       * @example 1
       */
      totalRecords?: number;
    };
    /** CampaignRecordSet_CSP */
    CampaignRecordSet_CSP: {
      /** Page */
      page?: number;
      /** Records */
      records?: components['schemas']['TelnyxCampaignWithAssignedCount_CSP'][];
      /** Totalrecords */
      totalRecords?: number;
    };
    /**
     * CampaignRequest
     * @description CampaignRequest object describes the campaign to be submitted via '/campaignBuilder/brand/{brandId}/usecase/{usecase}' operation. It is also used in operations for retrieving status of campaign request and for updating a pending request.
     */
    CampaignRequest: {
      /**
       * Affiliatemarketing
       * @description Does message content controlled by affiliate marketing other than the brand?
       */
      affiliateMarketing?: boolean;
      /**
       * Agegated
       * @description Age gated message content in campaign.
       */
      ageGated?: boolean;
      /**
       * Autorenewal
       * @description Campaign subscription auto-renewal option. If set to true, then campaign will automatically renewal at end of billing cycle.
       */
      autoRenewal?: boolean;
      /**
       * Brandid
       * @description Alphanumeric identifier of the brand associated with this campaign.
       */
      brandId: string;
      /**
       * Description
       * @description Summary description of this campaign.
       */
      description: string;
      /**
       * Directlending
       * @description Direct lending or loan arrangement
       */
      directLending?: boolean;
      /**
       * Embeddedlink
       * @description Does message generated by the campaign include URL link in SMS?
       */
      embeddedLink?: boolean;
      /**
       * Embeddedphone
       * @description Does message generated by the campaign include phone number in SMS?
       */
      embeddedPhone?: boolean;
      /**
       * Helpkeywords
       * @description Subscriber help keywords. Multiple keywords are comma separated without space.
       */
      helpKeywords?: string;
      /**
       * Helpmessage
       * @description Help message of the campaign.
       */
      helpMessage?: string;
      /**
       * Messageflow
       * @description Message flow description.
       */
      messageFlow?: string;
      /**
       * Mnoids
       * @description Submit campaign to given list of MNOs by MNO's network ID. Default is all MNOs if no value provided.
       */
      mnoIds?: number[];
      /**
       * Numberpool
       * @description Does campaign utilize pool of phone numbers?
       */
      numberPool?: boolean;
      /**
       * Optinkeywords
       * @description Subscriber opt-in keywords. Multiple keywords are comma separated without space.
       */
      optinKeywords?: string;
      /**
       * Optinmessage
       * @description Subscriber opt-in message.
       */
      optinMessage?: string;
      /**
       * Optoutkeywords
       * @description Subscriber opt-out keywords. Multiple keywords are comma separated without space.
       */
      optoutKeywords?: string;
      /**
       * Optoutmessage
       * @description Subscriber opt-out message.
       */
      optoutMessage?: string;
      /**
       * Referenceid
       * @description Caller supplied campaign reference ID. If supplied, the value must be unique across all submitted campaigns. Can be used to prevent duplicate campaign registrations.
       */
      referenceId?: string;
      /**
       * Resellerid
       * @description Alphanumeric identifier of the reseller that you want to associate with this campaign.
       */
      resellerId?: string;
      /**
       * Sample1
       * @description Message sample. Some campaign tiers require 1 or more message samples.
       */
      sample1?: string;
      /**
       * Sample2
       * @description Message sample. Some campaign tiers require 2 or more message samples.
       */
      sample2?: string;
      /**
       * Sample3
       * @description Message sample. Some campaign tiers require 3 or more message samples.
       */
      sample3?: string;
      /**
       * Sample4
       * @description Message sample. Some campaign tiers require 4 or more message samples.
       */
      sample4?: string;
      /**
       * Sample5
       * @description Message sample. Some campaign tiers require 5 or more message samples.
       */
      sample5?: string;
      /**
       * Subusecases
       * @description Campaign sub-usecases. Must be of defined valid sub-usecase types. Use `/registry/enum/usecase` operation to retrieve list of valid sub-usecases
       */
      subUsecases?: string[];
      /**
       * Subscriberhelp
       * @description Does campaign responds to help keyword(s)?
       */
      subscriberHelp?: boolean;
      /**
       * Subscriberoptin
       * @description Does campaign require subscriber to opt-in before SMS is sent to subscriber?
       */
      subscriberOptin?: boolean;
      /**
       * Subscriberoptout
       * @description Does campaign support subscriber opt-out keyword(s)?
       */
      subscriberOptout?: boolean;
      /**
       * Tag
       * @description Tags to be set on the Campaign.
       */
      tag?: string[];
      /**
       * Termsandconditions
       * @description Is terms and conditions accepted?
       */
      termsAndConditions?: boolean;
      /**
       * Usecase
       * @description Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase` operation to retrieve usecases available for given brand.
       */
      usecase: string;
      /**
       * WebhookURL
       * @description Webhook to which campaign status updates are sent.
       * @example https://webhook.com/67ea78a8-9f32-4d04-b62d-f9502e8e5f93
       */
      webhookURL?: string;
      /**
       * WebhookFailoverURL
       * @description Failover webhook to which campaign status updates are sent.
       * @example https://webhook.com/93711262-23e5-4048-a966-c0b2a16d5963
       */
      webhookFailoverURL?: string;
    };
    /** CampaignSharingChain */
    CampaignSharingChain: {
      sharedByMe?: components['schemas']['CampaignSharingStatus'];
      sharedWithMe?: components['schemas']['CampaignSharingStatus'];
    };
    /** CampaignSharingStatus */
    CampaignSharingStatus: {
      /** Downstreamcnpid */
      downstreamCnpId?: string;
      /** Shareddate */
      sharedDate?: string;
      /** Sharingstatus */
      sharingStatus?: string;
      /** Statusdate */
      statusDate?: string;
      /** Upstreamcnpid */
      upstreamCnpId?: string;
    };
    /** CampaignStatus */
    CampaignStatus: {
      /**
       * Description
       * @description The campaign description.
       * @example This campaign belongs to John's Donuts and will be used for marketing.
       */
      description: string;
      /**
       * @description The current status of the campaign.
       * @example pending
       */
      status: components['schemas']['CreationStatus'];
      /**
       * Campaignid
       * @description The ID of the campaign created via bulk creation. This campaign will only have a campaignId after the campaign has been created.
       * @example 4b30017a-2f50-4c90-c9e6-5f67304cbde7
       */
      campaignId?: string;
      /**
       * Created At
       * Format: date-time
       * @description The date and time that the campaign was created.
       * @example 2021-06-30T10:49:04-07:00
       */
      created_at?: string;
      /**
       * Error
       * @description Errors related to a campaign creation failure.
       * @example More sample messages required for some mobile network operators.
       */
      error?: string;
    };
    /** Campaign Status Update Event */
    CampaignStatusUpdateEvent: {
      /**
       * Brandid
       * @description Brand ID associated with the campaign.
       * @example d88dd2aa-1bb9-4ef0-9ec8-1752b80316a5
       */
      brandId?: string;
      /**
       * Campaignid
       * @description The ID of the campaign.
       * @example 4b300178-131c-d902-d54e-72d90ba1620j
       */
      campaignId?: string;
      /**
       * CreateDate
       * @description Unix timestamp when campaign was created.
       */
      createDate?: string;
      /**
       * Cspid
       * @description Alphanumeric identifier of the CSP associated with this campaign.
       */
      cspId?: string;
      /**
       * IsTMobileRegistered
       * @description Indicates whether the campaign is registered with T-Mobile.
       */
      isTMobileRegistered?: boolean;
    };
    Carrier: {
      /**
       * @description Region code that matches the specific country calling code if the requested phone number type is mobile
       * @example US
       */
      mobile_country_code?: string;
      /**
       * @description National destination code (NDC), with a 0 prefix, if an NDC is found and the requested phone number type is mobile
       * @example 0866
       */
      mobile_network_code?: string;
      /**
       * @description SPID (Service Provider ID) name, if the requested phone number has been ported; otherwise, the name of carrier who owns the phone number block
       * @example Telnyx/4
       */
      name?: string;
      /**
       * @description A phone number type that identifies the type of service associated with the requested phone number
       * @example voip
       * @enum {string}
       */
      type?:
        | 'fixed line'
        | 'mobile'
        | 'voip'
        | 'fixed line or mobile'
        | 'toll free'
        | 'premium rate'
        | 'shared cost'
        | 'personal number'
        | 'pager'
        | 'uan'
        | 'voicemail'
        | 'unknown';
      /**
       * @description Unused
       * @example null
       */
      error_code?: string;
      /**
       * @description If known to Telnyx and applicable, the primary network carrier.
       * @example AT&T
       */
      normalized_carrier?: string;
    };
    CdrGetSyncUsageReportResponse: {
      data?: components['schemas']['CdrUsageReportResponse'];
    };
    CdrUsageReportResponse: {
      /**
       * Format: uuid
       * @description Identifies the resource
       */
      id?: string;
      /**
       * Format: date-time
       * @example 2018-02-02T22:25:27.521Z
       */
      start_time?: string;
      /**
       * Format: date-time
       * @example 2018-02-02T22:25:27.521Z
       */
      end_time?: string;
      /** @example [1234567890L, 9876543210L] */
      connections?: number[];
      /** @enum {string} */
      aggregation_type?:
        | 'NO_AGGREGATION'
        | 'CONNECTION'
        | 'TAG'
        | 'BILLING_GROUP';
      /** @enum {string} */
      status?: 'PENDING' | 'COMPLETE' | 'FAILED' | 'EXPIRED';
      /** @example http://portal.telnyx.com/downloads/report_name_8hvb45Gu.csv */
      report_url?: string;
      result?: Record<string, never>;
      /**
       * Format: date-time
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
      /** @example cdr_usage_report */
      record_type?: string;
      /** @enum {string} */
      product_breakdown?:
        | 'NO_BREAKDOWN'
        | 'DID_VS_TOLL_FREE'
        | 'COUNTRY'
        | 'DID_VS_TOLL_FREE_PER_COUNTRY';
    };
    /** Function */
    ChatCompletionMessageToolCallFunctionParam: {
      /** Arguments */
      arguments: string;
      /** Name */
      name: string;
    };
    /** ChatCompletionMessageToolCallParam */
    ChatCompletionMessageToolCallParam: {
      /** Id */
      id: string;
      function: components['schemas']['ChatCompletionMessageToolCallFunctionParam'];
      /** Type */
      type: string;
    };
    /** Function */
    ChatCompletionNamedToolChoiceFunctionParam: {
      /** Name */
      name: string;
    };
    /** ChatCompletionRequest */
    ChatCompletionRequest: {
      /**
       * @description A list of the previous chat messages for context.
       * @example [
       *       {
       *         "role": "system",
       *         "content": "You are a friendly chatbot."
       *       },
       *       {
       *         "role": "user",
       *         "content": "Hello, world!"
       *       }
       *     ]
       */
      messages: components['schemas']['ChatCompletionSystemMessageParam'][];
      /**
       * @description The language model to chat with. If you are optimizing for speed + price, try `meta-llama/Meta-Llama-3.1-8B-Instruct`. For quality, try `meta-llama/Meta-Llama-3.1-70B-Instruct`. Or explore our [LLM Library](https://telnyx.com/products/llm-library).
       * @default meta-llama/Meta-Llama-3.1-8B-Instruct
       */
      model: string;
      /**
       * @description Whether or not to stream data-only server-sent events as they become available.
       * @default false
       */
      stream: boolean;
      /**
       * @description Adjusts the "creativity" of the model. Lower values make the model more deterministic and repetitive, while higher values make the model more random and creative.
       * @default 0.1
       */
      temperature: number;
      /** @description Maximum number of completion tokens the model should generate. */
      max_tokens?: number;
      /** @description The `function` tool type follows the same schema as the [OpenAI Chat Completions API](https://platform.openai.com/docs/api-reference/chat). The `retrieval` tool type is unique to Telnyx. You may pass a list of [embedded storage buckets](https://developers.telnyx.com/api/inference/inference-embedding/post-embedding) for retrieval-augmented generation. */
      tools?: (
        | components['schemas']['ChatCompletionToolParam']
        | components['schemas']['Retrieval']
      )[];
      /** @enum {string} */
      tool_choice?: 'none' | 'auto' | 'required';
      /** @description Use this is you want to guarantee a JSON output without defining a schema. For control over the schema, use `guided_json`. */
      response_format?: components['schemas']['ChatCompletionResponseFormatParam'];
      /** @description Must be a valid JSON schema. If specified, the output will follow the JSON schema. */
      guided_json?: Record<string, never>;
      /** @description If specified, the output will follow the regex pattern. */
      guided_regex?: string;
      /** @description If specified, the output will be exactly one of the choices. */
      guided_choice?: string[];
      /** @description This is an alternative to `top_p` that [many prefer](https://github.com/huggingface/transformers/issues/27670). Must be in [0, 1]. */
      min_p?: number;
      /** @description This will return multiple choices for you instead of a single chat completion. */
      n?: number;
      /**
       * @description Setting this to `true` will allow the model to [explore more completion options](https://huggingface.co/blog/how-to-generate#beam-search). This is not supported by OpenAI.
       * @default false
       */
      use_beam_search: boolean;
      /** @description This is used with `use_beam_search` to determine how many candidate beams to explore. */
      best_of?: number;
      /**
       * @description This is used with `use_beam_search` to prefer shorter or longer completions.
       * @default 1
       */
      length_penalty: number;
      /**
       * @description This is used with `use_beam_search`. If `true`, generation stops as soon as there are `best_of` complete candidates; if `false`, a heuristic is applied and the generation stops when is it very unlikely to find better candidates.
       * @default false
       */
      early_stopping: boolean;
      /**
       * @description Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the `content` of `message`.
       * @default false
       */
      logprobs: boolean;
      /** @description This is used with `logprobs`. An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. */
      top_logprobs?: number;
      /**
       * @description Higher values will penalize the model from repeating the same output tokens.
       * @default 0
       */
      frequency_penalty: number;
      /**
       * @description Higher values will penalize the model from repeating the same output tokens.
       * @default 0
       */
      presence_penalty: number;
      /** @description An alternative or complement to `temperature`. This adjusts how many of the top possibilities to consider. */
      top_p?: number;
      /** @description If you are using OpenAI models using our API, this is how you pass along your OpenAI API key. */
      openai_api_key?: string;
    };
    /** ChatCompletionResponseFormatParam */
    ChatCompletionResponseFormatParam: {
      /** @enum {string} */
      type: 'text' | 'json_object';
    };
    /** ChatCompletionSystemMessageParam */
    ChatCompletionSystemMessageParam: {
      content:
        | string
        | {
            /** @enum {string} */
            type: 'text' | 'image_url';
            text?: string;
            image_url?: string;
          }[];
      /** @enum {string} */
      role: 'system' | 'user' | 'assistant' | 'tool';
    };
    /** Function */
    ChatCompletionToolParam: {
      /** @enum {string} */
      type: 'function';
      function: components['schemas']['FunctionDefinition'];
    };
    /**
     * Civic Address
     * @example {
     *       "id": "07a4dc5d-9b3b-4ba2-88a4-6ba172316c65",
     *       "record_type": "civic_address",
     *       "city_or_town": "Chicago",
     *       "city_or_town_alias": null,
     *       "company_name": "Telnyx",
     *       "country": "US",
     *       "county_or_district": "US",
     *       "default_location_id": "18ded4bb-b694-44c1-a89b-a35b7acd4c9e",
     *       "description": "Chicago Office",
     *       "house_number": "311",
     *       "house_number_suffix": null,
     *       "locations": [
     *         {
     *           "id": "18ded4bb-b694-44c1-a89b-a35b7acd4c9e",
     *           "additional_info": null,
     *           "description": "Chicago Office",
     *           "is_default": true
     *         },
     *         {
     *           "id": "d420a57f-c4ae-4697-87e1-fbefd9e86f72",
     *           "additional_info": "Main building, Suite 504",
     *           "description": null,
     *           "is_default": false
     *         }
     *       ],
     *       "postal_or_zip_code": "60654",
     *       "state_or_province": "IL",
     *       "street_name": "West Superior Street",
     *       "street_suffix": null
     *     }
     */
    CivicAddress: {
      id?: components['schemas']['UUID'];
      /**
       * @description Identifies the type of the resource.
       * @example civic_address
       */
      record_type?: string;
      /** @example Chicago */
      city_or_town?: string;
      city_or_town_alias?: string;
      /** @example Telnyx */
      company_name?: string;
      /** @example US */
      country?: string;
      /** @example US */
      country_or_district?: string;
      /**
       * Format: uuid
       * @description Identifies what is the default location in the list of locations.
       */
      default_location_id?: string;
      /** @example Chicago Office */
      description?: string;
      /** @example 311 */
      house_number?: string;
      house_number_suffix?: string;
      /** @example 60654 */
      postal_or_zip_code?: string;
      /** @example IL */
      state_or_province?: string;
      /** @example West Superior Street */
      street_name?: string;
      street_suffix?: string;
      locations?: components['schemas']['Location'][];
    };
    /**
     * Update client state Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d"
     *     }
     */
    ClientStateUpdateRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state: string;
    };
    /**
     * CloudflareSyncStatus
     * @description An enumeration.
     * @enum {string}
     */
    CloudflareSyncStatus: 'pending' | 'added';
    /**
     * @description The CNAM listing settings for a phone number.
     * @example {
     *       "cnam_listing_enabled": true,
     *       "cnam_listing_details": "example"
     *     }
     */
    CnamListing: {
      /**
       * @description Enables CNAM listings for this number. Requires cnam_listing_details to also be set.
       * @default false
       */
      cnam_listing_enabled: boolean;
      /** @description The CNAM listing details for this number. Must be alphanumeric characters or spaces with a maximum length of 15. Requires cnam_listing_enabled to also be set to true. */
      cnam_listing_details?: string;
    };
    Comment: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example Hi there, .... */
      body?: string;
      /** @example user@company.com */
      readonly commenter?: string;
      /**
       * @example user
       * @enum {string}
       */
      readonly commenter_type?: 'admin' | 'user';
      /**
       * @example sub_number_order
       * @enum {string}
       */
      comment_record_type?:
        | 'number_order'
        | 'sub_number_order'
        | 'number_order_phone_number';
      /**
       * Format: uuid
       * @example 8ffb3622-7c6b-4ccc-b65f-7a3dc0099576
       */
      comment_record_id?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the comment was read.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly read_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the comment was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the comment was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
    };
    /**
     * OTAUpdate
     * @description This object represents an Over the Air (OTA) update request. It allows tracking the current status of a operation that apply settings in a particular SIM card. <br/><br/>
     * @example {
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "record_type": "ota_update",
     *       "settings": {
     *         "mobile_network_operators_preferences": [
     *           {
     *             "mobile_network_operator_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *             "mobile_network_operator_name": "AT&T Mobility (USACG)",
     *             "priority": 0
     *           }
     *         ]
     *       },
     *       "sim_card_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "status": "in-progress",
     *       "type": "sim_card_network_preferences",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     }
     */
    CompleteOTAUpdate: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /** @example ota_update */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description The identification UUID of the related SIM card resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_id?: string;
      /**
       * @description Represents the type of the operation requested. This will relate directly to the source of the request.
       * @example sim_card_network_preferences
       * @enum {string}
       */
      type?: 'sim_card_network_preferences';
      /**
       * @example in-progress
       * @enum {string}
       */
      status?: 'in-progress' | 'completed' | 'failed';
      /** @description A JSON object representation of the operation. The information present here will relate directly to the source of the OTA request. */
      settings?: {
        mobile_network_operators_preferences?: components['schemas']['MobileNetworkOperatorsPreferencesResponse'];
      };
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /**
     * Composition Completed
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.composition.completed",
     *       "id": "d51754fc-6888-4b0e-8f29-fc3ae41250cd",
     *       "occurred_at": "2022-03-02 04:47:29.980874Z",
     *       "payload": {
     *         "composition_id": "5970ce77-4aeb-4e18-ac8c-3effca0c145a",
     *         "download_url": "https://www.example.com",
     *         "duration_secs": 53,
     *         "format": "mp4",
     *         "resolution": "1280x720",
     *         "room_id": "2fbf2c0d-b6aa-463f-aeed-83ce298be978",
     *         "session_id": "7c4da191-2600-4df6-a35e-0ecae6caa5d3",
     *         "size_mb": 2.6
     *       }
     *     }
     */
    CompositionCompleted: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.composition.completed
       * @enum {string}
       */
      event_type?: 'video.room.composition.completed';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Composition ID that identifies the room composition.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        composition_id?: string;
        /**
         * @description Url to download the room composition.
         * @example https://www.example.com
         */
        download_url?: string;
        /**
         * @description Room composition duration in seconds.
         * @example 67
         */
        duration_secs?: number;
        /**
         * @description Format of the room composition.
         * @example mp4
         */
        format?: string;
        /**
         * @description Format of the room composition.
         * @example 1280x720
         */
        resolution?: string;
        /**
         * Format: uuid
         * @description Room ID associated with the room composition.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
        /**
         * Format: uuid
         * @description Session ID associated with the room composition.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: float
         * @description Room composition size in MB.
         * @example 10.5
         */
        size_mb?: number;
      };
    };
    /** Composition Completed Event */
    CompositionCompletedEvent: {
      data?: components['schemas']['CompositionCompleted'];
    };
    /**
     * Conference
     * @example {
     *       "record_type": "conference",
     *       "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "name": "All hands meeting",
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "expires_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z",
     *       "region": "sv1",
     *       "status": "completed",
     *       "end_reason": "all_left",
     *       "ended_by": {
     *         "call_control_id": "v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQczRrZvZakpWxBlpw48KyZQ==",
     *         "call_session_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1"
     *       },
     *       "connection_id": "3fa85f64-9191-4567-b3fc-2c963f66afa6"
     *     }
     */
    Conference: {
      /**
       * @example conference
       * @enum {string}
       */
      record_type: 'conference';
      /**
       * @description Uniquely identifies the conference
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      id: string;
      /**
       * @description Name of the conference
       * @example All hands meeting
       */
      name: string;
      /**
       * @description ISO 8601 formatted date of when the conference was created
       * @example 2019-01-23T18:10:02.574Z
       */
      created_at: string;
      /**
       * @description ISO 8601 formatted date of when the conference will expire
       * @example 2019-01-23T18:10:02.574Z
       */
      expires_at: string;
      /**
       * @description ISO 8601 formatted date of when the conference was last updated
       * @example 2019-01-23T18:10:02.574Z
       */
      updated_at?: string;
      /**
       * @description Region where the conference is hosted
       * @example sv1
       */
      region?: string;
      /**
       * @description Status of the conference
       * @example completed
       * @enum {string}
       */
      status?: 'init' | 'in_progress' | 'completed';
      /**
       * @description Reason why the conference ended
       * @example all_left
       * @enum {string}
       */
      end_reason?: 'all_left' | 'ended_via_api' | 'host_left' | 'time_exceeded';
      /** @description IDs related to who ended the conference. It is expected for them to all be there or all be null */
      ended_by?: {
        /**
         * @description Call Control ID which ended the conference
         * @example v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQczRrZvZakpWxBlpw48KyZQ==
         */
        call_control_id?: string;
        /**
         * @description Call Session ID which ended the conference
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
      };
      /**
       * @description Identifies the connection associated with the conference
       * @example 3fa85f64-9191-4567-b3fc-2c963f66afa6
       */
      connection_id?: string;
    };
    /**
     * Conference Command Result
     * @example {
     *       "result": "ok"
     *     }
     */
    ConferenceCommandResult: {
      /** @example ok */
      result: string;
    };
    /**
     * Conference Created
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.created",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceCreated: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.created
       * @enum {string}
       */
      event_type?: 'conference.created';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Conference ID that the participant joined.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Created Event */
    ConferenceCreatedEvent: {
      data?: components['schemas']['ConferenceCreated'];
    };
    ConferenceDetailRecord: {
      /**
       * @description Conference id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      id?: string;
      /**
       * @description Conference name
       * @example My Conference
       */
      name?: string;
      /**
       * @description User id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      user_id?: string;
      /**
       * Format: date-time
       * @description Conference start time
       * @example 2020-07-01T00:00:00-06:00
       */
      started_at?: string;
      /**
       * Format: date-time
       * @description Conference end time
       * @example 2020-07-01T00:00:00-06:00
       */
      ended_at?: string;
      /**
       * Format: date-time
       * @description Conference expiry time
       * @example 2020-07-01T00:00:00-06:00
       */
      expires_at?: string;
      /**
       * @description Region where the conference is hosted
       * @example ch1
       */
      region?: string;
      /**
       * @description Telnyx UUID that identifies the conference call leg
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      call_leg_id?: string;
      /**
       * @description Telnyx UUID that identifies with conference call session
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      call_session_id?: string;
      /**
       * @description Connection id
       * @example 1583941447772537867
       */
      connection_id?: string;
      /**
       * @description Duration of the conference call in seconds
       * @example 100
       */
      call_sec?: number;
      /**
       * @description Number of participants that joined the conference call
       * @example 5
       */
      participant_count?: number;
      /**
       * @description Sum of the conference call duration for all participants in seconds
       * @example 100
       */
      participant_call_sec?: number;
      /**
       * @description Indicates whether Telnyx billing charges might be applicable
       * @example false
       */
      is_telnyx_billable?: boolean;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'ConferenceDetailRecord';
    };
    /**
     * Conference Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z",
     *         "reason": "host_left"
     *       }
     *     }
     */
    ConferenceEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.ended
       * @enum {string}
       */
      event_type?: 'conference.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Conference ID that the participant joined.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
        /**
         * @description Reason the conference ended.
         * @enum {string}
         */
        reason?: 'all_left' | 'host_left' | 'time_exceeded';
      };
    };
    /** Conference Ended Event */
    ConferenceEndedEvent: {
      data?: components['schemas']['ConferenceEnded'];
    };
    /**
     * Conference Floor Changed
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.floor.changed",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceFloorChangedEvent: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.floor.changed
       * @enum {string}
       */
      event_type?: 'conference.floor.changed';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call Control ID of the new speaker.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description Call Leg ID of the new speaker.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description Call Session ID of the new speaker.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Conference ID that had a speaker change event.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /**
     * Conference Hold Request
     * @example {
     *       "call_control_ids": [
     *         "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg"
     *       ],
     *       "audio_url": "http://example.com/message.wav"
     *     }
     */
    ConferenceHoldRequest: {
      /** @description List of unique identifiers and tokens for controlling the call. When empty all participants will be placed on hold. */
      call_control_ids?: string[];
      /**
       * @description The URL of a file to be played to the participants when they are put on hold. media_name and audio_url cannot be used together in one request.
       * @example http://example.com/message.wav
       */
      audio_url?: string;
      /**
       * @description The media_name of a file to be played to the participants when they are put on hold. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      media_name?: string;
    };
    /**
     * Conference Mute Request
     * @example {
     *       "call_control_ids": [
     *         "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg"
     *       ]
     *     }
     */
    ConferenceMuteRequest: {
      /** @description Array of unique identifiers and tokens for controlling the call. When empty all participants will be muted. */
      call_control_ids?: string[];
    };
    ConferenceParticipantDetailRecord: {
      /**
       * @description Participant id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      id?: string;
      /**
       * @description User id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      user_id?: string;
      /**
       * @description Conference id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      conference_id?: string;
      /**
       * Format: date-time
       * @description Participant join time
       * @example 2020-07-01T00:00:00-06:00
       */
      joined_at?: string;
      /**
       * Format: date-time
       * @description Participant leave time
       * @example 2020-07-01T00:00:00-06:00
       */
      left_at?: string;
      /**
       * @description Number called by the participant to join the conference
       * @example +18005550199
       */
      destination_number?: string;
      /**
       * @description Participant origin number used in the conference call
       * @example +18005550199
       */
      originating_number?: string;
      /**
       * @description Telnyx UUID that identifies the conference call leg
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      call_leg_id?: string;
      /**
       * @description Telnyx UUID that identifies with conference call session
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      call_session_id?: string;
      /**
       * @description Duration of the conference call in seconds
       * @example 100
       */
      call_sec?: number;
      /**
       * @description Duration of the conference call for billing purposes
       * @example 120
       */
      billed_sec?: number;
      /**
       * @description Indicates whether Telnyx billing charges might be applicable
       * @example true
       */
      is_telnyx_billable?: boolean;
      /**
       * @description Currency amount per billing unit used to calculate the Telnyx billing cost
       * @example 0.002
       */
      rate?: string;
      /**
       * @description Billing unit used to calculate the Telnyx billing cost
       * @example minutes
       */
      rate_measured_in?: string;
      /**
       * @description Currency amount for Telnyx billing cost
       * @example 0.004
       */
      cost?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'ConferenceParticipantDetailRecord';
    };
    /**
     * Conference Participant Joined
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.participant.joined",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1"
     *       }
     *     }
     */
    ConferenceParticipantJoined: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.participant.joined
       * @enum {string}
       */
      event_type?: 'conference.participant.joined';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Conference ID that the participant joined.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
      };
    };
    /** Conference Participant Joined Event */
    ConferenceParticipantJoinedEvent: {
      data?: components['schemas']['ConferenceParticipantJoined'];
    };
    /**
     * Conference Participant Left
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.participant.left",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1"
     *       }
     *     }
     */
    ConferenceParticipantLeft: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.participant.left
       * @enum {string}
       */
      event_type?: 'conference.participant.left';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Conference ID that the participant joined.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
      };
    };
    /** Conference Participant Left Event */
    ConferenceParticipantLeftEvent: {
      data?: components['schemas']['ConferenceParticipantLeft'];
    };
    /**
     * Conference Participant Playback Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.participant.playback.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "media_url": "https://www.example.com/audio.mp3",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceParticipantPlaybackEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.participant.playback.ended
       * @enum {string}
       */
      event_type?: 'conference.participant.playback.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Participant's call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * @description The audio URL being played back, if audio_url has been used to start.
         * @example http://example.com/audio.wav
         */
        media_url?: string;
        /**
         * @description The name of the audio media file being played back, if media_name has been used to start.
         * @example my_media_uploaded_to_media_storage_api
         */
        media_name?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Participant Playback Ended Event */
    ConferenceParticipantPlaybackEndedEvent: {
      data?: components['schemas']['ConferenceParticipantPlaybackEnded'];
    };
    /**
     * Conference Participant Playback Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.participant.playback.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "media_url": "https://www.example.com/audio.mp3",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceParticipantPlaybackStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.participant.playback.started
       * @enum {string}
       */
      event_type?: 'conference.participant.playback.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Participant's call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * @description The audio URL being played back, if audio_url has been used to start.
         * @example http://example.com/audio.wav
         */
        media_url?: string;
        /**
         * @description The name of the audio media file being played back, if media_name has been used to start.
         * @example my_media_uploaded_to_media_storage_api
         */
        media_name?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Participant Playback Started Event */
    ConferenceParticipantPlaybackStartedEvent: {
      data?: components['schemas']['ConferenceParticipantPlaybackStarted'];
    };
    /**
     * Conference Participant Speak Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.participant.speak.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceParticipantSpeakEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.participant.speak.ended
       * @enum {string}
       */
      event_type?: 'conference.participant.speak.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Participant's call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Participant Speak Ended Event */
    ConferenceParticipantSpeakEndedEvent: {
      data?: components['schemas']['ConferenceParticipantSpeakEnded'];
    };
    /**
     * Conference Participant Speak Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.participant.speak.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceParticipantSpeakStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.participant.speak.started
       * @enum {string}
       */
      event_type?: 'conference.participant.speak.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Participant's call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Participant Speak Started Event */
    ConferenceParticipantSpeakStartedEvent: {
      data?: components['schemas']['ConferenceParticipantSpeakStarted'];
    };
    /**
     * Conference Play Request
     * @example {
     *       "audio_url": "http://www.example.com/sounds/greeting.wav"
     *     }
     */
    ConferencePlayRequest: {
      /**
       * @description The URL of a file to be played back in the conference. media_name and audio_url cannot be used together in one request.
       * @example http://example.com/message.wav
       */
      audio_url?: string;
      /**
       * @description The media_name of a file to be played back in the conference. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      media_name?: string;
      /**
       * @description The number of times the audio file should be played. If supplied, the value must be an integer between 1 and 100, or the special string `infinity` for an endless loop.
       * @default 1
       * @example infinity
       */
      loop: components['schemas']['Loopcount'];
      /** @description List of call control ids identifying participants the audio file should be played to. If not given, the audio file will be played to the entire conference. */
      call_control_ids?: string[];
    };
    /**
     * Conference Playback Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.playback.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "media_url": "https://www.example.com/audio.mp3",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferencePlaybackEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.playback.ended
       * @enum {string}
       */
      event_type?: 'conference.playback.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * @description The audio URL being played back, if audio_url has been used to start.
         * @example http://example.com/audio.wav
         */
        media_url?: string;
        /**
         * @description The name of the audio media file being played back, if media_name has been used to start.
         * @example my_media_uploaded_to_media_storage_api
         */
        media_name?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Playback Ended Event */
    ConferencePlaybackEndedEvent: {
      data?: components['schemas']['ConferencePlaybackEnded'];
    };
    /**
     * Conference Playback Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.playback.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "media_url": "https://www.example.com/audio.mp3",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferencePlaybackStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.playback.started
       * @enum {string}
       */
      event_type?: 'conference.playback.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * @description The audio URL being played back, if audio_url has been used to start.
         * @example http://example.com/audio.wav
         */
        media_url?: string;
        /**
         * @description The name of the audio media file being played back, if media_name has been used to start.
         * @example my_media_uploaded_to_media_storage_api
         */
        media_name?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Playback Started Event */
    ConferencePlaybackStartedEvent: {
      data?: components['schemas']['ConferencePlaybackStarted'];
    };
    /**
     * Conference recording resource
     * @example {
     *       "account_sid": "4e71926f-8f13-450e-b91c-23c2ef786aa6",
     *       "call_sid": "v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ",
     *       "channels": 1,
     *       "conference_sid": "6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f",
     *       "date_created": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "date_updated": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "duration": 5,
     *       "error_code": null,
     *       "media_url": "https://www.example.com/download.mp3",
     *       "sid": "136285da-4b74-46f1-a016-fe2982fa77c3",
     *       "source": "StartConferenceRecordingAPI",
     *       "start_time": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "status": "completed",
     *       "subresource_uris": {
     *         "transcriptions": null
     *       },
     *       "uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings/136285da-4b74-46f1-a016-fe2982fa77c3.json"
     *     }
     */
    ConferenceRecordingResource: {
      /**
       * @description The id of the account the resource belongs to.
       * @example 61bf923e-5e4d-4595-a110-56190ea18a1b
       */
      account_sid?: string;
      /**
       * @description The identifier of the related participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      call_sid?: string;
      /**
       * @description The number of channels in the recording.
       * @example 1
       */
      channels?: number;
      /**
       * @description The identifier of the related conference.
       * @example 6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f
       */
      conference_sid?: string;
      /**
       * @description The timestamp of when the resource was created.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_created?: string;
      /**
       * @description The timestamp of when the resource was last updated.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_updated?: string;
      /**
       * @description Duratin of the recording in seconds.
       * @example 10
       */
      duration?: number;
      /**
       * @description The recording error, if any.
       * @example null
       */
      error_code?: string;
      /**
       * @description The URL to use to download the recording.
       * @example https://www.example.com/download.mp3
       */
      media_url?: string;
      /**
       * @description The unique identifier of the recording.
       * @example 136285da-4b74-46f1-a016-fe2982fa77c3
       */
      sid?: string;
      /**
       * @description How the recording was started.
       * @example StartConferenceRecordingAPI
       * @enum {string}
       */
      source?:
        | 'DialVerb'
        | 'Conference'
        | 'OutboundAPI'
        | 'Trunking'
        | 'RecordVerb'
        | 'StartCallRecordingAPI'
        | 'StartConferenceRecordingAPI';
      /**
       * @description The timestamp of when the recording was started.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      start_time?: string;
      /**
       * @description The status of the recording.
       * @example completed
       * @enum {string}
       */
      status?: 'processing' | 'absent' | 'completed' | 'deleted';
      /**
       * @description A list of related resources identified by their relative URIs.
       * @example {
       *       "transcriptions": null
       *     }
       */
      subresource_uris?: Record<string, never>;
      /**
       * @description The relative URI for this recording.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings/136285da-4b74-46f1-a016-fe2982fa77c3.json
       */
      uri?: string;
    };
    /**
     * Multiple conference recording resources
     * @example {
     *       "participants": [],
     *       "end": 0,
     *       "first_page_uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Recordings.json?page=0&pagesize=20",
     *       "next_page_uri": null,
     *       "page": 0,
     *       "page_size": 20,
     *       "start": 0,
     *       "uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Recordings.json?page=0&pagesize=20"
     *     }
     */
    ConferenceRecordingResourceIndex: {
      recordings?: components['schemas']['ConferenceRecordingResource'][];
      /**
       * @description The number of the last element on the page, zero-indexed.
       * @example 19
       */
      end?: number;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Recordings.json?page=0&pagesize=20
       * @example accepted
       */
      first_page_uri?: string;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Recordings.json?Page=1&PageSize=1&PageToken=MTY4AjgyNDkwNzIxMQ
       * @example accepted
       */
      next_page_uri?: string;
      /**
       * @description Current page number, zero-indexed.
       * @example 0
       */
      page?: number;
      /**
       * @description The number of items on the page
       * @example 20
       */
      page_size?: number;
      /**
       * @description The number of the first element on the page, zero-indexed.
       * @example 0
       */
      start?: number;
      /**
       * @description The URI of the current page.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Recordings.json?Page=0&PageSize=1
       */
      uri?: string;
    };
    /**
     * Conference Recording Saved
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.recording.saved",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "channels": "single",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "format": "mp3",
     *         "public_recording_urls": {
     *           "mp3": "http://example.com/recording.mp3",
     *           "wav": "http://example.com/recording.wav"
     *         },
     *         "recording_ended_at": "2018-02-02T22:20:27.521992Z",
     *         "recording_id": "4577f9a2-cf0e-44f3-ac57-9f95fb03fa47",
     *         "recording_started_at": "2021-05-11T10:17:03.692107Z",
     *         "recording_urls": {
     *           "mp3": "http://example.com/recording.mp3",
     *           "wav": "http://example.com/recording.wav"
     *         }
     *       }
     *     }
     */
    ConferenceRecordingSaved: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.recording.saved
       * @enum {string}
       */
      event_type?: 'conference.recording.saved';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Participant's call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Whether recording was recorded in `single` or `dual` channel.
         * @example single
         * @enum {string}
         */
        channels?: 'single' | 'dual';
        /**
         * Format: uuid
         * @description ID of the conference that is being recorded.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description The audio file format used when storing the call recording. Can be either `mp3` or `wav`.
         * @example mp3
         * @enum {string}
         */
        format?: 'wav' | 'mp3';
        /** @description Recording URLs in requested format. The URL is valid for as long as the file exists. For security purposes, this feature is activated on a per request basis.  Please contact customer support with your Account ID to request activation. */
        public_recording_urls?: {
          /**
           * @description Recording URL in requested `mp3` format.
           * @example http://example.com/recording.mp3
           */
          mp3?: string | null;
          /**
           * @description Recording URL in requested `wav` format.
           * @example http://example.com/recording.wav
           */
          wav?: string | null;
        };
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when recording ended.
         * @example 2018-02-02T22:25:27.521992Z
         */
        recording_ended_at?: string;
        /**
         * Format: uuid
         * @description ID of the conference recording.
         * @example 4577f9a2-cf0e-44f3-ac57-9f95fb03fa47
         */
        recording_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when recording started.
         * @example 2018-02-02T22:20:27.521992Z
         */
        recording_started_at?: string;
        /** @description Recording URLs in requested format. These URLs are valid for 10 minutes. After 10 minutes, you may retrieve recordings via API using Reports -> Call Recordings documentation, or via Mission Control under Reporting -> Recordings. */
        recording_urls?: {
          /**
           * @description Recording URL in requested `mp3` format.
           * @example http://example.com/recording.mp3
           */
          mp3?: string | null;
          /**
           * @description Recording URL in requested `wav` format.
           * @example http://example.com/recording.wav
           */
          wav?: string | null;
        };
      };
    };
    /** Conference Recording Saved Event */
    ConferenceRecordingSavedEvent: {
      data?: components['schemas']['ConferenceRecordingSaved'];
    };
    /**
     * Conference resource
     * @example {
     *       "account_sid": "4e71926f-8f13-450e-b91c-23c2ef786aa6",
     *       "api_version": "v2/texml",
     *       "call_sid_ending_conference": null,
     *       "date_created": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "date_updated": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "friendly_name": "weekly_review_call",
     *       "reason_conference_ended": null,
     *       "region": "dc2",
     *       "sid": "cd5a70f4-759b-4d5e-9c06-88c00f16f3c1",
     *       "status": "in-progress",
     *       "subresource_uris": {
     *         "participants": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Participants.json",
     *         "recordings": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Recordings.json"
     *       },
     *       "uri": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1.json"
     *     }
     */
    ConferenceResource: {
      /**
       * @description The id of the account the resource belongs to.
       * @example 61bf923e-5e4d-4595-a110-56190ea18a1b
       */
      account_sid?: string;
      /**
       * @description The version of the API that was used to make the request.
       * @example v2/texml
       */
      api_version?: string;
      /**
       * @description Caller ID, if present.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      call_sid_ending_conference?: string;
      /**
       * @description The timestamp of when the resource was created.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_created?: string;
      /**
       * @description The timestamp of when the resource was last updated.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_updated?: string;
      /**
       * @description A string that you assigned to describe this conference room.
       * @example weekly_review_call
       */
      friendly_name?: string;
      /**
       * @description The reason why a conference ended. When a conference is in progress, will be null.
       * @example time-exceeded
       * @enum {string}
       */
      reason_conference_ended?:
        | 'participant-with-end-conference-on-exit-left'
        | 'last-participant-left'
        | 'conference-ended-via-api'
        | 'time-exceeded';
      /**
       * @description A string representing the region where the conference is hosted.
       * @example dc2
       */
      region?: string;
      /**
       * @description The unique identifier of the conference.
       * @example cd5a70f4-759b-4d5e-9c06-88c00f16f3c1
       */
      sid?: string;
      /**
       * @description The status of this conference.
       * @example in-progress
       * @enum {string}
       */
      status?: 'init' | 'in-progress' | 'completed';
      /**
       * @description A list of related resources identified by their relative URIs.
       * @example {
       *       "participants": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Participants.json",
       *       "recordings": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Recordings.json"
       *     }
       */
      subresource_uris?: Record<string, never>;
      /**
       * @description The relative URI for this conference.
       * @example /v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1.json
       */
      uri?: string;
    };
    /**
     * Multiple conference resources
     * @example {
     *       "conferences": [],
     *       "end": 0,
     *       "first_page_uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences.json?Page=0&PageSize=1",
     *       "next_page_uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences.json?Page=1&PageSize=1&PageToken=MTY4AjgyNDkwNzIxMQ",
     *       "page": 0,
     *       "page_size": 1,
     *       "start": 0,
     *       "uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences.json?Page=0&PageSize=1"
     *     }
     */
    ConferenceResourceIndex: {
      conferences?: components['schemas']['ConferenceResource'][];
      /**
       * @description The number of the last element on the page, zero-indexed.
       * @example 19
       */
      end?: number;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences.json?Page=0&PageSize=1
       * @example accepted
       */
      first_page_uri?: string;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences.json?Page=1&PageSize=1&PageToken=MTY4AjgyNDkwNzIxMQ
       * @example accepted
       */
      next_page_uri?: string;
      /**
       * @description Current page number, zero-indexed.
       * @example 0
       */
      page?: number;
      /**
       * @description The number of items on the page
       * @example 20
       */
      page_size?: number;
      /**
       * @description The number of the first element on the page, zero-indexed.
       * @example 0
       */
      start?: number;
      /**
       * @description The URI of the current page.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences.json?Page=0&PageSize=1
       */
      uri?: string;
    };
    /**
     * Format: uuid
     * @example cd5a70f4-759b-4d5e-9c06-88c00f16f3c1
     */
    ConferenceSid: string | null;
    /**
     * Conference Speak Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.speak.ended",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceSpeakEnded: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.speak.ended
       * @enum {string}
       */
      event_type?: 'conference.speak.ended';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Speak Ended Event */
    ConferenceSpeakEndedEvent: {
      data?: components['schemas']['ConferenceSpeakEnded'];
    };
    /**
     * Conference Speak Request
     * @example {
     *       "call_control_ids": [
     *         "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg"
     *       ],
     *       "payload": "Say this to participants",
     *       "payload_type": "text",
     *       "voice": "female",
     *       "language": "en-US",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    ConferenceSpeakRequest: {
      /** @description Call Control IDs of participants who will hear the spoken text. When empty all participants will hear the spoken text. */
      call_control_ids?: string[];
      /**
       * @description The text or SSML to be converted into speech. There is a 3,000 character limit.
       * @example Say this to participants
       */
      payload: string;
      /**
       * @description The type of the provided payload. The payload can either be plain text, or Speech Synthesis Markup Language (SSML).
       * @default text
       * @example ssml
       * @enum {string}
       */
      payload_type: 'text' | 'ssml';
      /**
       * @description The gender of the voice used to speak back the text or the specific Amazon Polly voice to be used in the form of `Polly.<voice>`, e.g. `Polly.Brian`. All standard Amazon Polly voices are supported.
       * @example female
       * @enum {string}
       */
      voice: 'male' | 'female';
      /**
       * @description The language you want spoken. This parameter is ignored when a `Polly.*` voice is specified.
       * @example en-US
       * @enum {string}
       */
      language?:
        | 'arb'
        | 'cmn-CN'
        | 'cy-GB'
        | 'da-DK'
        | 'de-DE'
        | 'en-AU'
        | 'en-GB'
        | 'en-GB-WLS'
        | 'en-IN'
        | 'en-US'
        | 'es-ES'
        | 'es-MX'
        | 'es-US'
        | 'fr-CA'
        | 'fr-FR'
        | 'hi-IN'
        | 'is-IS'
        | 'it-IT'
        | 'ja-JP'
        | 'ko-KR'
        | 'nb-NO'
        | 'nl-NL'
        | 'pl-PL'
        | 'pt-BR'
        | 'pt-PT'
        | 'ro-RO'
        | 'ru-RU'
        | 'sv-SE'
        | 'tr-TR';
      /**
       * @description Use this field to avoid execution of duplicate commands. Telnyx will ignore subsequent commands with the same `command_id` as one that has already been executed.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Conference Speak Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "conference.speak.started",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "creator_call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "conference_id": "428c31b6-abf3-3bc1-b7f4-5013ef9657c1",
     *         "occured_at": "2018-02-02T22:25:27.521Z"
     *       }
     *     }
     */
    ConferenceSpeakStarted: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example conference.speak.started
       * @enum {string}
       */
      event_type?: 'conference.speak.started';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      payload?: {
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call session that started the conference.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        creator_call_session_id?: string;
        /**
         * @description ID of the conference the text was spoken in.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        conference_id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521Z
         */
        occurred_at?: string;
      };
    };
    /** Conference Speak Started Event */
    ConferenceSpeakStartedEvent: {
      data?: components['schemas']['ConferenceSpeakStarted'];
    };
    /** Conference Stop Request */
    ConferenceStopRequest: {
      /** @description List of call control ids identifying participants the audio file should stop be played to. If not given, the audio will be stoped to the entire conference. */
      call_control_ids?: string[];
    };
    /**
     * Conference Unhold Request
     * @example {
     *       "call_control_ids": [
     *         "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg"
     *       ]
     *     }
     */
    ConferenceUnholdRequest: {
      /** @description List of unique identifiers and tokens for controlling the call. Enter each call control ID to be unheld. */
      call_control_ids: string[];
    };
    /**
     * Conference Unmute Request
     * @example {
     *       "call_control_ids": [
     *         "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg"
     *       ]
     *     }
     */
    ConferenceUnmuteRequest: {
      /** @description List of unique identifiers and tokens for controlling the call. Enter each call control ID to be unmuted. When empty all participants will be unmuted. */
      call_control_ids?: string[];
    };
    /**
     * Connection
     * @example {
     *       "id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "record_type": "ip_connection",
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "outbound_voice_profile_id": "1293384261075731499"
     *     }
     */
    Connection: {
      /**
       * Format: int64
       * @description Identifies the specific resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example ip_connection
       */
      record_type?: string;
      /**
       * @description Defaults to true
       * @example true
       */
      active?: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      /** @example string */
      connection_name?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent.
       * @default null
       * @example https://example.com
       */
      webhook_event_url: string | null;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
    };
    /**
     * Connection Active
     * @description Specifies whether the connection can be used.
     * @default true
     * @example false
     */
    ConnectionActive: boolean;
    /**
     * Android Push Credential Id
     * @description The uuid of the push credential for Android
     * @default null
     * @example 06b09dfd-7154-4980-8b75-cebf7a9d4f8e
     */
    ConnectionAndroidPushCredentialId: string | null;
    /**
     * @description The ID of the connection used to send the fax.
     * @example 234423
     */
    ConnectionId: string;
    /**
     * Ios Push Credential Id
     * @description The uuid of the push credential for Ios
     * @default null
     * @example ec0c8e5d-439e-4620-a0c1-9d9c8d02a836
     */
    ConnectionIosPushCredentialId: string | null;
    /**
     * Connection Name
     * @description A user-assigned name to help manage the connection.
     * @example office-connection
     */
    ConnectionName: string;
    /**
     * Connection RTCP Settings
     * @example {
     *       "port": "rtcp-mux",
     *       "capture_enabled": true,
     *       "report_frequency_secs": 10
     *     }
     */
    ConnectionRtcpSettings: {
      /**
       * @description RTCP port by default is rtp+1, it can also be set to rtcp-mux
       * @default rtp+1
       * @enum {unknown}
       */
      port: 'rtcp-mux' | 'rtp+1';
      /**
       * @description BETA - Enable the capture and storage of RTCP messages to create QoS reports on the Telnyx Mission Control Portal.
       * @default false
       * @example true
       */
      capture_enabled: boolean;
      /**
       * @description RTCP reports are sent to customers based on the frequency set. Frequency is in seconds and it can be set to values from 5 to 3000 seconds.
       * @default 5
       * @example 10
       */
      report_frequency_secs: number;
    };
    /**
     * ConsumedData
     * @description Represents the amount of data consumed.
     */
    ConsumedData: {
      /**
       * @default MB
       * @example MB
       */
      unit: string;
      /**
       * Format: decimal
       * @example 2048.1
       */
      amount?: string;
    };
    /**
     * Format: binary
     * @description The file you want to upload. The maximum allowed size is 20 MB. contents and media_name/media_url can't be submitted together.
     */
    Contents: string;
    /** @example {
     *       "upfront_cost": "3.21",
     *       "monthly_cost": "6.54",
     *       "currency": "USD"
     *     } */
    CostInformation: {
      /** @example 3.21 */
      upfront_cost?: string;
      /** @example 6.54 */
      monthly_cost?: string;
      /**
       * @description The ISO 4217 code for the currency.
       * @example USD
       */
      currency?: string;
    };
    /** @example {
     *       "United States of America": {
     *         "code": "US",
     *         "numbers": true,
     *         "features": [
     *           "hd_voice",
     *           "emergency",
     *           "voice",
     *           "mms",
     *           "fax",
     *           "sms",
     *           "international_sms"
     *         ],
     *         "phone_number_type": [
     *           "local",
     *           "local",
     *           "local",
     *           "local",
     *           "toll_free"
     *         ],
     *         "reservable": true,
     *         "quickship": true,
     *         "international_sms": true,
     *         "p2p": true,
     *         "local": {
     *           "features": [
     *             "hd_voice",
     *             "voice",
     *             "international_sms",
     *             "mms",
     *             "fax",
     *             "sms",
     *             "emergency"
     *           ],
     *           "reservable": true,
     *           "quickship": false,
     *           "international_sms": true,
     *           "p2p": true
     *         },
     *         "toll_free": {
     *           "features": [
     *             "voice",
     *             "mms",
     *             "fax",
     *             "sms",
     *             "emergency"
     *           ],
     *           "reservable": true,
     *           "quickship": true,
     *           "international_sms": false,
     *           "p2p": false
     *         },
     *         "mobile": {},
     *         "national": {},
     *         "inventory_coverage": true,
     *         "shared_cost": {}
     *       }
     *     } */
    CountryCoverage: {
      /** @description Country ISO code */
      code?: string;
      numbers?: boolean;
      /** @description Set of features supported */
      features?: string[];
      /** @description Phone number type */
      phone_number_type?: string[];
      /** @description Supports reservable */
      reservable?: boolean;
      /** @description Supports quickship */
      quickship?: boolean;
      international_sms?: boolean;
      p2p?: boolean;
      local?: {
        features?: string[];
        reservable?: boolean;
        quickship?: boolean;
        international_sms?: boolean;
        p2p?: boolean;
      };
      toll_free?: {
        features?: string[];
        reservable?: boolean;
        quickship?: boolean;
        international_sms?: boolean;
        p2p?: boolean;
      };
      mobile?: Record<string, never>;
      national?: Record<string, never>;
      /** @description Indicates whether country can be queried with inventory coverage endpoint */
      inventory_coverage?: boolean;
      shared_cost?: Record<string, never>;
    };
    /** Create Android Push Credential Request */
    CreateAndroidPushCredentialRequest: {
      /**
       * @description Type of mobile push credential. Should be <code>android</code> here
       * @enum {string}
       */
      type: 'android';
      /**
       * @description Private key file in JSON format
       * @example {
       *       "private_key": "BBBB0J56jd8kda:APA91vjb11BCjvxx3Jxja...",
       *       "client_email": "account@customer.org"
       *     }
       */
      project_account_json_file: Record<string, never>;
      /**
       * @description Alias to uniquely identify the credential
       * @example LucyAndroidCredential
       */
      alias: string;
    };
    /** CreateAssistantRequest */
    CreateAssistantRequest: {
      /** Name */
      name: string;
      /** Model */
      model: string;
      /**
       * Description
       * @default
       */
      description: string;
      /** Instructions */
      instructions: string;
      /** @description The `function` tool type follows the same schema as the [OpenAI Assistants API](https://platform.openai.com/docs/api-reference/assistants/createAssistant). The `retrieval` tool type is unique to Telnyx. You may pass a list of [embedded storage buckets](https://developers.telnyx.com/api/inference/inference-embedding/post-embedding) for retrieval-augmented generation. */
      tools?: (
        | components['schemas']['ChatCompletionToolParam']
        | components['schemas']['Retrieval']
      )[];
    };
    /** CreateBrand */
    CreateBrand: {
      /** @description Entity type behind the brand. This is the form of business establishment. */
      entityType: components['schemas']['EntityType'];
      /**
       * Displayname
       * @description Display name, marketing name, or DBA name of the brand.
       * @example ABC Mobile
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example ABC Inc.
       */
      companyName?: string;
      /**
       * Firstname
       * @description First name of business contact.
       * @example John
       */
      firstName?: string;
      /**
       * Lastname
       * @description Last name of business contact.
       * @example Smith
       */
      lastName?: string;
      /**
       * Ein
       * @description (Required for Non-profit) Government assigned corporate tax ID. EIN is 9-digits in U.S.
       * @example 111111111
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +12024567890
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example New York
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example NY
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 10001
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example ABC
       */
      stockSymbol?: string;
      /**
       * @description (Required for public company) stock exchange.
       * @example NASDAQ
       */
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example http://www.abcmobile.com
       */
      website?: string;
      /** @description Vertical or industry segment of the brand. */
      vertical: components['schemas']['Vertical'];
      /**
       * Isreseller
       * @default false
       */
      isReseller: boolean;
      /**
       * Mock
       * @description Mock brand for testing purposes
       * @default false
       */
      mock: boolean;
      /**
       * Mobilephone
       * @description Valid mobile phone number in e.164 international format.
       * @example +12024567890
       */
      mobilePhone?: string;
      /**
       * BusinessContactEmail
       * @description Business contact email.
       *
       *     Required if `entityType` is `PUBLIC_PROFIT`.
       * @example name@example.com
       */
      businessContactEmail?: string;
      /**
       * WebhookURL
       * @description Webhook URL for brand status updates.
       * @example https://webhook.com/67ea78a8-9f32-4d04-b62d-f9502e8e5f93
       */
      webhookURL?: string;
      /**
       * WebhookFailoverURL
       * @description Webhook failover URL for brand status updates.
       * @example https://webhook.com/9010a453-4df8-4be6-a551-1070892888d6
       */
      webhookFailoverURL?: string;
    };
    CreateBucketRequest: {
      LocationConstraint?: string;
    };
    /**
     * Create Call Control Application Request
     * @example {
     *       "application_name": "call-router",
     *       "webhook_event_url": "https://example.com",
     *       "active": false,
     *       "anchorsite_override": "\"Latency\"",
     *       "dtmf_type": "Inband",
     *       "first_command_timeout": true,
     *       "first_command_timeout_secs": 10,
     *       "inbound": {
     *         "channel_limit": 10,
     *         "shaken_stir_enabled": true,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       },
     *       "webhook_api_version": "1",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_timeout_secs": 25
     *     }
     */
    CreateCallControlApplicationRequest: {
      /**
       * @description A user-assigned name to help manage the application.
       * @example call-router
       */
      application_name: string;
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url: string;
      /**
       * @description Specifies whether the connection can be used.
       * @default true
       */
      active: boolean;
      /**
       * @description <code>Latency</code> directs Telnyx to route media through the site with the lowest round-trip time to the user's connection. Telnyx calculates this time using ICMP ping messages. This can be disabled by specifying a site to handle all media.
       *
       * @default "Latency"
       * @example "Amsterdam, Netherlands"
       * @enum {string}
       */
      anchorsite_override:
        | '"Latency"'
        | '"Chicago, IL"'
        | '"Ashburn, VA"'
        | '"San Jose, CA"';
      /**
       * @description Sets the type of DTMF digits sent from Telnyx to this Connection. Note that DTMF digits sent to Telnyx will be accepted in all formats.
       * @default RFC 2833
       * @example Inband
       * @enum {string}
       */
      dtmf_type: 'RFC 2833' | 'Inband' | 'SIP INFO';
      /**
       * @description Specifies whether calls to phone numbers associated with this connection should hangup after timing out.
       * @default false
       * @example true
       */
      first_command_timeout: boolean;
      /**
       * @description Specifies how many seconds to wait before timing out a dial command.
       * @default 30
       * @example 10
       */
      first_command_timeout_secs: number;
      inbound?: components['schemas']['CallControlApplicationInbound'];
      outbound?: components['schemas']['CallControlApplicationOutbound'];
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
    };
    /**
     * Create Conference Request
     * @example {
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "name": "Business",
     *       "beep_enabled": "always",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "duration_minutes": 5,
     *       "hold_audio_url": "http://www.example.com/audio.wav",
     *       "start_conference_on_create": false,
     *       "max_participants": 250
     *     }
     */
    CreateConferenceRequest: {
      /**
       * @description Unique identifier and token for controlling the call
       * @example v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQczRrZvZakpWxBlpw48KyZQ==
       */
      call_control_id: string;
      /**
       * @description Name of the conference
       * @example Business
       */
      name: string;
      /**
       * @description Whether a beep sound should be played when participants join and/or leave the conference.
       * @default never
       * @example on_exit
       * @enum {string}
       */
      beep_enabled: 'always' | 'never' | 'on_enter' | 'on_exit';
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string. The client_state will be updated for the creator call leg and will be used for all webhooks related to the created conference.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Toggle background comfort noise.
       * @default true
       * @example false
       */
      comfort_noise: boolean;
      /**
       * @description Use this field to avoid execution of duplicate commands. Telnyx will ignore subsequent commands with the same `command_id` as one that has already been executed.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Time length (minutes) after which the conference will end.
       * @example 5
       */
      duration_minutes?: number;
      /**
       * @description The URL of a file to be played to participants joining the conference. The URL can point to either a WAV or MP3 file. hold_media_name and hold_audio_url cannot be used together in one request. Takes effect only when "start_conference_on_create" is set to "false".
       * @example http://example.com/message.wav
       */
      hold_audio_url?: string;
      /**
       * @description The media_name of a file to be played to participants joining the conference. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file. Takes effect only when "start_conference_on_create" is set to "false".
       * @example my_media_uploaded_to_media_storage_api
       */
      hold_media_name?: string;
      /**
       * @description The maximum number of active conference participants to allow. Must be between 2 and 800. Defaults to 250
       * @example 3
       */
      max_participants?: number;
      /**
       * @description Whether the conference should be started on creation. If the conference isn't started all participants that join are automatically put on hold. Defaults to "true".
       * @example false
       */
      start_conference_on_create?: boolean;
    };
    /**
     * Create Credential Connection Request
     * @example {
     *       "active": true,
     *       "password": "my123secure456password789",
     *       "user_name": "myusername123",
     *       "anchorsite_override": "Latency",
     *       "connection_name": "my name",
     *       "sip_uri_calling_preference": " disabled",
     *       "default_on_hold_comfort_noise_enabled": false,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_seconds": 10
     *       },
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": "G722",
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 20,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "call_parking_enabled": true,
     *         "ani_override": "always",
     *         "channel_limit": 10,
     *         "instant_ringback_enabled": true,
     *         "generate_ringback_tone": true,
     *         "localization": "US",
     *         "t38_reinvite_source": "customer",
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    CreateCredentialConnectionRequest: {
      /** @description Defaults to true */
      active?: boolean;
      /**
       * @description The user name to be used as part of the credentials. Must be 4-32 characters long and alphanumeric values only (no spaces or special characters).
       * @example myusername123
       */
      user_name: string;
      /**
       * @description The password to be used as part of the credentials. Must be 8 to 128 characters long.
       * @example my123secure456password789
       */
      password: string;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name: components['schemas']['ConnectionName'];
      /**
       * @description This feature enables inbound SIP URI calls to your Credential Auth Connection. If enabled for all (unrestricted) then anyone who calls the SIP URI <your-username>@telnyx.com will be connected to your Connection. You can also choose to allow only calls that are originated on any Connections under your account (internal).
       * @enum {string}
       */
      sip_uri_calling_preference?: 'disabled' | 'unrestricted' | 'internal';
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default false
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      ios_push_credential_id?: components['schemas']['ConnectionIosPushCredentialId'];
      android_push_credential_id?: components['schemas']['ConnectionAndroidPushCredentialId'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1, v2 or texml. Note - texml can only be set when the outbound object parameter call_parking_enabled is included and set to true.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2' | 'texml';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['CredentialInbound'];
      outbound?: components['schemas']['CredentialOutbound'];
    };
    CreateDocServiceDocumentRequest:
      | components['schemas']['DocServiceDocumentUploadURL']
      | components['schemas']['DocServiceDocumentUploadInline'];
    /**
     * Create External Connection Request
     * @example {
     *       "external_sip_connection": "zoom",
     *       "active": false,
     *       "outbound": {
     *         "outbound_voice_profile_id": "1911630617284445511"
     *       }
     *     }
     */
    CreateExternalConnectionRequest: {
      active?: components['schemas']['ConnectionActive'];
      external_sip_connection: components['schemas']['ExternalSipConnectionZoomOnly'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      inbound?: {
        /**
         * @description When set, this will limit the number of concurrent inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
      };
      outbound?: {
        /**
         * @description When set, this will limit the number of concurrent outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
    };
    /**
     * Create Upload Request
     * @example {
     *       "number_ids": [
     *         "3920457616934164700",
     *         "3920457616934164701",
     *         "3920457616934164702",
     *         "3920457616934164703"
     *       ],
     *       "usage": "first_party_app_assignment",
     *       "location_id": "67ea7693-9cd5-4a68-8c76-abb3aa5bf5d2"
     *     }
     */
    CreateExternalConnectionUploadRequest: {
      number_ids?: string[];
      /**
       * @description The use case of the upload request. NOTE: `calling_user_assignment` is not supported for toll free numbers.
       * @enum {string}
       */
      usage?: 'calling_user_assignment' | 'first_party_app_assignment';
      additional_usages?: (
        | 'calling_user_assignment'
        | 'first_party_app_assignment'
      )[];
      /**
       * Format: uuid
       * @description Identifies the location to assign all phone numbers to.
       */
      location_id?: string;
      /**
       * Format: uuid
       * @description Identifies the civic address to assign all phone numbers to.
       */
      civic_address_id?: string;
    };
    /**
     * Create Fax Application Request
     * @example {
     *       "application_name": "fax-router",
     *       "active": false,
     *       "anchorsite_override": "Amsterdam, Netherlands",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_timeout_secs": 25,
     *       "inbound": {
     *         "channel_limit": 10,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    CreateFaxApplicationRequest: {
      application_name: components['schemas']['ApplicationName'];
      active?: components['schemas']['ConnectionActive'];
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      webhook_event_url: components['schemas']['WebhookEventUrl'];
      webhook_event_failover_url?: components['schemas']['WebhookEventFailoverUrl'];
      webhook_timeout_secs?: components['schemas']['WebhookTimeoutSecs'];
      inbound?: {
        /**
         * @description When set, this will limit the number of concurrent inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        /**
         * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
         * @default null
         * @example example
         */
        sip_subdomain: string;
        /**
         * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
         * @default from_anyone
         * @example only_my_connections
         * @enum {string}
         */
        sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      };
      outbound?: {
        /**
         * @description When set, this will limit the number of concurrent outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
    };
    /**
     * Create FQDN Connection Request
     * @example {
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "transport_protocol": "UDP",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_secs": 10
     *       },
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": [
     *           "G722"
     *         ],
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "sip_region": "US",
     *         "sip_subdomain": "string",
     *         "sip_subdomain_receive_settings": "only_my_connections",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 10,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "ani_override": "+1234567890",
     *         "ani_override_type": "always",
     *         "call_parking_enabled": true,
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "instant_ringback_enabled": true,
     *         "ip_authentication_method": "token",
     *         "ip_authentication_token": "aBcD1234",
     *         "localization": "string",
     *         "outbound_voice_profile_id": "1293384261075731499",
     *         "t38_reinvite_source": "customer",
     *         "tech_prefix": "0123",
     *         "encrypted_media": "string",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 10
     *       }
     *     }
     */
    CreateFqdnConnectionRequest: {
      /**
       * @description Defaults to true
       * @default true
       */
      active: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name: components['schemas']['ConnectionName'];
      transport_protocol?: components['schemas']['FqdnConnectionTransportProtocol'];
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description When enabled, the connection will be created for Microsoft Teams Direct Routing. A *.mstsbc.telnyx.tech FQDN will be created for the connection automatically.
       * @default false
       */
      microsoft_teams_sbc: boolean;
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      ios_push_credential_id?: components['schemas']['ConnectionIosPushCredentialId'];
      android_push_credential_id?: components['schemas']['ConnectionAndroidPushCredentialId'];
      webhook_event_url?: components['schemas']['WebhookEventUrl'];
      webhook_event_failover_url?: components['schemas']['WebhookEventFailoverUrl'];
      webhook_api_version?: components['schemas']['WebhookApiVersion'];
      webhook_timeout_secs?: components['schemas']['WebhookTimeoutSecs'];
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['InboundFqdn'];
      outbound?: components['schemas']['OutboundFqdn'];
    };
    /**
     * Create Fqdn Request
     * @example {
     *       "connection_id": "1516447646313612565",
     *       "fqdn": "example.com",
     *       "port": 8080,
     *       "dns_record_type": "a"
     *     }
     */
    CreateFqdnRequest: {
      /** @description ID of the FQDN connection to which this IP should be attached. */
      connection_id: string;
      /**
       * @description FQDN represented by this resource.
       * @example example.com
       */
      fqdn: string;
      /**
       * @description Port to use when connecting to this FQDN.
       * @default 5060
       * @example 5060
       */
      port: number;
      /**
       * @description The DNS record type for the FQDN. For cases where a port is not set, the DNS record type must be 'srv'. For cases where a port is set, the DNS record type must be 'a'. If the DNS record type is 'a' and a port is not specified, 5060 will be used.
       * @example a
       */
      dns_record_type: string;
    };
    /** @example {
     *       "from": "+13125551234",
     *       "to": [
     *         "+18655551234",
     *         "+14155551234"
     *       ],
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media_urls": [
     *         "http://example.com"
     *       ],
     *       "webhook_url": "http://example.com/webhooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "use_profile_webhooks": true
     *     } */
    CreateGroupMMSMessageRequest: {
      /**
       * Format: address
       * @description Phone number, in +E.164 format, used to send the message.
       */
      from: string;
      /** @description A list of destinations. No more than 8 destinations are allowed. */
      to: components['schemas']['ToNumber'][];
      /** @description Message body (i.e., content) as a non-empty string. */
      text?: string;
      /** @description Subject of multimedia message */
      subject?: string;
      /** @description A list of media URLs. The total media size must be less than 1 MB. */
      media_urls?: string[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string;
      /**
       * @description If the profile this number is associated with has webhooks, use them for delivery notifications. If webhooks are also specified on the message itself, they will be attempted first, then those on the profile.
       * @default true
       */
      use_profile_webhooks: boolean;
    };
    /**
     * Create Inbound Ip Request
     * @example {
     *       "ani_number_format": "+E.164",
     *       "dnis_number_format": "+e164",
     *       "codecs": "G722",
     *       "default_routing_method": "sequential",
     *       "channel_limit": 10,
     *       "generate_ringback_tone": true,
     *       "isup_headers_enabled": true,
     *       "prack_enabled": true,
     *       "privacy_zone_enabled": true,
     *       "sip_compact_headers_enabled": true,
     *       "sip_region": "US",
     *       "sip_subdomain": "test",
     *       "sip_subdomain_receive_settings": "only_my_connections",
     *       "timeout_1xx_secs": 10,
     *       "timeout_2xx_secs": 20,
     *       "shaken_stir_enabled": true
     *     }
     */
    CreateInboundIpRequest: {
      /**
       * @description This setting allows you to set the format with which the caller's number (ANI) is sent for inbound phone calls.
       * @default E.164-national
       * @enum {string}
       */
      ani_number_format:
        | '+E.164'
        | 'E.164'
        | '+E.164-national'
        | 'E.164-national';
      /**
       * @default e164
       * @enum {string}
       */
      dnis_number_format: '+e164' | 'e164' | 'national' | 'sip_username';
      /**
       * @description Defines the list of codecs that Telnyx will send for inbound calls to a specific number on your portal account, in priority order. This only works when the Connection the number is assigned to uses Media Handling mode: default. OPUS and H.264 codecs are available only when using TCP or TLS transport for SIP.
       * @default [
       *       "G722",
       *       "G711U",
       *       "G711A",
       *       "G729",
       *       "OPUS",
       *       "H.264"
       *     ]
       */
      codecs: string[];
      /**
       * @description Default routing method to be used when a number is associated with the connection. Must be one of the routing method types or left blank, other values are not allowed.
       * @enum {string}
       */
      default_routing_method?: 'sequential' | 'round-robin';
      /**
       * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
       * @default null
       */
      channel_limit: number;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description When set, inbound phone calls will receive ISUP parameters via SIP headers. (Only when available and only when using TCP or TLS transport.)
       * @default false
       */
      isup_headers_enabled: boolean;
      /**
       * @description Enable PRACK messages as defined in RFC3262.
       * @default false
       */
      prack_enabled: boolean;
      /**
       * @description By default, Telnyx does not send caller-id information when the caller has chosen to hide this information. When this option is enabled, Telnyx will send the SIP header Privacy:id plus the caller-id information so that the receiver side can choose when to hide it.
       * @default false
       */
      privacy_zone_enabled: boolean;
      /**
       * @description Defaults to true.
       * @default true
       */
      sip_compact_headers_enabled: boolean;
      /**
       * @description Selects which `sip_region` to receive inbound calls from. If null, the default region (US) will be used.
       * @default US
       * @enum {string}
       */
      sip_region: 'US' | 'Europe' | 'Australia';
      /** @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls. */
      sip_subdomain?: string;
      /**
       * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
       * @enum {string}
       */
      sip_subdomain_receive_settings?: 'only_my_connections' | 'from_anyone';
      /**
       * @description Time(sec) before aborting if connection is not made.
       * @default 3
       */
      timeout_1xx_secs: number;
      /**
       * @description Time(sec) before aborting if call is unanswered (min: 1, max: 600).
       * @default 90
       */
      timeout_2xx_secs: number;
      /**
       * @description When enabled the SIP Connection will receive the Identity header with Shaken/Stir data in the SIP INVITE message of inbound calls, even when using UDP transport.
       * @default false
       */
      shaken_stir_enabled: boolean;
    };
    /** Create iOS push credential request */
    CreateIosPushCredentialRequest: {
      /**
       * @description Type of mobile push credential. Should be <code>ios</code> here
       * @enum {string}
       */
      type: 'ios';
      /**
       * @description Certificate as received from APNs
       * @example -----BEGIN CERTIFICATE----- MIIGVDCCBTKCAQEAsNlRJVZn9ZvXcECQm65czs... -----END CERTIFICATE-----
       */
      certificate: string;
      /**
       * @description Corresponding private key to the certificate as received from APNs
       * @example -----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAsNlRJVZn9ZvXcECQm65czs... -----END RSA PRIVATE KEY-----
       */
      private_key: string;
      /**
       * @description Alias to uniquely identify the credential
       * @example LucyIosCredential
       */
      alias: string;
    };
    /**
     * Create IP Connection Request
     * @example {
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "transport_protocol": "UDP",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": false,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_secs": 10
     *       },
     *       "inbound:": {
     *         "ani_number_format": "+E.164",
     *         "dns_number_format": "+e164",
     *         "codecs": "G722",
     *         "default_primary_ip_id": "192.168.0.0",
     *         "default_tertiary_ip_id": "192.168.0.0",
     *         "default_secondary_ip_id": "192.168.0.0",
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "sip_region": "US",
     *         "sip_subdomain": "test",
     *         "sip_subdomain_receive_settings": "only_my_connections",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 20,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "call_parking_enabled": true,
     *         "ani_override": "string",
     *         "ani_override_type": "always",
     *         "channel_limit": 10,
     *         "instant_ringback_enabled": true,
     *         "generate_ringback_tone": true,
     *         "localization": "string",
     *         "t38_reinvite_source": "customer",
     *         "tech_prefix": "string",
     *         "ip_authentication_method": "token",
     *         "ip_authentication_token": "string",
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    CreateIpConnectionRequest: {
      /**
       * @description Defaults to true
       * @example true
       */
      active?: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      /** @example string */
      connection_name?: string;
      /**
       * @description One of UDP, TLS, or TCP. Applies only to connections with IP authentication or FQDN authentication.
       * @default UDP
       * @example UDP
       * @enum {string}
       */
      transport_protocol: 'UDP' | 'TCP' | 'TLS';
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       * @example true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       * @example true
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       * @example false
       */
      onnet_t38_passthrough_enabled: boolean;
      ios_push_credential_id?: components['schemas']['ConnectionIosPushCredentialId'];
      android_push_credential_id?: components['schemas']['ConnectionAndroidPushCredentialId'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['CreateInboundIpRequest'];
      outbound?: components['schemas']['OutboundIp'];
    };
    /**
     * Create Ip Request
     * @example {
     *       "connection_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "ip_address": "192.168.0.0",
     *       "port": 5060
     *     }
     */
    CreateIpRequest: {
      /** @description ID of the IP Connection to which this IP should be attached. */
      connection_id?: string;
      /**
       * @description IP adddress represented by this resource.
       * @example 192.168.0.0
       */
      ip_address: string;
      /**
       * @description Port to use when connecting to this IP.
       * @default 5060
       * @example 5060
       */
      port: number;
    };
    /** @example {
     *       "from": "+18445550001",
     *       "to": "+13125550002",
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media_urls": [
     *         "http://example.com"
     *       ],
     *       "webhook_url": "http://example.com/webhooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "use_profile_webhooks": true,
     *       "type": "MMS"
     *     } */
    CreateLongCodeMessageRequest: {
      /**
       * Format: address
       * @description Phone number, in +E.164 format, used to send the message.
       */
      from: string;
      to: components['schemas']['ToNumber'];
      /** @description Message body (i.e., content) as a non-empty string.
       *
       *     **Required for SMS** */
      text?: string;
      /** @description Subject of multimedia message */
      subject?: string;
      /** @description A list of media URLs. The total media size must be less than 1 MB.
       *
       *     **Required for MMS** */
      media_urls?: string[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string;
      /**
       * @description If the profile this number is associated with has webhooks, use them for delivery notifications. If webhooks are also specified on the message itself, they will be attempted first, then those on the profile.
       * @default true
       */
      use_profile_webhooks: boolean;
      /**
       * @description The protocol for sending the message, either SMS or MMS.
       * @enum {string}
       */
      type?: 'SMS' | 'MMS';
      /**
       * @description Automatically detect if an SMS message is unusually long and exceeds a recommended limit of message parts.
       * @default false
       */
      auto_detect: boolean;
    };
    /**
     * Create Managed Account Request
     * @example {
     *       "email": "larry_cat_food@customer.org",
     *       "password": "3jVjLq!tMuWKyWx4NN*CvhnB",
     *       "business_name": "Larry's Cat Food Inc",
     *       "managed_account_allow_custom_pricing": false,
     *       "rollup_billing": false
     *     }
     */
    CreateManagedAccountRequest: {
      /**
       * @description The email address for the managed account. If not provided, the email address will be generated based on the email address of the manager account.
       * @example new_managed_account@customer.org
       */
      email?: string;
      /**
       * @description Password for the managed account. If a password is not supplied, the account will not be able to be signed into directly. (A password reset may still be performed later to enable sign-in via password.)
       * @example 3jVjLq!tMuWKyWx4NN*CvhnB
       */
      password?: string;
      /**
       * @description The name of the business for which the new managed account is being created, that will be used as the managed accounts's organization's name.
       * @example Larry's Cat Food Inc
       */
      business_name: string;
      /**
       * @description Boolean value that indicates if the managed account is able to have custom pricing set for it or not. If false, uses the pricing of the manager account. Defaults to false. This value may be changed after creation, but there may be time lag between when the value is changed and pricing changes take effect.
       * @example false
       */
      managed_account_allow_custom_pricing?: boolean;
      /**
       * @description Boolean value that indicates if the billing information and charges to the managed account "roll up" to the manager account. If true, the managed account will not have its own balance and will use the shared balance with the manager account. This value cannot be changed after account creation without going through Telnyx support as changes require manual updates to the account ledger. Defaults to false.
       * @example false
       */
      rollup_billing?: boolean;
    };
    /** @example {
     *       "from": "+18445550001",
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600000000",
     *       "to": "+18445550001",
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media_urls": [
     *         "http://example.com"
     *       ],
     *       "webhook_url": "http://example.com/webhooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "use_profile_webhooks": true,
     *       "type": "MMS"
     *     } */
    CreateMessageRequest: {
      /**
       * Format: address
       * @description Sending address (+E.164 formatted phone number, alphanumeric sender ID, or short code).
       *
       *     **Required if sending with a phone number, short code, or alphanumeric sender ID.**
       *
       */
      from?: string;
      /** @description Unique identifier for a messaging profile.
       *
       *     **Required if sending via number pool or with an alphanumeric sender ID.**
       *      */
      messaging_profile_id?: string;
      to: components['schemas']['ToNumber'];
      /** @description Message body (i.e., content) as a non-empty string.
       *
       *     **Required for SMS** */
      text?: string;
      /** @description Subject of multimedia message */
      subject?: string;
      /** @description A list of media URLs. The total media size must be less than 1 MB.
       *
       *     **Required for MMS** */
      media_urls?: string[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string;
      /**
       * @description If the profile this number is associated with has webhooks, use them for delivery notifications. If webhooks are also specified on the message itself, they will be attempted first, then those on the profile.
       * @default true
       */
      use_profile_webhooks: boolean;
      /**
       * @description The protocol for sending the message, either SMS or MMS.
       * @enum {string}
       */
      type?: 'SMS' | 'MMS';
      /**
       * @description Automatically detect if an SMS message is unusually long and exceeds a recommended limit of message parts.
       * @default false
       */
      auto_detect: boolean;
    };
    /** @example {
     *       "messaging_profile_id": "dc8f39ac-953d-4520-b93b-786ae87db0da",
     *       "phone_numbers": [
     *         "+18665550001",
     *         "+18665550002"
     *       ]
     *     } */
    CreateMessagingHostedNumberOrderRequest: {
      /** @description Phone numbers to be used for hosted messaging. */
      phone_numbers?: string[];
      /** @description Automatically associate the number with this messaging profile ID when the order is complete. */
      messaging_profile_id?: string;
    };
    /** @example {
     *       "name": "My name",
     *       "enabled": true,
     *       "webhook_url": "https://www.example.com/hooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "webhook_api_version": "2",
     *       "number_pool_settings": {
     *         "toll_free_weight": 10,
     *         "long_code_weight": 1,
     *         "skip_unhealthy": true,
     *         "sticky_sender": false,
     *         "geomatch": false
     *       },
     *       "url_shortener_settings": {
     *         "domain": "example.ex",
     *         "prefix": "",
     *         "replace_blacklist_only": true,
     *         "send_webhooks": false
     *       },
     *       "whitelisted_destinations": [
     *         "US"
     *       ]
     *     } */
    CreateMessagingProfileRequest: {
      /** @description A user friendly name for the messaging profile. */
      name: string;
      /** @description Destinations to which the messaging profile is allowed to send. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]` all destinations will be allowed. */
      whitelisted_destinations: string[];
      /**
       * @description Specifies whether the messaging profile is enabled or not.
       * @default true
       */
      enabled: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this messaging profile will be sent.
       * @default
       */
      webhook_url: string | null;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this messaging profile will be sent if sending to the primary URL fails.
       * @default
       */
      webhook_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1, v2, or a legacy 2010-04-01 format.
       * @default 2
       * @enum {string}
       */
      webhook_api_version: '1' | '2' | '2010-04-01';
      number_pool_settings?: components['schemas']['NumberPoolSettings'];
      url_shortener_settings?: components['schemas']['UrlShortenerSettings'];
      /** @description The alphanumeric sender ID to use when sending to destinations that require an alphanumeric sender ID. */
      alpha_sender?: string | null;
    };
    CreateMultiPartDocServiceDocumentRequest: {
      /**
       * Format: binary
       * @description The file you are uploading.
       */
      file?: string;
      /**
       * @description Optional reference string for customer tracking.
       * @example MY REF 001
       */
      customer_reference?: string;
    };
    /** @example {
     *       "starting_number": "+19705555000",
     *       "range": 10
     *     } */
    CreateNumberBlockOrderRequest: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example number_block_order */
      readonly record_type?: string;
      /**
       * Format: e164_phone_number
       * @description Starting phone number block
       * @example +19705555000
       */
      starting_number: string;
      /**
       * @description The phone number range included in the block.
       * @example 10
       */
      range: number;
      /**
       * @description The count of phone numbers in the number order.
       * @example 10
       */
      readonly phone_numbers_count?: number;
      /**
       * @description Identifies the connection associated with this phone number.
       * @example 346789098765567
       */
      connection_id?: string;
      /**
       * @description Identifies the messaging profile associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      messaging_profile_id?: string;
      /**
       * @description The status of the order.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number order was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
      /**
       * @description True if all requirements are met for every phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
      /**
       * @description Errors the reservation could happen upon
       * @example Number is already on hold
       */
      readonly errors?: string;
    };
    /** @example {
     *       "id": "387d1e31-a218-4375-8151-103f2d5e2d2c",
     *       "record_type": "number_order_document",
     *       "file_id": "1e3c5822-0362-4702-8e46-5a129f0d3976",
     *       "requirements_id": "36aaf27d-986b-493c-bd1b-de16af2e4292",
     *       "customer_reference": "MY REF 001",
     *       "requirement_type": "address_proof",
     *       "created_at": "2018-01-01T00:00:00.000000Z"
     *     } */
    CreateNumberOrderDocumentRequest: {
      /**
       * Format: uuid
       * @example 387d1e31-a218-4375-8151-103f2d5e2d2c
       */
      readonly id?: string;
      /** @example number_order_document */
      readonly record_type?: string;
      /**
       * @description The id of the file to associate as a number order document.
       * @example 1e3c5822-0362-4702-8e46-5a129f0d3976
       */
      file_id?: string;
      /**
       * @description Unique id for a requirement.
       * @example 36aaf27d-986b-493c-bd1b-de16af2e4292
       */
      requirements_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @enum {string} */
      readonly requirement_type?:
        | 'address_proof'
        | 'identification'
        | 'reg_form';
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order document was uploaded.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
    };
    /** @example {
     *       "phone_numbers": [
     *         {
     *           "phone_number": "+19705555098",
     *           "bundle_id": "bc8e4d67-33a0-4cbb-af74-7b58f05bd494"
     *         },
     *         {
     *           "phone_number": "+492111609539",
     *           "requirement_group_id": "dbbd94ee-9079-488f-80ba-f566b247fd79"
     *         }
     *       ],
     *       "connection_id": "346789098765567",
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600",
     *       "billing_group_id": "abc85f64-5717-4562-b3fc-2c9600",
     *       "customer_reference": "MY REF 001"
     *     } */
    CreateNumberOrderRequest: {
      phone_numbers?: {
        /**
         * @description e164_phone_number
         * @example +19705555098
         */
        phone_number: string;
        /**
         * @description ID of requirement group to use to satisfy number requirements
         * @example dbbd94ee-9079-488f-80ba-f566b247fd7
         */
        requirement_group_id?: string;
        /**
         * @description ID of bundle to associate the number to
         * @example bc8e4d67-33a0-4cbb-af74-7b58f05bd494
         */
        bundle_id?: string;
      }[];
      /**
       * @description Identifies the connection associated with this phone number.
       * @example 346789098765567
       */
      connection_id?: string;
      /**
       * @description Identifies the messaging profile associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      messaging_profile_id?: string;
      /**
       * @description Identifies the billing group associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      billing_group_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
    };
    /** @example {
     *       "from": "+18445550001",
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600000000",
     *       "to": [
     *         "+13125550002"
     *       ],
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media_urls": [
     *         "http://example.com"
     *       ],
     *       "webhook_url": "http://example.com/webhooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "use_profile_webhooks": true,
     *       "type": "MMS"
     *     } */
    CreateNumberPoolMessageRequest: {
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id: string;
      to: components['schemas']['ToNumber'];
      /** @description Message body (i.e., content) as a non-empty string.
       *
       *     **Required for SMS** */
      text?: string;
      /** @description Subject of multimedia message */
      subject?: string;
      /** @description A list of media URLs. The total media size must be less than 1 MB.
       *
       *     **Required for MMS** */
      media_urls?: string[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string;
      /**
       * @description If the profile this number is associated with has webhooks, use them for delivery notifications. If webhooks are also specified on the message itself, they will be attempted first, then those on the profile.
       * @default true
       */
      use_profile_webhooks: boolean;
      /**
       * @description The protocol for sending the message, either SMS or MMS.
       * @enum {string}
       */
      type?: 'SMS' | 'MMS';
      /**
       * @description Automatically detect if an SMS message is unusually long and exceeds a recommended limit of message parts.
       * @default false
       */
      auto_detect: boolean;
    };
    /** @example {
     *       "id": "12ade33a-21c0-473b-b055-b3c836e1c292",
     *       "record_type": "number_reservation",
     *       "phone_numbers": [
     *         {
     *           "id": "12ade33a-21c0-473b-b055-b3c836e1c292",
     *           "record_type": "reserved_phone_number",
     *           "phone_number": "+19705555098",
     *           "status": "pending",
     *           "created_at": "2018-01-01T00:00:00.000000Z",
     *           "updated_at": "2018-01-01T00:00:00.000000Z",
     *           "expired_at": "2018-01-01T00:00:00.000000Z"
     *         }
     *       ],
     *       "status": "pending",
     *       "customer_reference": "MY REF 001",
     *       "created_at": "2018-01-01T00:00:00.000000Z",
     *       "updated_at": "2018-01-01T00:00:00.000000Z"
     *     } */
    CreateNumberReservationRequest: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example number_reservation */
      readonly record_type?: string;
      phone_numbers?: components['schemas']['ReservedPhoneNumber'][];
      /**
       * @description The status of the entire reservation.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the numbers reservation was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number reservation was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
    };
    /**
     * Outbound Voice Profile
     * @example {
     *       "name": "office",
     *       "traffic_type": "conversational",
     *       "service_plan": "global",
     *       "concurrent_call_limit": 10,
     *       "enabled": true,
     *       "tags": [
     *         "office-profile"
     *       ],
     *       "usage_payment_method": "rate-deck",
     *       "whitelisted_destinations": [
     *         "US",
     *         "BR",
     *         "AU"
     *       ],
     *       "max_destination_rate": 10,
     *       "daily_spend_limit": "100.00",
     *       "daily_spend_limit_enabled": true,
     *       "billing_group_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58"
     *     }
     */
    CreateOutboundVoiceProfileRequest: {
      /**
       * @description A user-supplied name to help with organization.
       * @example office
       */
      name: string;
      traffic_type?: components['schemas']['TrafficType'];
      service_plan?: components['schemas']['ServicePlan'];
      /**
       * @description Must be no more than your global concurrent call limit. Null means no limit.
       * @example 10
       */
      concurrent_call_limit?: number | null;
      /**
       * @description Specifies whether the outbound voice profile can be used. Disabled profiles will result in outbound calls being blocked for the associated Connections.
       * @default true
       * @example true
       */
      enabled: boolean;
      /** @example [
       *       "office-profile"
       *     ] */
      tags?: string[];
      usage_payment_method?: components['schemas']['UsagePaymentMethod'];
      /**
       * @description The list of destinations you want to be able to call using this outbound voice profile formatted in alpha2.
       * @default [
       *       "US",
       *       "CA"
       *     ]
       * @example [
       *       "US",
       *       "BR",
       *       "AU"
       *     ]
       */
      whitelisted_destinations: string[];
      /** @description Maximum rate (price per minute) for a Destination to be allowed when making outbound calls. */
      max_destination_rate?: number;
      /**
       * @description The maximum amount of usage charges, in USD, you want Telnyx to allow on this outbound voice profile in a day before disallowing new calls.
       * @example 100.00
       */
      daily_spend_limit?: string;
      /**
       * @description Specifies whether to enforce the daily_spend_limit on this outbound voice profile.
       * @default false
       * @example true
       */
      daily_spend_limit_enabled: boolean;
      call_recording?: components['schemas']['OutboundCallRecording'];
      /**
       * Format: uuid
       * @description The ID of the billing group associated with the outbound proflile. Defaults to null (for no group assigned).
       * @default null
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      billing_group_id: string | null;
    };
    /** CreatePortingOrder */
    CreatePortingOrder: {
      /**
       * @description The list of +E.164 formatted phone numbers
       * @example [
       *       "+13035550000",
       *       "+13035550001",
       *       "+13035550002"
       *     ]
       */
      phone_numbers: string[];
      /**
       * @description A customer-specified reference number for customer bookkeeping purposes
       * @example Acct 123abc
       */
      customer_reference?: string;
    };
    CreatePortingOrderComment: {
      /** @example Please, let me know when the port completes */
      body?: string;
    };
    CreateRoomClientTokenRequest: {
      /**
       * @description The time to live in seconds of the Client Token, after that time the Client Token is invalid and can't be used to join a Room.
       * @default 600
       * @example 600
       */
      token_ttl_secs: number;
      /**
       * @description The time to live in seconds of the Refresh Token, after that time the Refresh Token is invalid and can't be used to refresh Client Token.
       * @default 3600
       * @example 3600
       */
      refresh_token_ttl_secs: number;
    };
    CreateRoomCompositionRequest: {
      /**
       * @description The desired format of the room composition.
       * @default mp4
       * @example mp4
       */
      format: string;
      /**
       * @description The desired resolution (width/height in pixels) of the resulting video of the room composition. Both width and height are required to be between 16 and 1280; and width * height should not exceed 1280 * 720
       * @default 1280x720
       * @example 800x600
       */
      resolution: string;
      /**
       * Format: uuid
       * @description id of the room session associated with the room composition.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      session_id?: string | null;
      /** @description Describes the video layout of the room composition in terms of regions. */
      video_layout?: {
        [key: string]: components['schemas']['VideoRegion'];
      };
      /**
       * Format: url
       * @description The URL where webhooks related to this room composition will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this room composition will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
    };
    CreateRoomRequest: {
      /**
       * @description The unique (within the Telnyx account scope) name of the room.
       * @example My room
       */
      unique_name?: string;
      /**
       * @description The maximum amount of participants allowed in a room. If new participants try to join after that limit is reached, their request will be rejected.
       * @default 10
       * @example 10
       */
      max_participants: number;
      /**
       * @description Enable or disable recording for that room.
       * @default false
       * @example true
       */
      enable_recording: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this room will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this room will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
    };
    /** @example {
     *       "from": "+18445550001",
     *       "to": "+18445550001",
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media_urls": [
     *         "http://example.com"
     *       ],
     *       "webhook_url": "http://example.com/webhooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "use_profile_webhooks": true,
     *       "type": "MMS"
     *     } */
    CreateShortCodeMessageRequest: {
      /**
       * Format: address
       * @description Phone number, in +E.164 format, used to send the message.
       */
      from: string;
      to: components['schemas']['ToNumber'];
      /** @description Message body (i.e., content) as a non-empty string.
       *
       *     **Required for SMS** */
      text?: string;
      /** @description Subject of multimedia message */
      subject?: string;
      /** @description A list of media URLs. The total media size must be less than 1 MB.
       *
       *     **Required for MMS** */
      media_urls?: string[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string;
      /**
       * @description If the profile this number is associated with has webhooks, use them for delivery notifications. If webhooks are also specified on the message itself, they will be attempted first, then those on the profile.
       * @default true
       */
      use_profile_webhooks: boolean;
      /**
       * @description The protocol for sending the message, either SMS or MMS.
       * @enum {string}
       */
      type?: 'SMS' | 'MMS';
      /**
       * @description Automatically detect if an SMS message is unusually long and exceeds a recommended limit of message parts.
       * @default false
       */
      auto_detect: boolean;
    };
    /**
     * Create TeXML Secret request
     * @example {
     *       "name": "My Secret Name",
     *       "value": "My Secret Value"
     *     }
     */
    CreateTeXMLSecretRequest: {
      /**
       * @description Name used as a reference for the secret, if the name already exists within the account its value will be replaced
       * @example My Secret Name
       */
      name: string;
      /**
       * @description Secret value which will be used when rendering the TeXML template
       * @example My Secret Value
       */
      value: string;
    };
    /**
     * Create TeXML Secret result
     * @example {
     *       "name": "My Secret Name",
     *       "value": "*****"
     *     }
     */
    CreateTeXMLSecretResult: {
      /** @example My Secret Name */
      name?: string;
      /**
       * @example *****
       * @enum {string}
       */
      value?: '*****';
    };
    /**
     * Create Texml Application Request
     * @example {
     *       "friendly_name": "call-router",
     *       "active": false,
     *       "anchorsite_override": "Amsterdam, Netherlands",
     *       "dtmf_type": "Inband",
     *       "first_command_timeout": true,
     *       "first_command_timeout_secs": 10,
     *       "voice_url": "https://example.com",
     *       "voice_fallback_url": "https://fallback.example.com",
     *       "voice_method": "get",
     *       "status_callback": "https://example.com",
     *       "status_callback_method": "get",
     *       "inbound": {
     *         "channel_limit": 10,
     *         "shaken_stir_enabled": true,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    CreateTexmlApplicationRequest: {
      friendly_name: components['schemas']['ApplicationName'];
      active?: components['schemas']['ConnectionActive'];
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      dtmf_type?: components['schemas']['DtmfType'];
      first_command_timeout?: components['schemas']['FirstCommandTimeout'];
      first_command_timeout_secs?: components['schemas']['FirstCommandTimeoutSecs'];
      /**
       * Format: url
       * @description URL to which Telnyx will deliver your XML Translator webhooks.
       * @example https://example.com
       */
      voice_url: string;
      /**
       * Format: url
       * @description URL to which Telnyx will deliver your XML Translator webhooks if we get an error response from your voice_url.
       * @default null
       * @example https://fallback.example.com
       */
      voice_fallback_url: string;
      /**
       * @description HTTP request method Telnyx will use to interact with your XML Translator webhooks. Either 'get' or 'post'.
       * @default post
       * @example get
       * @enum {string}
       */
      voice_method: 'get' | 'post';
      /**
       * Format: url
       * @description URL for Telnyx to send requests to containing information about call progress events.
       * @default null
       * @example https://example.com
       */
      status_callback: string;
      /**
       * @description HTTP request method Telnyx should use when requesting the status_callback URL.
       * @default post
       * @example get
       * @enum {string}
       */
      status_callback_method: 'get' | 'post';
      inbound?: {
        /**
         * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        /**
         * @description When enabled Telnyx will include Shaken/Stir data in the Webhook for new inbound calls.
         * @default false
         * @example false
         */
        shaken_stir_enabled: boolean;
        /**
         * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
         * @default null
         * @example example
         */
        sip_subdomain: string;
        /**
         * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
         * @default from_anyone
         * @example only_my_connections
         * @enum {string}
         */
        sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      };
      outbound?: {
        /**
         * @description When set, this will limit the total number of outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
    };
    /**
     * CreateVerificationRequestCall
     * @description The request body when creating a verification.
     */
    CreateVerificationRequestCall: {
      /**
       * @description +E164 formatted phone number.
       * @example +13035551234
       */
      phone_number: string;
      /**
       * Format: uuid
       * @description The identifier of the associated Verify profile.
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      verify_profile_id: string;
      /**
       * @description Send a self-generated numeric code to the end-user
       * @default null
       * @example 43612
       */
      custom_code: string | null;
      /**
       * @description The number of seconds the verification code is valid for.
       * @example 300
       */
      timeout_secs?: number;
    };
    /**
     * CreateVerificationRequestFlashcall
     * @description The request body when creating a verification.
     */
    CreateVerificationRequestFlashcall: {
      /**
       * @description +E164 formatted phone number.
       * @example +13035551234
       */
      phone_number: string;
      /**
       * Format: uuid
       * @description The identifier of the associated Verify profile.
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      verify_profile_id: string;
      /**
       * @description The number of seconds the verification code is valid for.
       * @example 300
       */
      timeout_secs?: number;
    };
    /**
     * CreateVerificationRequestSMS
     * @description The request body when creating a verification.
     */
    CreateVerificationRequestSMS: {
      /**
       * @description +E164 formatted phone number.
       * @example +13035551234
       */
      phone_number: string;
      /**
       * Format: uuid
       * @description The identifier of the associated Verify profile.
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      verify_profile_id: string;
      /**
       * @description Send a self-generated numeric code to the end-user
       * @default null
       * @example 43612
       */
      custom_code: string | null;
      /**
       * @description The number of seconds the verification code is valid for.
       * @example 300
       */
      timeout_secs?: number;
    };
    /** CreateVerifyVerificationResponse */
    CreateVerificationResponse: {
      data: components['schemas']['Verification'];
    };
    /** CreateVerifiedNumberResponse */
    CreateVerifiedNumberResponse: {
      /** @example +15551234567 */
      phone_number?: string;
      /** @example sms */
      verification_method?: string;
    };
    /** CreateVerifyProfileCallRequest */
    CreateVerifyProfileCallRequest: {
      /**
       * Format: uuid
       * @description The message template identifier selected from /verify_profiles/templates
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      messaging_template_id?: string;
      /**
       * @description The name that identifies the application requesting 2fa in the verification message.
       * @example Example Secure App
       */
      app_name?: string;
      /**
       * @description The length of the verify code to generate.
       * @default 5
       * @example 6
       */
      code_length: number;
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** CreateVerifyProfileFlashcallRequest */
    CreateVerifyProfileFlashcallRequest: {
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** CreateVerifyProfileSMSRequest */
    CreateVerifyProfileSMSRequest: {
      /**
       * Format: uuid
       * @description The message template identifier selected from /verify_profiles/templates
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      messaging_template_id?: string;
      /**
       * @description The name that identifies the application requesting 2fa in the verification message.
       * @example Example Secure App
       */
      app_name?: string;
      /**
       * @description The alphanumeric sender ID to use when sending to destinations that require an alphanumeric sender ID.
       * @default Telnyx
       */
      alpha_sender: string;
      /**
       * @description The length of the verify code to generate.
       * @default 5
       * @example 6
       */
      code_length: number;
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /**
     * @description ISO 8601 formatted date-time indicating when the resource was created.
     * @example 2018-02-02T22:25:27.521Z
     */
    CreatedAt: string;
    /** Format: date-time */
    CreationDate: string;
    /**
     * CreationStatus
     * @description An enumeration.
     * @enum {string}
     */
    CreationStatus: 'pending' | 'created' | 'failed';
    /**
     * Credential Active
     * @description If the credential associated with this service is active.
     * @default false
     * @example true
     */
    CredentialActive: boolean;
    /**
     * Credential Connection
     * @example {
     *       "id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "record_type": "credential_connection",
     *       "active": true,
     *       "user_name": "myusername123",
     *       "password": "my123secure456password789",
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z",
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "sip_uri_calling_preference": "disabled",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtp+1",
     *         "capture_enabled": true,
     *         "report_frequency_seconds": 10
     *       },
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": [
     *           "G722"
     *         ],
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 15,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "call_parking_enabled": true,
     *         "ani_override": "string",
     *         "ani_override_type": "always",
     *         "channel_limit": 10,
     *         "instant_ringback_enabled": true,
     *         "generate_ringback_tone": true,
     *         "localization": "string",
     *         "t38_reinvite_source": "customer",
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    CredentialConnection: {
      /**
       * Format: int64
       * @description Identifies the type of resource.
       * @example 1293384261075731499
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example credential_connection
       */
      record_type?: string;
      /** @description Defaults to true */
      active?: boolean;
      /**
       * @description The user name to be used as part of the credentials. Must be 4-32 characters long and alphanumeric values only (no spaces or special characters).
       * @example myusername123
       */
      user_name?: string;
      /**
       * @description The password to be used as part of the credentials. Must be 8 to 128 characters long.
       * @example my123secure456password789
       */
      password?: string;
      /**
       * @description ISO-8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO-8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name?: string;
      /**
       * @description This feature enables inbound SIP URI calls to your Credential Auth Connection. If enabled for all (unrestricted) then anyone who calls the SIP URI <your-username>@telnyx.com will be connected to your Connection. You can also choose to allow only calls that are originated on any Connections under your account (internal).
       * @example disabled
       * @enum {string}
       */
      sip_uri_calling_preference?: 'disabled' | 'unrestricted' | 'internal';
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['CredentialInbound'];
      outbound?: components['schemas']['CredentialOutbound'];
    };
    /**
     * Credential Inbound
     * @example {
     *       "ani_number_format": "+E.164",
     *       "dnis_number_format": "+e164",
     *       "codecs": "G722",
     *       "default_routing_method": "sequential",
     *       "channel_limit": 10,
     *       "generate_ringback_tone": true,
     *       "isup_headers_enabled": true,
     *       "prack_enabled": true,
     *       "privacy_zone_enabled": true,
     *       "sip_compact_headers_enabled": true,
     *       "timeout_1xx_secs": 10,
     *       "timeout_2xx_secs": 20,
     *       "shaken_stir_enabled": true
     *     }
     */
    CredentialInbound: {
      /**
       * @description This setting allows you to set the format with which the caller's number (ANI) is sent for inbound phone calls.
       * @default E.164-national
       * @enum {string}
       */
      ani_number_format:
        | '+E.164'
        | 'E.164'
        | '+E.164-national'
        | 'E.164-national';
      /**
       * @default e164
       * @enum {string}
       */
      dnis_number_format: '+e164' | 'e164' | 'national' | 'sip_username';
      /**
       * @description Defines the list of codecs that Telnyx will send for inbound calls to a specific number on your portal account, in priority order. This only works when the Connection the number is assigned to uses Media Handling mode: default. OPUS and H.264 codecs are available only when using TCP or TLS transport for SIP.
       * @default [
       *       "G722",
       *       "G711U",
       *       "G711A",
       *       "G729",
       *       "OPUS",
       *       "H.264"
       *     ]
       */
      codecs: string[];
      /**
       * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
       * @default null
       */
      channel_limit: number;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description When set, inbound phone calls will receive ISUP parameters via SIP headers. (Only when available and only when using TCP or TLS transport.)
       * @default false
       */
      isup_headers_enabled: boolean;
      /**
       * @description Enable PRACK messages as defined in RFC3262.
       * @default false
       */
      prack_enabled: boolean;
      /**
       * @description By default, Telnyx does not send caller-id information when the caller has chosen to hide this information. When this option is enabled, Telnyx will send the SIP header Privacy:id plus the caller-id information so that the receiver side can choose when to hide it.
       * @default false
       */
      privacy_zone_enabled: boolean;
      /**
       * @description Defaults to true.
       * @default true
       */
      sip_compact_headers_enabled: boolean;
      /**
       * @description Time(sec) before aborting if connection is not made.
       * @default 3
       */
      timeout_1xx_secs: number;
      /**
       * @description Time(sec) before aborting if call is unanswered (min: 1, max: 600).
       * @default 90
       */
      timeout_2xx_secs: string;
      /**
       * @description When enabled the SIP Connection will receive the Identity header with Shaken/Stir data in the SIP INVITE message of inbound calls, even when using UDP transport.
       * @default false
       */
      shaken_stir_enabled: boolean;
    };
    /**
     * Credential Outbound
     * @example {
     *       "call_parking_enabled": true,
     *       "ani_override": "always",
     *       "channel_limit": 10,
     *       "instant_ringback_enabled": true,
     *       "generate_ringback_tone": true,
     *       "localization": "US",
     *       "t38_reinvite_source": "customer",
     *       "outbound_voice_profile_id": "1293384261075731499"
     *     }
     */
    CredentialOutbound: {
      /**
       * @description Forces all SIP calls originated on this connection to be "parked" instead of "bridged" to the destination specified on the URI. Parked calls will return ringback to the caller and will await for a Call Control command to define which action will be taken next.
       * @default false
       */
      call_parking_enabled: boolean | null;
      /**
       * @description Set a phone number as the ani_override value to override caller id number on outbound calls.
       * @default
       */
      ani_override: string;
      /**
       * @description Specifies when we apply your ani_override setting. Only applies when ani_override is not blank.
       * @default always
       * @enum {string}
       */
      ani_override_type: 'always' | 'normal' | 'emergency';
      /**
       * @description When set, this will limit the total number of outbound calls to phone numbers associated with this connection.
       * @default null
       */
      channel_limit: number;
      /**
       * @description When set, ringback will not wait for indication before sending ringback tone to calling party.
       * @default true
       */
      instant_ringback_enabled: boolean;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description A 2-character country code specifying the country whose national dialing rules should be used. For example, if set to `US` then any US number can be dialed without preprending +1 to the number. When left blank, Telnyx will try US and GB dialing rules, in that order, by default.
       * @default US
       * @example US
       */
      localization: string;
      /**
       * @description This setting only affects connections with Fax-type Outbound Voice Profiles. The setting dictates whether or not Telnyx sends a t.38 reinvite.<br/><br/> By default, Telnyx will send the re-invite. If set to `customer`, the caller is expected to send the t.38 reinvite.
       * @default telnyx
       * @enum {string}
       */
      t38_reinvite_source:
        | 'telnyx'
        | 'customer'
        | 'disabled'
        | 'passthru'
        | 'caller-passthru'
        | 'callee-passthru';
      outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
    };
    /**
     * Format: password
     * @description Opaque credential token used to authenticate and authorize with storage provider.
     * @example OPAQUE_CREDENTIALS_TOKEN
     */
    Credentials: string;
    /** CredentialsResponse */
    CredentialsResponse: {
      data: components['schemas']['CustomStorageConfiguration'];
      connection_id: components['parameters']['ConnectionId'];
      record_type: components['schemas']['RecordType'];
    };
    /** @example {
     *       "id": "42587e44-3a3e-46de-9255-0c9a7a1d1ec7",
     *       "record_type": "csv_download",
     *       "url": "https://www.telnyx.com/sample/42587e44-3a3e-46de-9255-0c9a7a1d1ec7",
     *       "status": "pending"
     *     } */
    CsvDownload: {
      /**
       * @description Identifies the resource.
       * @example 42587e44-3a3e-46de-9255-0c9a7a1d1ec7
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example csv_download
       */
      readonly record_type?: string;
      /**
       * @description The URL at which the CSV file can be retrieved.
       * @example https://www.telnyx.com/sample/42587e44-3a3e-46de-9255-0c9a7a1d1ec7
       */
      url?: string;
      /**
       * @description Indicates the completion level of the CSV report. Only complete CSV download requests will be able to be retrieved.
       * @default pending
       * @example pending
       * @enum {string}
       */
      status: 'pending' | 'complete' | 'failed' | 'expired';
    };
    /**
     * Currencies
     * @description The supported currencies.
     * @example USD
     * @enum {string}
     */
    Currencies: 'USD' | 'EUR' | 'GBP' | 'AUD' | 'CAD';
    Cursor: {
      /**
       * @description Opaque identifier of next page.
       * @example v1:g3QAAAADZAAKdGVsbnl4X2lkc2wAAAABbQAAACRlYmRiYzdkNi1kZWRmLTExZWQtYTM3MS0wMjQyMGFlZjAwYjRqZAAJdGltZXN0YW1wbggA8Le4pGhpVxdkAAR0eXBlZAAFYWZ0ZXI=
       */
      after?: string;
      /**
       * @description Opaque identifier of previous page.
       * @example v1:g3QAAAADZAAKdGVsbnl4X2lkc2wAAAABbQAAACRlYmRiYzdkNi1kZWRmLTExZWQtYTM3MS0wMjQyMGFlZjAwYjRqZAAJdGltZXN0YW1wbggA8Le4pGhpVxdkAAR0eXBlZAAFYWZ0ZXI=
       */
      before?: string;
    };
    /** Cursor Pagination Meta */
    CursorPaginationMeta: {
      cursors?: components['schemas']['Cursor'];
      /**
       * @description Path to next page.
       * @example /v2/recording_transcriptions?page[after]=v1:g3QAAAADZAAKdGVsbnl4X2lkc2wAAAABbQAAACRlYmRiYzdkNi1kZWRmLTExZWQtYTM3MS0wMjQyMGFlZjAwYjRqZAAJdGltZXN0YW1wbggA8Le4pGhpVxdkAAR0eXBlZAAFYWZ0ZXI=
       */
      next?: string;
      /**
       * @description Path to previous page.
       * @example /v2/recording_transcriptions?page[before]=v1:g3QAAAADZAAKdGVsbnl4X2lkc2wAAAABbQAAACRlYmRiYzdkNi1kZWRmLTExZWQtYTM3MS0wMjQyMGFlZjAwYjRqZAAJdGltZXN0YW1wbggA8Le4pGhpVxdkAAR0eXBlZAAFYWZ0ZXI=
       */
      previous?: string;
    };
    /**
     * Custom SIP Header
     * @example {
     *       "name": "head_1",
     *       "value": "val_1"
     *     }
     */
    CustomSipHeader: {
      /**
       * @description The name of the header to add.
       * @example head_1
       */
      name: string;
      /**
       * @description The value of the header.
       * @example val_1
       */
      value: string;
    };
    /** Custom Storage Configuration */
    CustomStorageConfiguration: {
      /**
       * @example gcs
       * @enum {string}
       */
      backend: 'gcs' | 's3' | 'azure';
      configuration:
        | components['schemas']['GCSConfigurationData']
        | components['schemas']['S3ConfigurationData']
        | components['schemas']['AzureConfigurationData'];
    };
    CustomerServiceRecord: {
      /**
       * Format: uuid
       * @description Uniquely identifies this customer service record
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      readonly id?: string;
      /**
       * @description The phone number of the customer service record.
       * @example +12065551212
       */
      phone_number?: string;
      /**
       * @description The status of the customer service record
       * @example completed
       * @enum {string}
       */
      status?: 'pending' | 'completed' | 'failed';
      /**
       * @description The error message in case status is `failed`. This field would be null in case of `pending` or `completed` status.
       * @example CSR information not available.
       */
      error_message?: string;
      /** @description The result of the CSR request. This field would be null in case of `pending` or `failed` status. */
      result?: {
        /**
         * @description The name of the carrier that the customer service record is for.
         * @example ABC CARRIER, INC.
         */
        carrier_name?: string;
        /** @description The associated phone numbers of the customer service record. */
        associated_phone_numbers?: string[];
        /** @description The admin of the customer service record. */
        admin?: {
          /**
           * @description The name of the customer service record.
           * @example John Doe
           */
          name?: string;
          /**
           * @description The billing phone number of the customer service record.
           * @example +12065551212
           */
          billing_phone_number?: string;
          /**
           * @description The account number of the customer service record.
           * @example 1234567890
           */
          account_number?: string;
          /**
           * @description The authorized person name of the customer service record.
           * @example John Doe
           */
          authorized_person_name?: string;
        };
        /** @description The address of the customer service record */
        address?: {
          /**
           * @description The state of the address
           * @example NY
           */
          administrative_area?: string;
          /**
           * @description The city of the address
           * @example New York
           */
          locality?: string;
          /**
           * @description The zip code of the address
           * @example 10001
           */
          postal_code?: string;
          /**
           * @description The street address
           * @example 123 Main St
           */
          street_address?: string;
          /**
           * @description The full address
           * @example 123 Main St; New York; NY; 10001
           */
          full_address?: string;
        };
      };
      /**
       * @description Identifies the type of the resource.
       * @example customer_service_record
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    CustomerServiceRecordAdditionalData: {
      /**
       * @description The name of the administrator of CSR.
       * @example Entity Inc.
       */
      name?: string;
      /**
       * @description The name of the authorized person.
       * @example John Doe
       */
      authorized_person_name?: string;
      /**
       * @description The PIN of the customer service record.
       * @example 1234
       */
      pin?: string;
      /**
       * @description The account number of the customer service record.
       * @example 123456789
       */
      account_number?: string;
      /**
       * @description The customer code of the customer service record.
       * @example 123456789
       */
      customer_code?: string;
      /**
       * @description The first line of the address of the customer service record.
       * @example 123 Main St
       */
      address_line_1?: string;
      /**
       * @description The city of the customer service record.
       * @example New York
       */
      city?: string;
      /**
       * @description The state of the customer service record.
       * @example NY
       */
      state?: string;
      /**
       * @description The zip code of the customer service record.
       * @example 10001
       */
      zip_code?: string;
      /**
       * @description The billing phone number of the customer service record.
       * @example +12065551212
       */
      billing_phone_number?: string;
    };
    CustomerServiceRecordPhoneNumberCoverage: {
      /**
       * @description The phone number that is being verified.
       * @example +12223334444
       */
      phone_number?: string;
      /**
       * @description Indicates whether the phone number is covered or not.
       * @example true
       */
      has_csr_coverage?: boolean;
      /**
       * @description The reason why the phone number is not covered. Only returned if `has_csr_coverage` is false.
       * @example The phone number '+19999999999' is invalid.
       */
      reason?: string;
      /** @description Additional data required to perform CSR for the phone number. Only returned if `has_csr_coverage` is true. */
      additional_data_required?: (
        | 'name'
        | 'authorized_person_name'
        | 'account_number'
        | 'customer_code'
        | 'pin'
        | 'address_line_1'
        | 'city'
        | 'state'
        | 'zip_code'
        | 'billing_phone_number'
      )[];
      /**
       * @description Identifies the type of the resource.
       * @example customer_service_record_phone_number_coverage
       */
      record_type?: string;
    };
    CustomerServiceRecordStatusChangedEvent: {
      /**
       * Format: uuid
       * @description Uniquely identifies the callback event.
       * @example d3c462b5-8afa-4d48-9af1-4f9b1f00e7bd
       */
      id?: string;
      /**
       * @description The type of the callback event.
       * @example customer_service_record.status_changed
       * @enum {string}
       */
      event_type?: 'customer_service_record.status_changed';
      payload?: {
        /**
         * Format: uuid
         * @description Uniquely identifies the customer service record.
         * @example f1486bae-f067-460c-ad43-73a92848f902
         */
        id?: string;
        /**
         * @description The phone number of the customer service record.
         * @example +12065551212
         */
        phone_number?: string;
        /**
         * @description The status of the customer service record
         * @example completed
         * @enum {string}
         */
        status?: 'pending' | 'completed' | 'failed';
        /**
         * Format: date-time
         * @description ISO 8601 formatted date indicating the last time where the resource was updated.
         * @example 2021-03-19T10:07:15.527Z
         */
        updated_at?: string;
      };
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the callback event occurred.
       * @example 2021-03-19T10:07:15.527Z
       */
      occurred_at?: string;
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
    };
    /**
     * Format: datetime-rfc2822
     * @example Fri, 11 Aug 2023 19:12:11 +0000
     */
    DateTimeRFC2822: string;
    /** Dca */
    Dca: {
      /**
       * Id
       * @description Unique identifier of the direct connect aggregator
       */
      id: string;
      /**
       * Displayname
       * @description Display name of the direct connect aggregator.
       */
      displayName: string;
    };
    DefaultGateway: components['schemas']['Record'] & {
      /**
       * @description Identifies the type of the resource.
       * @example default_gateway
       */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Network ID.
       * @example e66c496d-4a85-423b-8b2a-8e63fac20320
       */
      network_id?: string;
      /**
       * Format: uuid
       * @description Wireguard peer ID.
       * @example e66c496d-4a85-423b-8b2a-8e63fac20320
       */
      wireguard_peer_id?: string;
      status?: components['schemas']['InterfaceStatus'];
    };
    DeleteObjectsRequest: {
      Key?: string;
    }[];
    DeleteObjectsResponse: Record<string, never>;
    /** @description An object following one of the schemas published in https://developers.telnyx.com/docs/api/v2/detail-records */
    DetailRecord:
      | components['schemas']['MessageDetailRecord']
      | components['schemas']['ConferenceDetailRecord']
      | components['schemas']['ConferenceParticipantDetailRecord']
      | components['schemas']['WhatsAppDetailRecord']
      | components['schemas']['WhatsAppConversationDetailRecord']
      | components['schemas']['AmdDetailRecord']
      | components['schemas']['VerifyDetailRecord']
      | components['schemas']['SimCardUsageDetailRecord']
      | components['schemas']['MediaStorageDetailRecord'];
    DetailRecordsSearchResponse: {
      data?: components['schemas']['DetailRecord'][];
      meta?: components['schemas']['PaginationMeta'];
    };
    /** DetailedTaskStatus */
    DetailedTaskStatus: {
      /**
       * Taskid
       * @description The ID of the task associated with bulk Sole Proprietor brand and campaign creation.
       * @example 4b60017a-2f50-4c90-c9e6-5f67304cbde2
       */
      taskId: string;
      /**
       * Referenceid
       * @description A user generated unique identifier that keeps track of sole proprietor brand/campaign combinations submitted during bulk creation.
       * @example 4q90017a-2f50-4c90-c9e6-5f67304cbde9
       */
      referenceId: string;
      /**
       * Brand
       * @description The status of the individual brand submitted via bulk creation.
       */
      brand: components['schemas']['BrandStatus'][];
      /**
       * Campaign
       * @description The status of the individual campaign submitted via bulk creation.
       */
      campaign: components['schemas']['CampaignStatus'][];
      /** Phonenumbers */
      phoneNumbers: components['schemas']['PhoneNumberStatus'][];
    };
    /**
     * Create Conference Participant Request
     * @example {
     *       "To": "+12065550100",
     *       "From": "+12065550200"
     *     }
     */
    DialConferenceParticipantRequest: {
      /**
       * @description Whether to play a notification beep to the conference when the participant enters and exits.
       * @example onExit
       * @enum {string}
       */
      Beep?: 'true' | 'false' | 'onEnter' | 'onExit';
      /**
       * @description URL destination for Telnyx to send status callback events to for the call.
       * @example https://www.example.com/callback
       */
      StatusCallback?: string;
      /**
       * @description HTTP request type used for `StatusCallback`.
       * @example GET
       * @enum {string}
       */
      StatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description The changes to the call's state that should generate a call to `StatusCallback`. Can be: `initiated`, `ringing`, `answered`, and `completed`. Separate multiple values with a space. The default value is `completed`.
       * @example answered completed
       */
      StatusCallbackEvent?: string;
      /**
       * @description The phone number of the called party. Phone numbers are formatted with a `+` and country code.
       * @example +16175551212
       */
      To?: string;
      /**
       * @description The phone number of the party that initiated the call. Phone numbers are formatted with a `+` and country code.
       * @example +16175551212
       */
      From?: string;
      /**
       * @description The number of seconds that we should allow the phone to ring before assuming there is no answer. Can be an integer between 5 and 120, inclusive. The default value is 30.
       * @example 30
       */
      Timeout?: number;
      /**
       * @description Whether the participant should be muted.
       * @example true
       */
      Muted?: boolean;
      /**
       * @description Whether to start the conference when the participant enters. Defaults to `true`.
       * @example false
       */
      StartConferenceOnEnter?: boolean;
      /**
       * @description Whether to end the conference when the participant leaves. Defaults to `false`.
       * @example true
       */
      EndConferenceOnExit?: boolean;
      /**
       * @description Whether participant shall be bridged to conference before the participant answers (from early media if available). Defaults to `false`.
       * @default false
       * @example true
       */
      EarlyMedia: boolean;
      /**
       * @description The URL the conference callbacks will be sent to.
       * @example https://example.com/conference_status_callback
       */
      ConferenceStatusCallback?: string;
      /**
       * @description HTTP request type used for `ConferenceStatusCallback`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      ConferenceStatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description The changes to the conference's state that should generate a call to `ConferenceStatusCallback`. Can be: `start`, `end`, `join` and `leave`. Separate multiple values with a space. By default no callbacks are sent.
       * @example start end join leave
       */
      ConferenceStatusCallbackEvent?: string;
      /**
       * @description The URL to call for an audio file to play while the participant is waiting for the conference to start.
       * @example https://www.example.com/wait_music.mp3
       */
      WaitUrl?: string;
      /**
       * @description The maximum number of participants in the conference. Can be a positive integer from 2 to 800. The default value is 250.
       * @example 30
       */
      MaxParticipants?: number;
      /**
       * @description Whether the participant is coaching another call. When `true`, `CallSidToCoach` has to be given.
       * @example false
       */
      Coaching?: boolean;
      /**
       * @description The SID of the participant who is being coached. The participant being coached is the only participant who can hear the participant who is coaching.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      CallSidToCoach?: string;
      /**
       * @description To be used as the caller id name (SIP From Display Name) presented to the destination (`To` number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and `-_~!.+` special characters. If ommited, the display name will be the same as the number in the `From` field.
       * @example Info
       */
      CallerId?: string;
      /**
       * @description The maximum duration of the call in seconds.
       * @example 30
       */
      TimeLimit?: number;
      /**
       * @description Whether to detect if a human or an answering machine picked up the call. Use `Enable` if you would like to ne notified as soon as the called party is identified. Use `DetectMessageEnd`, if you would like to leave a message on an answering machine.
       * @example Enable
       * @enum {string}
       */
      MachineDetection?: 'Enable' | 'DetectMessageEnd';
      /**
       * @description How long answering machine detection should go on for before sending an `Unknown` result. Given in milliseconds.
       * @example 1000
       */
      MachineDetectionTimeout?: number;
      /**
       * @description Maximum threshold of a human greeting. If greeting longer than this value, considered machine. Ignored when `premium` detection is used.
       * @default 3500
       * @example 2000
       */
      MachineDetectionSpeechThreshold: number;
      /**
       * @description Silence duration threshold after a greeting message or voice for it be considered human. Ignored when `premium` detection is used.
       * @default 800
       * @example 2000
       */
      MachineDetectionSpeechEndThreshold: number;
      /**
       * @description If initial silence duration is greater than this value, consider it a machine. Ignored when `premium` detection is used.
       * @default 3500
       * @example 2000
       */
      MachineDetectionSilenceTimeout: number;
      /**
       * @description The URL the result of answering machine detection will be sent to.
       * @example https://www.example.com/amd_result
       */
      AmdStatusCallback?: string;
      /**
       * @description HTTP request type used for `AmdStatusCallback`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      AmdStatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description Whether to cancel ongoing playback on `machine` detection. Defaults to `true`.
       * @default true
       * @example false
       */
      CancelPlaybackOnMachineDetection: boolean;
      /**
       * @description Whether to cancel ongoing playback on `greeting ended` detection. Defaults to `true`.
       * @default true
       * @example false
       */
      CancelPlaybackOnDetectMessageEnd: boolean;
      /**
       * @description The list of comma-separated codecs to be offered on a call.
       * @example PCMA,PCMU
       */
      PreferredCodecs?: string;
      /**
       * @description Whether to record the entire participant's call leg. Defaults to `false`.
       * @example false
       */
      Record?: boolean;
      /**
       * @description The number of channels in the final recording. Defaults to `mono`.
       * @example dual
       * @enum {string}
       */
      RecordingChannels?: 'mono' | 'dual';
      /**
       * @description The URL the recording callbacks will be sent to.
       * @example https://example.com/recording_status_callback
       */
      RecordingStatusCallback?: string;
      /**
       * @description HTTP request type used for `RecordingStatusCallback`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      RecordingStatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description The changes to the recording's state that should generate a call to `RecoridngStatusCallback`. Can be: `in-progress`, `completed` and `absent`. Separate multiple values with a space. Defaults to `completed`.
       * @example in-progress completed absent
       */
      RecordingStatusCallbackEvent?: string;
      /**
       * @description The audio track to record for the call. The default is `both`.
       * @example inbound
       * @enum {string}
       */
      RecordingTrack?: 'inbound' | 'outbound' | 'both';
      /**
       * @description The password to use for SIP authentication.
       * @example 1234
       */
      SipAuthPassword?: string;
      /**
       * @description The username to use for SIP authentication.
       * @example user
       */
      SipAuthUsername?: string;
      /**
       * @description Whether to trim any leading and trailing silence from the recording. Defaults to `trim-silence`.
       * @example false
       * @enum {string}
       */
      Trim?: 'trim-silence' | 'do-not-trim';
      /**
       * @description Whether to record the conference the participant is joining. Defualts to `do-not-record`. The boolean values `true` and `false` are synonymous with `record-from-start` and `do-not-record` respectively.
       * @example record-from-start
       * @enum {string}
       */
      ConferenceRecord?:
        | 'true'
        | 'false'
        | 'record-from-start'
        | 'do-not-record';
      /**
       * @description The URL the conference recording callbacks will be sent to.
       * @example https://example.com/conference_recording_status_callback
       */
      ConferenceRecordingStatusCallback?: string;
      /**
       * @description HTTP request type used for `ConferenceRecordingStatusCallback`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      ConferenceRecordingStatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description The changes to the conference recording's state that should generate a call to `RecoridngStatusCallback`. Can be: `in-progress`, `completed` and `absent`. Separate multiple values with a space. Defaults to `completed`. `failed` and `absent` are synonymous.
       * @example in-progress completed failed absent
       */
      ConferenceRecordingStatusCallbackEvent?: string;
      /**
       * @description The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected. The timer only starts when the speech is detected. Please note that the transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite)
       * @default 0
       * @example 5
       */
      ConferenceRecordingTimeout: number;
      /**
       * @description Whether to trim any leading and trailing silence from the conference recording. Defaults to `trim-silence`.
       * @example false
       * @enum {string}
       */
      ConferenceTrim?: 'trim-silence' | 'do-not-trim';
    };
    /** Dialogflow Config */
    DialogflowConfig: {
      /**
       * @description Enable sentiment analysis from Dialogflow.
       * @default false
       * @example true
       */
      analyze_sentiment: boolean;
      /**
       * @description Enable partial automated agent reply from Dialogflow.
       * @default false
       * @example true
       */
      partial_automated_agent_reply: boolean;
    };
    /**
     * Dialogflow Connection Params
     * @example {
     *       "service_Account": "{\"type\":\"service_account\",\"project_id\":\"your-project-id\",\"private_key_id\":\"your-private-key\",\"private_key\":\"-----BEGIN PRIVATE KEY-----n-----END PRIVATE\",\"client_email\":\"example@example.com\",\"client_id\":\"your-client-id\",\"auth_uri\":\"http://example.com\",\"token_uri\":\"http://example.com\",\"auth_provider_x509_cert_url\":\"http://example.com\",\"client_x509_cert_url\":\"http://example.com\"}",
     *       "dialogflow_api": "cx",
     *       "conversation_profile_id": "a-VMHLWzTmKjiJw5S6O0-w",
     *       "location": "global",
     *       "environment": "development"
     *     }
     */
    DialogflowConnection: {
      /**
       * @description The JSON map to connect your Dialoglow account.
       * @example {"service_account":{"type":"service_account","project_id":"your-project-id","private_key_id":"your-private-key","private_key":"-----BEGIN PRIVATE KEY-----n-----END PRIVATE","client_email":"example@example.com","client_id":"your-client-id","auth_uri":"http://example.com","token_uri":"http://example.com","auth_provider_x509_cert_url":"http://example.com","client_x509_cert_url":"http://example.com"}}
       */
      service_account: Record<string, never>;
      /**
       * @description Determin which Dialogflow will be used.
       * @default es
       * @example cx
       * @enum {string}
       */
      dialogflow_api: 'cx' | 'es';
      /**
       * @description The id of a configured conversation profile on your Dialogflow account. (If you use Dialogflow CX, this param is required)
       * @example a-VMHLWzTmKjiJw5S6O0-w
       */
      conversation_profile_id?: string;
      /**
       * @description The region of your agent is. (If you use Dialogflow CX, this param is required)
       * @example global
       */
      location?: string;
      /**
       * @description Which Dialogflow environment will be used.
       * @example development
       */
      environment?: string;
    };
    /** Dialogflow Connection Response */
    DialogflowConnectionResponse: {
      /** Dialogflow Connection */
      data: {
        /** @example dialogflow_connections */
        record_type?: string;
        /**
         * @description Uniquely identifies a Telnyx application (Call Control).
         * @example 1234541231
         */
        connection_id?: string;
        /**
         * @description The id of a configured conversation profile on your Dialogflow account. (If you use Dialogflow CX, this param is required)
         * @example a-VMHLWzTmKjiJw5S6O0-w
         */
        conversation_profile_id?: string;
        /**
         * @description Which Dialogflow environment will be used.
         * @example development
         */
        environment?: string;
        /**
         * @description The JSON map to connect your Dialoglow account.
         * @example ****
         */
        service_account?: string;
      };
    };
    /**
     * @description The direction of the fax.
     * @example outbound
     * @enum {string}
     */
    Direction: 'inbound' | 'outbound';
    DocReqsRequirement: {
      /**
       * @description Identifies the type of the resource.
       * @example requirement
       */
      readonly record_type?: string;
      /**
       * @description The 2-character (ISO 3166-1 alpha-2) country code where this requirement applies
       * @example FR
       */
      country_code?: string;
      /**
       * @description The locality where this requirement applies
       * @example Nice
       */
      locality?: string;
      /**
       * @description Indicates the phone_number_type this requirement applies to. Leave blank if this requirement applies to all number_types.
       * @example local
       * @enum {string}
       */
      phone_number_type?: 'local' | 'national' | 'toll_free';
      /**
       * @description Indicates whether this requirement applies to ordering, porting, or both
       * @example ordering
       * @enum {string}
       */
      action?: 'both' | 'ordering' | 'porting';
      /** @description Lists the requirement types necessary to fulfill this requirement */
      readonly requirements_types?: components['schemas']['DocReqsRequirementType'][];
      /**
       * Format: uuid
       * @description Identifies the associated document
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2021-04-09T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was last updated.
       * @example 2021-04-12T20:20:20.020Z
       */
      readonly updated_at?: string;
    };
    DocReqsRequirementList: components['schemas']['DocReqsRequirement'][];
    DocReqsRequirementType: {
      /** @description Specifies objective criteria for acceptance */
      acceptance_criteria?: {
        /**
         * @description Specifies time-based acceptance criteria
         * @example Current and not expired
         */
        time_limit?: string;
        /**
         * @description Specifies geography-based acceptance criteria
         * @example Issued by the same country that the phone number belongs to
         */
        locality_limit?: string;
        /** @description Specifies the list of strictly possible values for the requirement. Ignored when empty */
        acceptable_values?: string[];
      };
      /**
       * @description Describes the requirement type
       * @example Proves the customer has a physical address in the same locality as the phone number
       */
      description?: string;
      /**
       * @description Provides one or more examples of acceptable documents
       * @example Utility bill, internet bill, phone bill, or lease
       */
      example?: string;
      /**
       * @description Defines the type of this requirement type
       * @example document
       * @enum {string}
       */
      type?: 'document' | 'address' | 'textual';
      /**
       * @description A short descriptive name for this requirement_type
       * @example Proof of Address
       */
      readonly name?: string;
      /**
       * @description Identifies the type of the resource
       * @example requirement_type
       */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Identifies the associated document
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2021-04-09T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was last updated.
       * @example 2021-04-12T20:20:20.020Z
       */
      readonly updated_at?: string;
    };
    DocReqsRequirementTypeList: components['schemas']['DocReqsRequirementType'][];
    DocServiceDocument: components['schemas']['DocServiceRecord'] & {
      /**
       * @description Identifies the type of the resource.
       * @example document
       */
      readonly record_type?: string;
      /**
       * @description The document's content_type.
       * @example application/pdf
       */
      readonly content_type?: string;
      /** @description Indicates the document's filesize */
      readonly size?: {
        /**
         * @description Identifies the unit
         * @example bytes
         */
        readonly unit?: string;
        /**
         * @description The number of bytes
         * @example 123456
         */
        readonly amount?: number;
      };
      /**
       * @description Indicates the current document reviewing status
       * @example pending
       * @enum {string}
       */
      readonly status?: 'pending' | 'verified' | 'denied';
      /**
       * @description The document's SHA256 hash provided for optional verification purposes.
       * @example 08a96c641c3a74e44eb59afb61a24f2cb9f4d7188748e76ba4bb5edfa3cb7d1c
       */
      readonly sha256?: string;
      /**
       * @description The filename of the document.
       * @example test-document.pdf
       */
      filename?: string;
      /**
       * @description Optional reference string for customer tracking.
       * @example MY REF 001
       */
      customer_reference?: string;
    };
    DocServiceDocumentLink: components['schemas']['DocServiceRecord'] & {
      /**
       * @description Identifies the type of the resource.
       * @example document_link
       */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Identifies the associated document.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly document_id?: string;
      /**
       * @description The linked resource's record type.
       * @example porting_order
       */
      readonly linked_record_type?: string;
      /**
       * @description Identifies the linked resource.
       * @example 132091b4-442b-4a2a-b87f-61e707e46d54
       */
      readonly linked_resource_id?: string;
    };
    DocServiceDocumentUploadInline: {
      /**
       * Format: byte
       * @description The Base64 encoded contents of the file you are uploading.
       * @example [Base64 encoded content]
       */
      file: string;
      /**
       * @description The filename of the document.
       * @example test-document.pdf
       */
      filename?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
    };
    DocServiceDocumentUploadURL: {
      /**
       * @description If the file is already hosted publicly, you can provide a URL and have the documents service fetch it for you.
       * @example https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf
       */
      url: string;
      /**
       * @description The filename of the document.
       * @example test-document.pdf
       */
      filename?: string;
      /**
       * @description Optional reference string for customer tracking.
       * @example MY REF 001
       */
      customer_reference?: string;
    };
    DocServiceRecord: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example sample_record_type
       */
      readonly record_type?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    DownlinkData: {
      /**
       * @description Downlink data
       * @example 1
       */
      amount?: number;
      /**
       * @description Transmission unit
       * @default MB
       * @enum {string}
       */
      unit: 'B' | 'KB' | 'MB';
    };
    /**
     * DTMF Type
     * @description Sets the type of DTMF digits sent from Telnyx to this Connection. Note that DTMF digits sent to Telnyx will be accepted in all formats.
     * @default RFC 2833
     * @example Inband
     * @enum {string}
     */
    DtmfType: 'RFC 2833' | 'Inband' | 'SIP INFO';
    DynamicEmergencyAddress: {
      /** @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f1 */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example dynamic_emergency_address
       */
      readonly record_type?: string;
      /**
       * @description Unique location reference string to be used in SIP INVITE from / p-asserted headers.
       * @example XYZ123
       */
      readonly sip_geolocation_id?: string;
      /**
       * @description Status of dynamic emergency address
       * @example pending
       * @enum {string}
       */
      readonly status?: 'pending' | 'activated' | 'rejected';
      /** @example 311 */
      house_number: string;
      house_suffix?: string;
      /** @example W */
      street_pre_directional?: string;
      /** @example Superior */
      street_name: string;
      street_suffix?: string;
      street_post_directional?: string;
      extended_address?: string;
      /** @example Chicago */
      locality: string;
      /** @example IL */
      administrative_area: string;
      /** @example 60654 */
      postal_code: string;
      /**
       * @example US
       * @enum {string}
       */
      country_code?: 'US' | 'CA' | 'PR';
      /**
       * @description ISO 8601 formatted date of when the resource was created
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date of when the resource was last updated
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    DynamicEmergencyEndpoint: {
      /** @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0 */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example dynamic_emergency_endpoint
       */
      readonly record_type?: string;
      /**
       * @description An id of a currently active dynamic emergency location.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      dynamic_emergency_address_id: string;
      /**
       * @description Status of dynamic emergency address
       * @example pending
       * @enum {string}
       */
      readonly status?: 'pending' | 'activated' | 'rejected';
      /** @example FXDFWEDF */
      readonly sip_from_id?: string;
      /** @example +13125550000 */
      callback_number: string;
      /** @example Jane Doe Desk Phone */
      caller_name: string;
      /**
       * @description ISO 8601 formatted date of when the resource was created
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date of when the resource was last updated
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SIMCardRegistration */
    ESimPurchase: {
      /**
       * Format: uuid
       * @description The group SIMCardGroup identification. This attribute can be <code>null</code> when it's present in an associated resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_group_id?: string;
      /**
       * @description Searchable tags associated with the SIM cards
       * @example [
       *       "personal",
       *       "customers",
       *       "active-customers"
       *     ]
       */
      tags?: string[];
      /**
       * @description The amount of eSIMs to be purchased.
       * @example 10
       */
      amount: number;
      /**
       * @description Status on which the SIM cards will be set after being successfully registered.
       * @default enabled
       * @example standby
       * @enum {string}
       */
      status: 'enabled' | 'disabled' | 'standby';
    };
    /** ElevenLabs Voice Settings */
    ElevenLabsVoiceSettings: {
      /**
       * @description The reference to the ElevenLabs API key to be used for the voice assistant. The API key must be added to the account text-to-speech secrets `/v2/text-to-speech/secrets`.
       * @example my_elevenlabs_api_key
       */
      api_key_ref?: string;
    };
    /** EmbeddingBucketRequest */
    EmbeddingBucketRequest: {
      /** Bucket Name */
      bucket_name: string;
      /**
       * Document Chunk Size
       * @default 1024
       */
      document_chunk_size: number;
      /**
       * Document Chunk Overlap Size
       * @default 512
       */
      document_chunk_overlap_size: number;
      /** @default thenlper/gte-large */
      embedding_model: components['schemas']['SupportedEmbeddingModels'];
      /** @default default */
      loader: components['schemas']['SupportedEmbeddingLoaders'];
    };
    /** EmbeddingMetadata */
    EmbeddingMetadata: {
      /** Source */
      source: string;
      /** Checksum */
      checksum: string;
      /** Embedding */
      embedding: string;
      /** Filename */
      filename: string;
      /** Certainty */
      certainty?: number;
      /** Loader Metadata */
      loader_metadata?: Record<string, never>;
    };
    /** EmbeddingResponse */
    EmbeddingResponse: {
      data: {
        /**
         * Task ID
         * Format: uuid
         */
        task_id?: string;
        /** Task Name */
        task_name?: string;
        /** Status */
        status?: string;
        /** Created At */
        created_at?: string;
        /** Finished At */
        finished_at?: string | null;
        /**
         * User ID
         * Format: uuid
         */
        user_id?: string;
      };
    };
    /**
     * EmbeddingSimilaritySearchDocument
     * @description Example document response from embedding service
     *     {
     *       "document_chunk": "your status? This is Vanessa Bloome...",
     *       "distance": 0.18607724,
     *       "metadata": {
     *         "source": "https://us-central-1.telnyxstorage.com/scripts/bee_movie_script.txt",
     *         "checksum": "343054dd19bab39bbf6761a3d20f1daa",
     *         "embedding": "openai/text-embedding-ada-002",
     *         "filename": "bee_movie_script.txt",
     *         "certainty": 0.9069613814353943,
     *         "loader_metadata": {}
     *       }
     *     }
     */
    EmbeddingSimilaritySearchDocument: {
      /** Document Chunk */
      document_chunk: string;
      /** Distance */
      distance: number;
      metadata: components['schemas']['EmbeddingMetadata'];
    };
    /** EmbeddingSimilaritySearchRequest */
    EmbeddingSimilaritySearchRequest: {
      /** Bucket Name */
      bucket_name: string;
      /** Query */
      query: string;
      /**
       * Num Of Docs
       * @default 3
       */
      num_of_docs: number;
    };
    /** EmbeddingSimilaritySearchResponse */
    EmbeddingSimilaritySearchResponse: {
      /** Data */
      data: components['schemas']['EmbeddingSimilaritySearchDocument'][];
    };
    /** EmbeddingsBucketFiles */
    EmbeddingsBucketFiles: {
      /** Filename */
      filename: string;
      /** Status */
      status: string;
      /**
       * Created At
       * Format: date-time
       */
      created_at: string;
      /**
       * Updated At
       * Format: date-time
       */
      updated_at?: string;
      /**
       * Last Embedded At
       * Format: date-time
       */
      last_embedded_at?: string;
      /** Error Reason */
      error_reason?: string;
    };
    /** EmbeddingsBucketFilesData */
    EmbeddingsBucketFilesData: {
      /** Data */
      data: components['schemas']['EmbeddingsBucketFiles'][];
    };
    /**
     * @description The emergency services settings for a phone number.
     * @example {
     *       "emergency_enabled": true,
     *       "emergency_address_id": "1315261609962112019"
     *     }
     */
    EmergencySettings: {
      /**
       * @description Allows you to enable or disable emergency services on the phone number. In order to enable emergency services, you must also set an emergency_address_id.
       * @default false
       */
      emergency_enabled: boolean;
      /**
       * Format: int64
       * @description Identifies the address to be used with emergency services.
       */
      emergency_address_id?: string;
      /**
       * @description Represents the state of the number regarding emergency activation.
       * @default disabled
       * @enum {string}
       */
      emergency_status:
        | 'disabled'
        | 'active'
        | 'provisioning'
        | 'deprovisioning';
    };
    /**
     * @description Enable use of SRTP for encryption. Cannot be set if the transport_portocol is TLS.
     * @example SRTP
     * @enum {string|null}
     */
    EncryptedMedia: 'SRTP' | null;
    /**
     * Enqueue Request
     * @example {
     *       "queue_name": "support",
     *       "max_wait_time_secs": 600,
     *       "max_size": 20,
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    EnqueueRequest: {
      /**
       * @description The name of the queue the call should be put in. If a queue with a given name doesn't exist yet it will be created.
       * @example tier_1_support
       */
      queue_name?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description The number of seconds after which the call will be removed from the queue.
       * @example 600
       */
      max_wait_time_secs?: number;
      /**
       * @description The maximum number of calls allowed in the queue at a given time. Can't be modified for an existing queue.
       * @default 100
       * @example 200
       */
      max_size: number;
    };
    /**
     * EntityType
     * @description Entity type behind the brand. This is the form of business establishment.
     * @example PRIVATE_PROFIT
     * @enum {unknown}
     */
    EntityType:
      | 'PRIVATE_PROFIT'
      | 'PUBLIC_PROFIT'
      | 'NON_PROFIT'
      | 'SOLE_PROPRIETOR'
      | 'GOVERNMENT';
    /**
     * EnumListResponse
     * @example ["BASIC_ACCOUNT", "SMALL_ACCOUNT", "MEDIUM_ACCOUNT", "LARGE_ACCOUNT", "KEY_ACCOUNT"]
     */
    EnumListResponse: (string | Record<string, never>)[];
    /**
     * EnumObjectResponse
     * @example {"AREIS": "AREIS", "BANDW": "Bandwidth", "SINCH": "Sinch"}
     */
    EnumObjectResponse: Record<string, never>;
    /**
     * EnumPaginatedResponse
     * @example {"page": 1, "records": [{"isin": "US68243Q1067", "iso2": "US", "symbol": "FLWS", "exchange": "NASDAQ", "displayName": "1-800 FLOWERS.COM, Inc."}, {"isin": "US88025U1097", "iso2": "US", "symbol": "TXG", "exchange": "NASDAQ", "displayName": "10X GENOMICS INC CLASS A"}], "totalRecords": 2}
     */
    EnumPaginatedResponse: Record<string, never>;
    Error: {
      /** Format: int */
      code: string;
      title: string;
      detail?: string;
      source?: {
        /**
         * Format: json-pointer
         * @description JSON pointer (RFC6901) to the offending entity.
         */
        pointer?: string;
        /** @description Indicates which query parameter caused the error. */
        parameter?: string;
      };
      meta?: Record<string, never>;
    };
    ErrorRecord: {
      /**
       * @description an application-specific error code, expressed as a stringified 5-digit integer
       * @example 10003
       */
      code?: string;
      /**
       * @description a short, human-readable summary of the problem, with NO punctuation, that SHOULD NOT CHANGE from occurrence to occurrence of the problem, except for purposes of localization
       * @example Metrics invalid values
       */
      title?: string;
      /**
       * @description a human-readable explanation specific to this occurrence of the problem. Like title, this field’s value can be localized
       * @example Available metrics values for sip-trunking: connected,cost,completed,call_sec,attempted,billed_sec.
       */
      detail?: string;
      source?: components['schemas']['SourceResponse'];
      meta?: components['schemas']['MetaResponse'];
    };
    ErrorResponse: {
      errors?: components['schemas']['ErrorRecord'][];
    };
    Errors: {
      errors?: components['schemas']['Error'][];
    };
    /**
     * Exchange
     * @description An enumeration.
     * @enum {unknown}
     */
    Exchange:
      | 'NONE'
      | 'NASDAQ'
      | 'NYSE'
      | 'AMEX'
      | 'AMX'
      | 'ASX'
      | 'B3'
      | 'BME'
      | 'BSE'
      | 'FRA'
      | 'ICEX'
      | 'JPX'
      | 'JSE'
      | 'KRX'
      | 'LON'
      | 'NSE'
      | 'OMX'
      | 'SEHK'
      | 'SSE'
      | 'STO'
      | 'SWX'
      | 'SZSE'
      | 'TSX'
      | 'TWSE'
      | 'VSE';
    /** @description The parameters for generating a porting orders CSV report. */
    ExportPortingOrdersCSVReport: {
      /** @description The filters to apply to the export porting order CSV report. */
      filters: {
        /** @description The status of the porting orders to include in the report. */
        status__in?: (
          | 'draft'
          | 'in-process'
          | 'submitted'
          | 'exception'
          | 'foc-date-confirmed'
          | 'cancel-pending'
          | 'ported'
          | 'cancelled'
        )[];
        /** @description The customer reference of the porting orders to include in the report. */
        customer_reference__in?: string[];
        /**
         * Format: date-time
         * @description The date and time the porting order was created before.
         */
        created_at__lt?: string;
        /**
         * Format: date-time
         * @description The date and time the porting order was created after.
         */
        created_at__gt?: string;
      };
    };
    /** @description The parameters for generating a port-outs CSV report. */
    ExportPortoutsCSVReport: {
      /** @description The filters to apply to the export port-out CSV report. */
      filters: {
        /** @description The status of the port-outs to include in the report. */
        status__in?: (
          | 'pending'
          | 'authorized'
          | 'ported'
          | 'rejected'
          | 'rejected-pending'
          | 'canceled'
        )[];
        /** @description The customer reference of the port-outs to include in the report. */
        customer_reference__in?: string[];
        /**
         * @description The end user name of the port-outs to include in the report.
         * @example McPortersen
         */
        end_user_name?: string;
        /** @description A list of phone numbers that the port-outs phone numbers must overlap with. */
        phone_numbers__overlaps?: string[];
        /**
         * Format: date-time
         * @description The date and time the port-out was created before.
         */
        created_at__lt?: string;
        /**
         * Format: date-time
         * @description The date and time the port-out was created after.
         */
        created_at__gt?: string;
      };
    };
    /** ExtVettingProvider */
    ExtVettingProvider: {
      /** Evpid */
      evpId?: string;
      /** Displayname */
      displayName?: string;
      /** Tcrbillable */
      tcrBillable?: boolean;
      /** Vettingclasses */
      vettingClasses?: string[];
      /** Vettinginstruction */
      vettingInstruction?: string;
    };
    /**
     * External Connection
     * @example {
     *       "id": "1930241863466354012",
     *       "record_type": "external_connection",
     *       "external_sip_connection": "zoom",
     *       "credential_active": false,
     *       "active": false,
     *       "created_at": "2022-06-29T19:23:59Z",
     *       "updated_at": "2022-06-29T19:39:47Z",
     *       "outbound": {
     *         "outbound_voice_profile_id": "1911630617284445511"
     *       }
     *     }
     */
    ExternalConnection: {
      id?: components['schemas']['IntId'];
      /**
       * @description Identifies the type of the resource.
       * @example external_connection
       */
      record_type?: string;
      active?: components['schemas']['ConnectionActive'];
      credential_active?: components['schemas']['CredentialActive'];
      external_sip_connection?: components['schemas']['ExternalSipConnection'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      inbound?: {
        /**
         * @description When set, this will limit the number of concurrent inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
      };
      outbound?: {
        /**
         * @description When set, this will limit the number of concurrent outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /** Phone number details with relation to an external connection */
    ExternalConnectionPhoneNumber: {
      ticket_id?: components['schemas']['UUID'];
      /** @description Phone number in E164 format. */
      telephone_number?: string;
      /** @description Phone number ID from the Telnyx API. */
      number_id?: string;
      /**
       * Format: uuid
       * @description Identifies the civic address assigned to the phone number.
       */
      civic_address_id?: string;
      /**
       * Format: uuid
       * @description Identifies the location assigned to the phone number.
       */
      location_id?: string;
      /** @description The iso country code that will be displayed to the user when they receive a call from this phone number. */
      displayed_country_code?: string;
      acquired_capabilities?: (
        | 'FirstPartyAppAssignment'
        | 'InboundCalling'
        | 'Office365'
        | 'OutboundCalling'
        | 'UserAssignment'
      )[];
    };
    /**
     * External SIP Connection
     * @description The service that will be consuming this connection.
     * @default zoom
     * @example zoom
     * @enum {string}
     */
    ExternalSipConnection: 'zoom' | 'operator_connect';
    /**
     * External SIP Connection
     * @description The service that will be consuming this connection.
     * @default zoom
     * @example zoom
     * @enum {string}
     */
    ExternalSipConnectionZoomOnly: 'zoom';
    /** ExternalVetting */
    ExternalVetting: {
      /**
       * Evpid
       * @description External vetting provider ID for the brand.
       */
      evpId?: string;
      /**
       * vettingId
       * @description Unique ID that identifies a vetting transaction performed by a vetting provider. This ID is provided by the vetting provider at time of vetting.
       */
      vettingId?: string;
      /**
       * vettingToken
       * @description Required by some providers for vetting record confirmation.
       */
      vettingToken?: string;
      /**
       * vettingScore
       * @description Vetting score ranging from 0-100.
       */
      vettingScore?: number;
      /**
       * Vettingclass
       * @description Identifies the vetting classification.
       */
      vettingClass?: string;
      /**
       * vettedDate
       * @description Vetting effective date. This is the date when vetting was completed, or the starting effective date in ISO 8601 format. If this date is missing, then the vetting was not complete or not valid.
       */
      vettedDate?: string;
      /**
       * createDate
       * @description Vetting submission date. This is the date when the vetting request is generated in ISO 8601 format.
       */
      createDate?: string;
    };
    ExternalWdrDetailRecordDto: {
      /**
       * @description WDR id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      id?: string;
      /**
       * Format: date-time
       * @description Record created time
       * @example 2020-07-01T00:00:00-06:00
       */
      created_at?: string;
      cost?: components['schemas']['WirelessCost'];
      /**
       * @description Mobile country code.
       * @example 204
       */
      mcc?: string;
      /**
       * @description Mobile network code.
       * @example 01
       */
      mnc?: string;
      downlink_data?: components['schemas']['DownlinkData'];
      /**
       * @description Session duration in seconds.
       * @example 1
       */
      duration_seconds?: number;
      /**
       * @description International mobile subscriber identity.
       * @example 123
       */
      imsi?: string;
      rate?: components['schemas']['WirelessRate'];
      /**
       * @description Defined sim group name
       * @example sim name
       */
      sim_group_name?: string;
      /**
       * @description Sim group unique identifier
       * @example f05a189f-7c46-4531-ac56-1460dc465a42
       */
      sim_group_id?: string;
      /**
       * @description Sim card unique identifier
       * @example 877f80a6-e5b2-4687-9a04-88076265720f
       */
      sim_card_id?: string;
      /**
       * @description Phone number
       * @example +12345678910
       */
      phone_number?: string;
      uplink_data?: components['schemas']['UplinkData'];
      /** @example wdr */
      record_type?: string;
    };
    ExternalWdrGetDetailResponse: {
      data?: components['schemas']['ExternalWdrDetailRecordDto'][];
      meta?: components['schemas']['PaginationMeta'];
    };
    /** @example {
     *       "record_type": "fax",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "connection_id": "c-1",
     *       "direction": "outbound",
     *       "from": "+123",
     *       "to": "+456",
     *       "media_url": "http://www.example.com/fax.pdf",
     *       "store_media": true,
     *       "stored_media_url": "https://s3.amazonaws.com/faxes-dev/user-1/cf4a6b52-bf8e-4945-9f49-611d0d2b083b.pdf?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=xxxxxxxxxx%2F20200505%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200505T095917Z&X-Amz-Expires=7200&X-Amz-SignedHeaders=host&X-Amz-Signature=fac2af40464fcc77673ad762db86e34f9c1b91a82699b5578c5327f53874df51",
     *       "preview_url": "https://s3.amazonaws.com/faxes-dev/user-1/cf4a6b52-bf8e-4945-9f49-611d0d2b083b_preview.tiff?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=xxxxxxxxxx%2F20200505%2Fus-east-1%2Fs3%2Faws4_request&X-Amz-Date=20200505T095917Z&X-Amz-Expires=7200&X-Amz-SignedHeaders=host&X-Amz-Signature=fac2af40464fcc77673ad762db86e34f9c1b91a82699b5578c5327f53874df51",
     *       "quality": "high",
     *       "webhook_url": "http://www.example.com/webhooks",
     *       "webhook_failover_url": "",
     *       "status": "queued",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "created_at": "2020-05-05T09:59:12",
     *       "updated_at": "2020-05-05T09:59:12"
     *     } */
    Fax: {
      /**
       * @description Identifies the type of the resource.
       * @example fax
       * @enum {string}
       */
      record_type?: 'fax';
      id?: components['schemas']['Id'];
      connection_id?: components['schemas']['ConnectionId'];
      direction?: components['schemas']['Direction'];
      media_url?: components['schemas']['MediaUrl'];
      media_name?: components['schemas']['MediaName'];
      to?: components['schemas']['To'];
      from?: components['schemas']['From'];
      /**
       * @description The string used as the caller id name (SIP From Display Name) presented to the destination (`to` number).
       * @example Company Name
       */
      from_display_name?: string;
      quality?: components['schemas']['Quality'];
      /**
       * @description Status of the fax
       * @example queued
       * @enum {string}
       */
      status?:
        | 'queued'
        | 'media.processed'
        | 'originated'
        | 'sending'
        | 'delivered'
        | 'failed'
        | 'initiated'
        | 'receiving'
        | 'media.processing'
        | 'received';
      /** @description URL that will receive fax webhooks */
      webhook_url?: string;
      /** @description Optional failover URL that will receive fax webhooks if webhook_url doesn't return a 2XX response */
      webhook_failover_url?: string;
      /** @description Should fax media be stored on temporary URL. It does not support media_name. */
      store_media?: boolean;
      /** @description If store_media was set to true, this is a link to temporary location. Link expires after 10 minutes. */
      stored_media_url?: string;
      /** @description If store_preview was set to true, this is a link to temporary location. Link expires after 10 minutes. */
      preview_url?: string;
      /**
       * @description State received from a command.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when resource was created
       */
      created_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when resource was updated
       */
      updated_at?: string;
    };
    /**
     * Fax Application
     * @example {
     *       "id": "1293384261075731499",
     *       "record_type": "fax_application",
     *       "application_name": "fax-router",
     *       "active": false,
     *       "anchorsite_override": "Amsterdam, Netherlands",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_timeout_secs": 25,
     *       "inbound": {
     *         "channel_limit": 10,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       },
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     }
     */
    FaxApplication: {
      id?: components['schemas']['IntId'];
      /**
       * @description Identifies the type of the resource.
       * @example fax_application
       */
      record_type?: string;
      application_name?: components['schemas']['ApplicationName'];
      active?: components['schemas']['ConnectionActive'];
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      webhook_event_url?: components['schemas']['WebhookEventUrl'];
      webhook_event_failover_url?: components['schemas']['WebhookEventFailoverUrl'];
      webhook_timeout_secs?: components['schemas']['WebhookTimeoutSecs'];
      inbound?: {
        /**
         * @description When set, this will limit the number of concurrent inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        /**
         * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
         * @default null
         * @example example
         */
        sip_subdomain: string;
        /**
         * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
         * @default from_anyone
         * @example only_my_connections
         * @enum {string}
         */
        sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      };
      outbound?: {
        /**
         * @description When set, this will limit the number of concurrent outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /** @example {
     *       "data": {
     *         "event_type": "fax.delivered",
     *         "id": "95479a2e-b947-470a-a88f-2da6dd07ae0f",
     *         "occurred_at": "2020-05-05T13:08:22.039204Z",
     *         "payload": {
     *           "call_duration_secs": 25,
     *           "connection_id": "234423",
     *           "direction": "outbound",
     *           "fax_id": "f8338808-3dc6-4f2b-942a-5d1f39255784",
     *           "from": "+17733372107",
     *           "original_media_url": "http://www.example.com/fax.pdf",
     *           "page_count": 2,
     *           "status": "delivered",
     *           "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *           "to": "+15107882622",
     *           "user_id": "19a75cea-02c6-4b9a-84fa-c9bc8341feb8"
     *         },
     *         "record_type": "event"
     *       }
     *     } */
    FaxDelivered: {
      record_type?: components['schemas']['RecordType'];
      id?: components['schemas']['Id'];
      /**
       * @description The type of event being delivered.
       * @example fax.delivered
       * @enum {string}
       */
      event_type?: 'fax.delivered';
      payload?: {
        /**
         * @description The duration of the call in seconds.
         * @example 25
         */
        call_duration_secs?: number;
        connection_id?: components['schemas']['ConnectionId'];
        direction?: components['schemas']['Direction'];
        fax_id?: components['schemas']['FaxId'];
        original_media_url?: components['schemas']['OriginalMediaUrl'];
        media_name?: components['schemas']['MediaName'];
        to?: components['schemas']['To'];
        from?: components['schemas']['From'];
        user_id?: components['schemas']['UserId'];
        /**
         * @description Number of transferred pages
         * @example 2
         */
        page_count?: number;
        /**
         * @description The status of the fax.
         * @example delivered
         * @enum {string}
         */
        status?: 'delivered';
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
      };
    };
    /**
     * Fax Email Recipient
     * Format: email
     * @description Specifies an email address where faxes sent to this application will be forwarded to (as pdf or tiff attachments)
     * @default null
     * @example user@example.com
     */
    FaxEmailRecipient: string | null;
    /** @example {
     *       "data": {
     *         "event_type": "fax.failed",
     *         "id": "95479a2e-b947-470a-a88f-2da6dd07ae0f",
     *         "occurred_at": "2020-05-05T13:08:22.039204Z",
     *         "payload": {
     *           "connection_id": "234423",
     *           "direction": "outbound",
     *           "failure_reason": "rejected",
     *           "fax_id": "f8338808-3dc6-4f2b-942a-5d1f39255784",
     *           "from": "+17733372107",
     *           "original_media_url": "http://www.example.com/fax.pdf",
     *           "status": "failed",
     *           "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *           "to": "+15107882622",
     *           "user_id": "19a75cea-02c6-4b9a-84fa-c9bc8341feb8"
     *         },
     *         "record_type": "event"
     *       }
     *     } */
    FaxFailed: {
      record_type?: components['schemas']['RecordType'];
      id?: components['schemas']['Id'];
      /**
       * @description The type of event being delivered.
       * @example fax.failed
       * @enum {string}
       */
      event_type?: 'fax.failed';
      payload?: {
        connection_id?: components['schemas']['ConnectionId'];
        direction?: components['schemas']['Direction'];
        fax_id?: components['schemas']['FaxId'];
        original_media_url?: components['schemas']['OriginalMediaUrl'];
        media_name?: components['schemas']['MediaName'];
        to?: components['schemas']['To'];
        from?: components['schemas']['From'];
        user_id?: components['schemas']['UserId'];
        /**
         * @description Cause of the sending failure
         * @enum {string}
         */
        failure_reason?: 'rejected';
        /**
         * @description The status of the fax.
         * @example failed
         * @enum {string}
         */
        status?: 'failed';
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
      };
    };
    /**
     * Format: uuid
     * @description Identifies the fax.
     * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
     */
    FaxId: string;
    /** @example {
     *       "data": {
     *         "event_type": "fax.media.processed",
     *         "id": "95479a2e-b947-470a-a88f-2da6dd07ae0f",
     *         "occurred_at": "2020-05-05T13:08:22.039204Z",
     *         "payload": {
     *           "connection_id": "234423",
     *           "direction": "outbound",
     *           "fax_id": "f8338808-3dc6-4f2b-942a-5d1f39255784",
     *           "from": "+17733372107",
     *           "original_media_url": "http://www.example.com/fax.pdf",
     *           "status": "media.processed",
     *           "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *           "to": "+15107882622",
     *           "user_id": "19a75cea-02c6-4b9a-84fa-c9bc8341feb8"
     *         },
     *         "record_type": "event"
     *       }
     *     } */
    FaxMediaProcessed: {
      record_type?: components['schemas']['RecordType'];
      id?: components['schemas']['Id'];
      /**
       * @description The type of event being delivered.
       * @example fax.media.processed
       * @enum {string}
       */
      event_type?: 'fax.media.processed';
      payload?: {
        connection_id?: components['schemas']['ConnectionId'];
        direction?: components['schemas']['Direction'];
        fax_id?: components['schemas']['FaxId'];
        original_media_url?: components['schemas']['OriginalMediaUrl'];
        media_name?: components['schemas']['MediaName'];
        to?: components['schemas']['To'];
        from?: components['schemas']['From'];
        user_id?: components['schemas']['UserId'];
        /**
         * @description The status of the fax.
         * @example media.processed
         * @enum {string}
         */
        status?: 'media.processed';
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
      };
    };
    /** @example {
     *       "data": {
     *         "event_type": "fax.queued",
     *         "id": "95479a2e-b947-470a-a88f-2da6dd07ae0f",
     *         "occurred_at": "2020-05-05T13:08:22.039204Z",
     *         "payload": {
     *           "connection_id": "234423",
     *           "direction": "outbound",
     *           "fax_id": "f8338808-3dc6-4f2b-942a-5d1f39255784",
     *           "from": "+17733372107",
     *           "original_media_url": "http://www.example.com/fax.pdf",
     *           "status": "queued",
     *           "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *           "to": "+15107882622",
     *           "user_id": "19a75cea-02c6-4b9a-84fa-c9bc8341feb8"
     *         },
     *         "record_type": "event"
     *       }
     *     } */
    FaxQueued: {
      record_type?: components['schemas']['RecordType'];
      id?: components['schemas']['Id'];
      /**
       * @description The type of event being delivered.
       * @example fax.queued
       * @enum {string}
       */
      event_type?: 'fax.queued';
      payload?: {
        connection_id?: components['schemas']['ConnectionId'];
        direction?: components['schemas']['Direction'];
        fax_id?: components['schemas']['FaxId'];
        original_media_url?: components['schemas']['OriginalMediaUrl'];
        media_name?: components['schemas']['MediaName'];
        to?: components['schemas']['To'];
        from?: components['schemas']['From'];
        user_id?: components['schemas']['UserId'];
        /**
         * @description The status of the fax.
         * @example queued
         * @enum {string}
         */
        status?: 'queued';
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
      };
    };
    /** @example {
     *       "data": {
     *         "event_type": "fax.sending.started",
     *         "id": "95479a2e-b947-470a-a88f-2da6dd07ae0f",
     *         "occurred_at": "2020-05-05T13:08:22.039204Z",
     *         "payload": {
     *           "connection_id": "234423",
     *           "direction": "outbound",
     *           "fax_id": "f8338808-3dc6-4f2b-942a-5d1f39255784",
     *           "from": "+17733372107",
     *           "original_media_url": "http://www.example.com/fax.pdf",
     *           "status": "sending",
     *           "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *           "to": "+15107882622",
     *           "user_id": "19a75cea-02c6-4b9a-84fa-c9bc8341feb8"
     *         },
     *         "record_type": "event"
     *       }
     *     } */
    FaxSendingStarted: {
      record_type?: components['schemas']['RecordType'];
      id?: components['schemas']['Id'];
      /**
       * @description The type of event being delivered.
       * @example fax.sending.started
       * @enum {string}
       */
      event_type?: 'fax.sending.started';
      payload?: {
        connection_id?: components['schemas']['ConnectionId'];
        direction?: components['schemas']['Direction'];
        fax_id?: components['schemas']['FaxId'];
        original_media_url?: components['schemas']['OriginalMediaUrl'];
        media_name?: components['schemas']['MediaName'];
        to?: components['schemas']['To'];
        from?: components['schemas']['From'];
        user_id?: components['schemas']['UserId'];
        /**
         * @description The status of the fax.
         * @example sending
         * @enum {string}
         */
        status?: 'sending';
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
      };
    };
    /** @example {
     *       "name": "sms"
     *     } */
    Feature: {
      /** @example sms */
      name?: string;
    };
    Filter: {
      /** @enum {string} */
      filter_type?: 'and' | 'or';
      /** @example +13129457420 */
      cli?: string;
      /** @enum {string} */
      cli_filter?: 'contains' | 'starts_with' | 'ends_with';
      /** @example +13129457420 */
      cld?: string;
      /** @enum {string} */
      cld_filter?: 'contains' | 'starts_with' | 'ends_with';
      /** @example tag1 */
      tags_list?: string;
      /** @example adfaa016-f921-4b6c-97bb-e4c1dad231c5 */
      billing_group?: string;
    };
    /**
     * First Command Timeout
     * @description Specifies whether calls to phone numbers associated with this connection should hangup after timing out.
     * @default false
     * @example true
     */
    FirstCommandTimeout: boolean;
    /**
     * First Command Timeout Secs
     * @description Specifies how many seconds to wait before timing out a dial command.
     * @default 30
     * @example 10
     */
    FirstCommandTimeoutSecs: number;
    ForbiddenError: components['schemas']['GenericError'] & {
      /** @example 10010 */
      code?: unknown;
      /** @example Authorization failed */
      title?: unknown;
      /** @example You do not have permission to perform the requested action on the specified resource or resources. */
      detail?: unknown;
      meta?: {
        /** @example https://developers.telnyx.com/docs/overview/errors/10010 */
        url?: string;
      };
    };
    /**
     * Fqdn
     * @example {
     *       "id": "1293384261075731499",
     *       "record_type": "fqdn",
     *       "connection_id": "1516447646313612565",
     *       "fqdn": "example.com",
     *       "port": 5060,
     *       "dns_record_type": "a",
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     }
     */
    Fqdn: {
      /**
       * Format: int64
       * @description Identifies the resource.
       * @example 1293384261075731499
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example fqdn
       */
      record_type?: string;
      /** @description ID of the FQDN connection to which this FQDN is attached. */
      connection_id?: string;
      /**
       * @description FQDN represented by this resource.
       * @example example.com
       */
      fqdn?: string;
      /**
       * @description Port to use when connecting to this FQDN.
       * @default 5060
       * @example 5060
       */
      port: number;
      /**
       * @description The DNS record type for the FQDN. For cases where a port is not set, the DNS record type must be 'srv'. For cases where a port is set, the DNS record type must be 'a'. If the DNS record type is 'a' and a port is not specified, 5060 will be used.
       * @example a
       */
      dns_record_type?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /**
     * FQDN Connection
     * @example {
     *       "id": "1293384261075731499",
     *       "record_type": "fqdn_connection",
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "transport_protocol": "UDP",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_secs": 10
     *       },
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z",
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": [
     *           "G722"
     *         ],
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "sip_region": "US",
     *         "sip_subdomain": "string",
     *         "sip_subdomain_receive_settings": "only_my_connections",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 10,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "ani_override": "string",
     *         "ani_override_type": "always",
     *         "call_parking_enabled": true,
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "instant_ringback_enabled": true,
     *         "ip_authentication_method": "token",
     *         "ip_authentication_token": "string",
     *         "localization": "string",
     *         "outbound_voice_profile_id": "1293384261075731499",
     *         "t38_reinvite_source": "customer",
     *         "tech_prefix": "string"
     *       }
     *     }
     */
    FqdnConnection: {
      /**
       * Format: int64
       * @description Identifies the resource.
       * @example 1293384261075731499
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example fqdn_connection
       */
      record_type?: string;
      /** @description Defaults to true */
      active?: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name: components['schemas']['ConnectionName'];
      transport_protocol?: components['schemas']['FqdnConnectionTransportProtocol'];
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description The connection is enabled for Microsoft Teams Direct Routing.
       * @default false
       */
      microsoft_teams_sbc: boolean;
      /**
       * @description Enable on-net T38 if you prefer that the sender and receiver negotiate T38 directly when both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call according to each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      /** @description The username for the FQDN connection. */
      user_name?: string;
      /** @description The password for the FQDN connection. */
      password?: string;
      /** @description Defines if codecs should be passed on stream change. */
      rtp_pass_codecs_on_stream_change?: boolean;
      /** @description Indicates whether DTMF timestamp adjustment is enabled. */
      adjust_dtmf_timestamp?: boolean;
      /** @description Indicates whether DTMF duration should be ignored. */
      ignore_dtmf_duration?: boolean;
      /** @description Indicates whether the mark bit should be ignored. */
      ignore_mark_bit?: boolean;
      /** @description Indicates whether call cost calculation is enabled. */
      call_cost_enabled?: boolean;
      /** @description Indicates whether noise suppression is enabled. */
      noise_suppression?: boolean;
      /** @description Indicates whether normalized timestamps should be sent. */
      send_normalized_timestamps?: boolean;
      /** @description Indicates whether third-party control is enabled. */
      third_party_control_enabled?: boolean;
      /** @description The name for the TXT record associated with the FQDN connection. */
      txt_name?: string;
      /** @description The value for the TXT record associated with the FQDN connection. */
      txt_value?: string;
      /** @description The time to live for the TXT record associated with the FQDN connection. */
      txt_ttl?: number;
      webhook_event_url?: components['schemas']['WebhookEventUrl'];
      webhook_event_failover_url?: components['schemas']['WebhookEventFailoverUrl'];
      webhook_api_version?: components['schemas']['WebhookApiVersion'];
      webhook_timeout_secs?: components['schemas']['WebhookTimeoutSecs'];
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      created_at?: components['schemas']['CreatedAt'];
      updated_at?: components['schemas']['UpdatedAt'];
      inbound?: components['schemas']['InboundFqdn'];
      outbound?: components['schemas']['OutboundFqdn'];
    };
    /**
     * @description One of UDP, TLS, or TCP. Applies only to connections with IP authentication or FQDN authentication.
     * @default UDP
     * @enum {string}
     */
    FqdnConnectionTransportProtocol: 'UDP' | 'TCP' | 'TLS';
    /**
     * @description The phone number, in E.164 format, the fax will be sent from.
     * @example +13125790015
     */
    From: string;
    /** FunctionCall */
    FunctionCall: {
      /** Arguments */
      arguments: string;
      /** Name */
      name: string;
    };
    /** FunctionDefinition */
    FunctionDefinition: {
      name: string;
      description?: string;
      parameters?: Record<string, never>;
    };
    /** FunctionDetail */
    'FunctionDetail-Input': {
      /** Name */
      name: string;
      /**
       * Description
       * @default
       */
      description: string;
      parameters?: components['schemas']['FunctionParameters'];
    };
    /** FunctionDetail */
    'FunctionDetail-Output': {
      /** Name */
      name: string;
      /**
       * Description
       * @default
       */
      description: string;
      parameters?: components['schemas']['FunctionParameters'];
    };
    /** FunctionParameters */
    FunctionParameters: {
      /** Type */
      type: string;
      /** Properties */
      properties: {
        [key: string]: components['schemas']['ParameterProperties'];
      };
      /** Required */
      required: string[];
    };
    /** Google Cloud Storage Configuration Data */
    GCSConfigurationData: {
      credentials?: components['schemas']['Credentials'];
      bucket?: components['schemas']['Bucket'];
    };
    /** Gather */
    GatherRequest: {
      /**
       * Format: int32
       * @description The minimum number of digits to fetch. This parameter has a minimum value of 1.
       * @default 1
       * @example 1
       */
      minimum_digits: number;
      /**
       * Format: int32
       * @description The maximum number of digits to fetch. This parameter has a maximum value of 128.
       * @default 128
       * @example 10
       */
      maximum_digits: number;
      /**
       * Format: int32
       * @description The number of milliseconds to wait to complete the request.
       * @default 60000
       * @example 60000
       */
      timeout_millis: number;
      /**
       * Format: int32
       * @description The number of milliseconds to wait for input between digits.
       * @default 5000
       * @example 10000
       */
      inter_digit_timeout_millis: number;
      /**
       * Format: int32
       * @description The number of milliseconds to wait for the first DTMF.
       * @default 5000
       * @example 10000
       */
      initial_timeout_millis: number;
      /**
       * @description The digit used to terminate input if fewer than `maximum_digits` digits have been gathered.
       * @default #
       * @example #
       */
      terminating_digit: string;
      /**
       * @description A list of all digits accepted as valid.
       * @default 0123456789#*
       * @example 123
       */
      valid_digits: string;
      /**
       * @description An id that will be sent back in the corresponding `call.gather.ended` webhook. Will be randomly generated if not specified.
       * @example my_gather_id
       */
      gather_id?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Gather Using AI Request
     * @example {
     *       "parameters": {
     *         "properties": {
     *           "age": {
     *             "description": "The age of the customer.",
     *             "type": "integer"
     *           },
     *           "location": {
     *             "description": "The location of the customer.",
     *             "type": "string"
     *           }
     *         },
     *         "required": [
     *           "age",
     *           "location"
     *         ],
     *         "type": "object"
     *       },
     *       "voice": "Telnyx.LibriTTS.0",
     *       "voice_settings": {
     *         "voice_speed": 1.25
     *       },
     *       "greeting": "Hello, can you tell me your age and where you live?",
     *       "message_history": [
     *         {
     *           "content": "Hello, what's your name?",
     *           "role": "assistant"
     *         },
     *         {
     *           "content": "Hello, I'm John.",
     *           "role": "user"
     *         }
     *       ],
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    GatherUsingAIRequest: {
      /**
       * @description The parameters described as a JSON Schema object that needs to be gathered by the voice assistant. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema) for documentation about the format
       * @example {
       *       "properties": {
       *         "age": {
       *           "description": "The age of the customer.",
       *           "type": "integer"
       *         },
       *         "location": {
       *           "description": "The location of the customer.",
       *           "type": "string"
       *         }
       *       },
       *       "required": [
       *         "age",
       *         "location"
       *       ],
       *       "type": "object"
       *     }
       */
      parameters: Record<string, never>;
      /**
       * @description The voice to be used by the voice assistant. Currently we support ElevenLabs, Telnyx and AWS voices only, for ElevenLabs voices you can pass the voice as `ElevenLabs.<model_id>.<voice_id>`, for Telnyx voices you can pass the voice as `Telnyx.<model_id>.<voice_id>`, for AWS Polly voices you can pass the voice as `AWS.Polly.<voice_id>`
       * @default Telnyx.LibriTTS.0
       * @example Telnyx.LibriTTS.0
       */
      voice: string;
      /** @description The settings associated with the voice selected */
      voice_settings?:
        | components['schemas']['ElevenLabsVoiceSettings']
        | components['schemas']['TelnyxVoiceSettings']
        | components['schemas']['AWSVoiceSettings'];
      /**
       * @description Text that will be played when the gathering starts, if none then nothing will be played when the gathering starts. The greeting can be text or SSML. There is a 3,000 character limit.
       * @example Hello, can you tell me your age and where you live?
       */
      greeting?: string;
      /** @description The message history you want the voice assistant to be aware of, this can be useful to keep the context of the conversation, or to pass additional information to the voice assistant. */
      message_history?: {
        /**
         * @description The content of the message
         * @example Hello, I'm 29 and I live in Paris.
         */
        content?: string;
        /**
         * @description The role of the message sender
         * @example user
         * @enum {string}
         */
        role?: 'assistant' | 'user';
      }[];
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Gather Using Audio Request
     * @example {
     *       "audio_url": "http://example.com/message.wav",
     *       "invalid_audio_url": "http://example.com/message.wav",
     *       "minimum_digits": 1,
     *       "maximum_digits": 10,
     *       "timeout_millis": 10000,
     *       "terminating_digit": "#",
     *       "valid_digits": "123",
     *       "inter_digit_timeout_millis": 10000,
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    GatherUsingAudioRequest: {
      /**
       * @description The URL of a file to be played back at the beginning of each prompt. The URL can point to either a WAV or MP3 file. media_name and audio_url cannot be used together in one request.
       * @example http://example.com/message.wav
       */
      audio_url?: string;
      /**
       * @description The media_name of a file to be played back at the beginning of each prompt. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      media_name?: string;
      /**
       * @description The URL of a file to play when digits don't match the `valid_digits` parameter or the number of digits is not between `min` and `max`. The URL can point to either a WAV or MP3 file. invalid_media_name and invalid_audio_url cannot be used together in one request.
       * @example http://example.com/invalid.wav
       */
      invalid_audio_url?: string;
      /**
       * @description The media_name of a file to be played back when digits don't match the `valid_digits` parameter or the number of digits is not between `min` and `max`. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      invalid_media_name?: string;
      /**
       * Format: int32
       * @description The minimum number of digits to fetch. This parameter has a minimum value of 1.
       * @default 1
       * @example 1
       */
      minimum_digits: number;
      /**
       * Format: int32
       * @description The maximum number of digits to fetch. This parameter has a maximum value of 128.
       * @default 128
       * @example 10
       */
      maximum_digits: number;
      /**
       * Format: int32
       * @description The maximum number of times the file should be played if there is no input from the user on the call.
       * @default 3
       * @example 3
       */
      maximum_tries: number;
      /**
       * Format: int32
       * @description The number of milliseconds to wait for a DTMF response after file playback ends before a replaying the sound file.
       * @default 60000
       * @example 60000
       */
      timeout_millis: number;
      /**
       * @description The digit used to terminate input if fewer than `maximum_digits` digits have been gathered.
       * @default #
       * @example #
       */
      terminating_digit: string;
      /**
       * @description A list of all digits accepted as valid.
       * @default 0123456789#*
       * @example 123
       */
      valid_digits: string;
      /**
       * Format: int32
       * @description The number of milliseconds to wait for input between digits.
       * @default 5000
       * @example 10000
       */
      inter_digit_timeout_millis: number;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Gather Using Speak Request
     * @example {
     *       "payload": "say this on call",
     *       "invalid_payload": "say this on call",
     *       "payload_type": "text",
     *       "service_level": "premium",
     *       "voice": "male",
     *       "language": "arb",
     *       "minimum_digits": 1,
     *       "maximum_digits": 10,
     *       "terminating_digit": "#",
     *       "valid_digits": "123",
     *       "inter_digit_timeout_millis": 10000,
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    GatherUsingSpeakRequest: {
      /**
       * @description The text or SSML to be converted into speech. There is a 3,000 character limit.
       * @example Say this on the call
       */
      payload: string;
      /**
       * @description The text or SSML to be converted into speech when digits don't match the `valid_digits` parameter or the number of digits is not between `min` and `max`. There is a 3,000 character limit.
       * @example Say this on the call
       */
      invalid_payload?: string;
      /**
       * @description The type of the provided payload. The payload can either be plain text, or Speech Synthesis Markup Language (SSML).
       * @default text
       * @example ssml
       * @enum {string}
       */
      payload_type: 'text' | 'ssml';
      /**
       * @description This parameter impacts speech quality, language options and payload types. When using `basic`, only the `en-US` language and payload type `text` are allowed.
       * @default premium
       * @example premium
       * @enum {string}
       */
      service_level: 'basic' | 'premium';
      /**
       * @description The gender of the voice used to speak back the text or the specific Amazon Polly voice to be used in the form of `Polly.<voice>`, e.g. `Polly.Brian`. All standard Amazon Polly voices are supported.
       * @example female
       * @enum {string}
       */
      voice: 'male' | 'female';
      /**
       * @description The language you want spoken. This parameter is ignored when a `Polly.*` voice is specified.
       * @example en-US
       * @enum {string}
       */
      language?:
        | 'arb'
        | 'cmn-CN'
        | 'cy-GB'
        | 'da-DK'
        | 'de-DE'
        | 'en-AU'
        | 'en-GB'
        | 'en-GB-WLS'
        | 'en-IN'
        | 'en-US'
        | 'es-ES'
        | 'es-MX'
        | 'es-US'
        | 'fr-CA'
        | 'fr-FR'
        | 'hi-IN'
        | 'is-IS'
        | 'it-IT'
        | 'ja-JP'
        | 'ko-KR'
        | 'nb-NO'
        | 'nl-NL'
        | 'pl-PL'
        | 'pt-BR'
        | 'pt-PT'
        | 'ro-RO'
        | 'ru-RU'
        | 'sv-SE'
        | 'tr-TR';
      /**
       * Format: int32
       * @description The minimum number of digits to fetch. This parameter has a minimum value of 1.
       * @default 1
       * @example 1
       */
      minimum_digits: number;
      /**
       * Format: int32
       * @description The maximum number of digits to fetch. This parameter has a maximum value of 128.
       * @default 128
       * @example 10
       */
      maximum_digits: number;
      /**
       * Format: int32
       * @description The maximum number of times that a file should be played back if there is no input from the user on the call.
       * @default 3
       * @example 3
       */
      maximum_tries: number;
      /**
       * Format: int32
       * @description The number of milliseconds to wait for a DTMF response after speak ends before a replaying the sound file.
       * @default 60000
       * @example 60000
       */
      timeout_millis: number;
      /**
       * @description The digit used to terminate input if fewer than `maximum_digits` digits have been gathered.
       * @default #
       * @example #
       */
      terminating_digit: string;
      /**
       * @description A list of all digits accepted as valid.
       * @default 0123456789#*
       * @example 123
       */
      valid_digits: string;
      /**
       * Format: int32
       * @description The number of milliseconds to wait for input between digits.
       * @default 5000
       * @example 10000
       */
      inter_digit_timeout_millis: number;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** Channel zone object */
    GcbChannelZone: {
      /**
       * @example channel_zone
       * @enum {string}
       */
      record_type: 'channel_zone';
      /**
       * @description List of countries (in ISO 3166-2, capitalized) members of the billing channel zone
       * @example [
       *       "BE",
       *       "EL",
       *       "LT",
       *       "PT",
       *       "BG",
       *       "ES",
       *       "LU",
       *       "RO",
       *       "CZ",
       *       "FR",
       *       "HU",
       *       "SI",
       *       "DK",
       *       "HR",
       *       "MT",
       *       "SK",
       *       "DE",
       *       "IT",
       *       "NL",
       *       "FI",
       *       "EE",
       *       "CY",
       *       "AT",
       *       "SE",
       *       "IE",
       *       "LV",
       *       "PL"
       *     ]
       */
      countries: string[];
      /** @example 1653e6a1-4bfd-4857-97c6-6a51e1c34477 */
      id: string;
      /** @example Euro channel zone */
      name: string;
      /**
       * Format: int64
       * @example 7
       */
      channels: number;
      /**
       * @description ISO 8601 formatted date of when the channel zone was created
       * @example 2019-01-23T18:10:02.574Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date of when the channel zone was updated
       * @example 2019-01-23T18:10:02.574Z
       */
      updated_at?: string;
    };
    /** Phone Number object */
    GcbPhoneNumber: {
      /**
       * @example channel_zone_phone_number
       * @enum {string}
       */
      record_type: 'channel_zone_phone_number';
      /** @example 1653e6a1-4bfd-4857-97c6-6a51e1c34477 */
      channel_zone_id: string;
      /** @example 3da3c749-bb7d-4ad6-acae-ca0d415ae08b */
      id?: string;
      /**
       * Format: +E.164
       * @example +15554441234
       */
      phone_number: string;
      /**
       * @description ISO 8601 formatted date of when the phone number was created
       * @example 2019-01-23T18:10:02.574Z
       */
      created_at?: string;
    };
    GenericError: {
      /** Format: int */
      code?: string;
      title?: string;
      detail?: string;
      source?: {
        /**
         * Format: json-pointer
         * @description JSON pointer (RFC6901) to the offending entity.
         */
        pointer?: string;
        /** @description Indicates which query parameter caused the error. */
        parameter?: string;
      };
      meta?: Record<string, never>;
    };
    GetSubRequestByPortingOrder: {
      /**
       * @description Identifies the Sub Request associated with the Porting Order
       * @example 9787fb5f-cbe5-4de4-b765-3303774ee9fe
       */
      sub_request_id?: string;
      /**
       * @description Identifies the Port Request associated with the Porting Order
       * @example 59b0762a-b274-4f76-ac32-4d5cf0272e66
       */
      port_request_id?: string;
    };
    GlobalIP: components['schemas']['Record'] & {
      /**
       * @description Identifies the type of the resource.
       * @example global_ip
       */
      readonly record_type?: string;
      /**
       * @description The Global IP address.
       * @example 198.51.100.1
       */
      readonly ip_address?: string;
      /**
       * @description A Global IP ports grouped by protocol code.
       * @example {
       *       "tcp": [
       *         80,
       *         8080
       *       ],
       *       "udp": [
       *         5000,
       *         5050
       *       ]
       *     }
       */
      ports?: Record<string, never>;
      /**
       * @description A user specified name for the address.
       * @example test interface
       */
      name?: string;
      /**
       * @description A user specified description for the address.
       * @example test interface
       */
      description?: string;
    };
    GlobalIPAllowedPort: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example global_ip_allowed_port
       */
      readonly record_type?: string;
      /**
       * @description The Global IP Protocol code.
       * @example tcp
       */
      readonly protocol_code?: string;
      /**
       * @description A name for the Global IP ports range.
       * @example TCP Registered
       */
      name?: string;
      /**
       * @description First port of a range.
       * @example 1024
       */
      first_port?: number;
      /**
       * @description Last port of a range.
       * @example 49151
       */
      last_port?: number;
    };
    GlobalIPHealthCheck: components['schemas']['Record'] & {
      /**
       * @description Identifies the type of the resource.
       * @example global_ip_health_check
       */
      readonly record_type?: string;
      /**
       * @description The Global IP health check type.
       * @example http_status_2xx
       */
      health_check_type?: string;
      /**
       * @description A Global IP health check params.
       * @example {
       *       "path": "/",
       *       "port": 8080
       *     }
       */
      health_check_params?: Record<string, never>;
      /**
       * Format: uuid
       * @description Global IP ID.
       * @example a836125b-20b6-452e-9c03-2653f09c7ed7
       */
      global_ip_id?: string;
    };
    GlobalIPProtocol: {
      /**
       * @description Identifies the type of the resource.
       * @example global_ip_protocol
       */
      readonly record_type?: string;
      /**
       * @description The Global IP Protocol code.
       * @example tcp
       */
      readonly code?: string;
      /**
       * @description A name for Global IP Protocol.
       * @example TCP
       */
      name?: string;
    };
    GlobalIpAssignment: components['schemas']['Record'] & {
      /**
       * @description Identifies the type of the resource.
       * @example global_ip_assignment
       */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Global IP ID.
       * @example a836125b-20b6-452e-9c03-2653f09c7ed7
       */
      global_ip_id?: string;
      /**
       * Format: uuid
       * @description Wireguard peer ID.
       * @example e66c496d-4a85-423b-8b2a-8e63fac20320
       */
      wireguard_peer_id?: string;
      status?: components['schemas']['InterfaceStatus'];
      /** @description Wireguard peer is connected. */
      readonly is_connected?: boolean;
      /** @description Enable/disable BGP announcement. */
      is_in_maintenance?: boolean;
      /** @description Status of BGP announcement. */
      readonly is_announced?: boolean;
    };
    GlobalIpAssignmentHealthMetric: {
      /**
       * Format: date-time
       * @description The timestamp of the metric.
       * @example 2020-01-01T00:00:00.000Z
       */
      timestamp?: string;
      global_ip?: {
        /**
         * Format: uuid
         * @description Global IP ID.
         * @example a836125b-20b6-452e-9c03-2653f09c7ed7
         */
        id?: string;
        /**
         * @description The Global IP address.
         * @example null
         */
        readonly ip_address?: string;
      };
      global_ip_assignment?: {
        /**
         * Format: uuid
         * @description Global IP assignment ID.
         * @example a836125b-20b6-452e-9c03-2653f09c7ed7
         */
        id?: string;
        /**
         * Format: uuid
         * @description Wireguard peer ID.
         * @example e66c496d-4a85-423b-8b2a-8e63fac20320
         */
        wireguard_peer_id?: string;
        wireguard_peer?: {
          /**
           * @description A user specified name for the interface.
           * @example Wireguard Peer 1
           */
          name?: string;
          /**
           * @description The IP address of the interface.
           * @example 73.47.1.23
           */
          ip_address?: string;
        };
      };
      health?: {
        /**
         * @description The number of successful health checks.
         * @example 100
         */
        pass?: number;
        /**
         * @description The number of failed health checks.
         * @example 0
         */
        fail?: number;
      };
    };
    GlobalIpAssignmentUpdate: components['schemas']['GlobalIpAssignment'] & {
      readonly global_ip_id?: unknown;
      readonly wireguard_peer_id?: unknown;
    };
    GlobalIpAssignmentUsageMetric: {
      /**
       * Format: date-time
       * @description The timestamp of the metric.
       * @example 2020-01-01T00:00:00.000Z
       */
      timestamp?: string;
      global_ip?: {
        /**
         * Format: uuid
         * @description Global IP ID.
         * @example a836125b-20b6-452e-9c03-2653f09c7ed7
         */
        id?: string;
        /**
         * @description The Global IP address.
         * @example 64.1.4.130
         */
        readonly ip_address?: string;
      };
      global_ip_assignment?: {
        /**
         * Format: uuid
         * @description Global IP assignment ID.
         * @example a836125b-20b6-452e-9c03-2653f09c7ed7
         */
        id?: string;
        /**
         * Format: uuid
         * @description Wireguard peer ID.
         * @example e66c496d-4a85-423b-8b2a-8e63fac20320
         */
        wireguard_peer_id?: string;
        wireguard_peer?: {
          /**
           * @description A user specified name for the interface.
           * @example Wireguard Peer 1
           */
          name?: string;
          /**
           * @description The IP address of the interface.
           * @example 172.1.0.1
           */
          ip_address?: string;
        };
      };
      transmitted?: {
        /**
         * @description The amount of data transmitted.
         * @example 100000
         */
        amount?: number;
        /**
         * @description The unit of the amount of data transmitted.
         * @example B
         */
        unit?: string;
      };
      received?: {
        /**
         * @description The amount of data received.
         * @example 100000
         */
        amount?: number;
        /**
         * @description The unit of the amount of data received.
         * @example B
         */
        unit?: string;
      };
    };
    GlobalIpHealthCheckType: {
      /**
       * @description Identifies the type of the resource.
       * @example global_ip_health_check_type
       */
      readonly record_type?: string;
      /**
       * @description Global IP Health check type.
       * @example http_status_2xx
       */
      health_check_type?: string;
      /**
       * @description Global IP Health check params.
       * @example {
       *       "health_check_params": {
       *         "path": "str",
       *         "port": "int"
       *       }
       *     }
       */
      health_check_params?: Record<string, never>;
    };
    GlobalIpLatencyMetric: {
      /**
       * Format: date-time
       * @description The timestamp of the metric.
       * @example 2020-01-01T00:00:00.000Z
       */
      timestamp?: string;
      global_ip?: {
        /**
         * Format: uuid
         * @description Global IP ID.
         * @example a836125b-20b6-452e-9c03-2653f09c7ed7
         */
        id?: string;
        /**
         * @description The Global IP address.
         * @example null
         */
        readonly ip_address?: string;
      };
      prober_location?: {
        /**
         * Format: uuid
         * @description Location ID.
         * @example 1
         */
        id?: string;
        /**
         * @description Location name.
         * @example Amsterdam
         */
        name?: string;
        /**
         * @description Latitude.
         * @example 52.370216
         */
        lat?: number;
        /**
         * @description Longitude.
         * @example 4.895168
         */
        lon?: number;
      };
      mean_latency?: {
        /**
         * @description The average latency.
         * @example 100
         */
        amount?: number;
        /**
         * @description The unit of the average latency.
         * @example ms
         */
        unit?: string;
      };
      percentile_latency?: {
        0?: {
          /**
           * @description The minimum latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the minimum latency.
           * @example ms
           */
          unit?: string;
        };
        25?: {
          /**
           * @description The 25th percentile latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the 25th percentile latency.
           * @example ms
           */
          unit?: string;
        };
        50?: {
          /**
           * @description The 50th percentile latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the 50th percentile latency.
           * @example ms
           */
          unit?: string;
        };
        75?: {
          /**
           * @description The 75th percentile latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the 75th percentile latency.
           * @example ms
           */
          unit?: string;
        };
        90?: {
          /**
           * @description The 90th percentile latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the 90th percentile latency.
           * @example ms
           */
          unit?: string;
        };
        99?: {
          /**
           * @description The 99th percentile latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the 99th percentile latency.
           * @example ms
           */
          unit?: string;
        };
        100?: {
          /**
           * @description The maximum latency.
           * @example 100
           */
          amount?: number;
          /**
           * @description The unit of the maximum latency.
           * @example ms
           */
          unit?: string;
        };
      };
    };
    GlobalIpUsageMetric: {
      /**
       * Format: date-time
       * @description The timestamp of the metric.
       * @example 2020-01-01T00:00:00.000Z
       */
      timestamp?: string;
      global_ip?: {
        /**
         * Format: uuid
         * @description Global IP ID.
         * @example a836125b-20b6-452e-9c03-2653f09c7ed7
         */
        id?: string;
        /**
         * @description The Global IP address.
         * @example 64.1.2.130
         */
        readonly ip_address?: string;
      };
      transmitted?: {
        /**
         * @description The amount of data transmitted.
         * @example 100000
         */
        amount?: number;
        /**
         * @description The unit of the amount of data transmitted.
         * @example B
         */
        unit?: string;
      };
      received?: {
        /**
         * @description The amount of data received.
         * @example 100000
         */
        amount?: number;
        /**
         * @description The unit of the amount of data received.
         * @example B
         */
        unit?: string;
      };
    };
    /**
     * Google transcription engine list of languages
     * @description Language to use for speech recognition
     * @default en
     * @example en
     * @enum {string}
     */
    GoogleTranscriptionLanguage:
      | 'af'
      | 'sq'
      | 'am'
      | 'ar'
      | 'hy'
      | 'az'
      | 'eu'
      | 'bn'
      | 'bs'
      | 'bg'
      | 'my'
      | 'ca'
      | 'yue'
      | 'zh'
      | 'hr'
      | 'cs'
      | 'da'
      | 'nl'
      | 'en'
      | 'et'
      | 'fil'
      | 'fi'
      | 'fr'
      | 'gl'
      | 'ka'
      | 'de'
      | 'el'
      | 'gu'
      | 'iw'
      | 'hi'
      | 'hu'
      | 'is'
      | 'id'
      | 'it'
      | 'ja'
      | 'jv'
      | 'kn'
      | 'kk'
      | 'km'
      | 'ko'
      | 'lo'
      | 'lv'
      | 'lt'
      | 'mk'
      | 'ms'
      | 'ml'
      | 'mr'
      | 'mn'
      | 'ne'
      | 'no'
      | 'fa'
      | 'pl'
      | 'pt'
      | 'pa'
      | 'ro'
      | 'ru'
      | 'rw'
      | 'sr'
      | 'si'
      | 'sk'
      | 'sl'
      | 'ss'
      | 'st'
      | 'es'
      | 'su'
      | 'sw'
      | 'sv'
      | 'ta'
      | 'te'
      | 'th'
      | 'tn'
      | 'tr'
      | 'ts'
      | 'uk'
      | 'ur'
      | 'uz'
      | 've'
      | 'vi'
      | 'xh'
      | 'zu';
    /** HTTPValidationError */
    HTTPValidationError: {
      /** Detail */
      detail?: components['schemas']['ValidationError'][];
    };
    /**
     * Hangup Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    HangupRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** @example [
     *       {
     *         "record_type": "messaging_hosted_number",
     *         "id": "bf6307bd-884d-4c1f-b6ea-c62b8c495d3c",
     *         "phone_number": "+18665550001",
     *         "status": "successful"
     *       }
     *     ] */
    HostedNumber: {
      /** @example messaging_hosted_number */
      record_type?: string;
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      readonly id?: string;
      /**
       * Format: +E.164
       * @description The messaging hosted phone number (+E.164 format)
       */
      phone_number?: string;
      /** @enum {string} */
      status?: 'deleted' | 'failed' | 'pending' | 'successful';
    };
    /**
     * Format: uuid
     * @description Identifies the resource.
     * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
     */
    Id: string;
    /** ImageURL */
    ImageURL: {
      /** Url */
      url: string;
      /**
       * Detail
       * @enum {string}
       */
      detail?: 'auto' | 'low' | 'high';
    };
    /** @example [1234567890L, 9876543210L] */
    ImmutableSetLong: number[];
    /** ImportExternalVetting */
    ImportExternalVetting: {
      /**
       * Evpid
       * @description External vetting provider ID for the brand.
       */
      evpId: string;
      /**
       * Vettingid
       * @description Unique ID that identifies a vetting transaction performed by a vetting provider. This ID is provided by the vetting provider at time of vetting.
       */
      vettingId: string;
      /**
       * Vettingtoken
       * @description Required by some providers for vetting record confirmation.
       */
      vettingToken?: string;
    };
    /**
     * Inbound FQDN
     * @example {
     *       "ani_number_format": "+E.164",
     *       "dnis_number_format": "+e164",
     *       "codecs": [
     *         "G722"
     *       ],
     *       "default_routing_method": "sequential",
     *       "default_primary_fqdn_id": "1293384261075731497",
     *       "default_secondary_fqdn_id": "1293384261075731498",
     *       "default_tertiary_fqdn_id": "1293384261075731499",
     *       "channel_limit": 10,
     *       "generate_ringback_tone": true,
     *       "isup_headers_enabled": true,
     *       "prack_enabled": true,
     *       "privacy_zone_enabled": true,
     *       "sip_compact_headers_enabled": true,
     *       "sip_region": "US",
     *       "sip_subdomain": "test",
     *       "sip_subdomain_receive_settings": "only_my_connections",
     *       "timeout_1xx_secs": 10,
     *       "timeout_2xx_secs": 20,
     *       "shaken_stir_enabled": true
     *     }
     */
    InboundFqdn: {
      /**
       * @description This setting allows you to set the format with which the caller's number (ANI) is sent for inbound phone calls.
       * @default E.164-national
       * @enum {string}
       */
      ani_number_format:
        | '+E.164'
        | 'E.164'
        | '+E.164-national'
        | 'E.164-national';
      /**
       * @default e164
       * @enum {string}
       */
      dnis_number_format: '+e164' | 'e164' | 'national' | 'sip_username';
      /**
       * @description Defines the list of codecs that Telnyx will send for inbound calls to a specific number on your portal account, in priority order. This only works when the Connection the number is assigned to uses Media Handling mode: default. OPUS and H.264 codecs are available only when using TCP or TLS transport for SIP.
       * @default [
       *       "G722",
       *       "G711U",
       *       "G711A",
       *       "G729",
       *       "OPUS",
       *       "H.264"
       *     ]
       */
      codecs: string[];
      /**
       * @description Default routing method to be used when a number is associated with the connection. Must be one of the routing method types or null, other values are not allowed.
       * @default sequential
       * @enum {string|null}
       */
      default_routing_method: 'sequential' | 'round-robin';
      /**
       * Format: int64
       * @description The default primary FQDN to use for the number. Only settable if the connection is
       *     of FQDN type. Value must be the ID of an FQDN set on the connection.
       * @default null
       */
      default_primary_fqdn_id: string | null;
      /**
       * Format: int64
       * @description The default secondary FQDN to use for the number. Only settable if the connection is
       *     of FQDN type. Value must be the ID of an FQDN set on the connection.
       * @default null
       */
      default_secondary_fqdn_id: string | null;
      /**
       * Format: int64
       * @description The default tertiary FQDN to use for the number. Only settable if the connection is
       *     of FQDN type. Value must be the ID of an FQDN set on the connection.
       * @default null
       */
      default_tertiary_fqdn_id: string | null;
      /**
       * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
       * @default null
       */
      channel_limit: number | null;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description When set, inbound phone calls will receive ISUP parameters via SIP headers. (Only when available and only when using TCP or TLS transport.)
       * @default false
       */
      isup_headers_enabled: boolean;
      /**
       * @description Enable PRACK messages as defined in RFC3262.
       * @default false
       */
      prack_enabled: boolean;
      /**
       * @description By default, Telnyx does not send caller-id information when the caller has chosen to hide this information. When this option is enabled, Telnyx will send the SIP header Privacy:id plus the caller-id information so that the receiver side can choose when to hide it.
       * @default false
       */
      privacy_zone_enabled: boolean;
      /**
       * @description Defaults to true.
       * @default true
       */
      sip_compact_headers_enabled: boolean;
      /**
       * @description Selects which `sip_region` to receive inbound calls from. If null, the default region (US) will be used.
       * @default US
       * @enum {string}
       */
      sip_region: 'US' | 'Europe' | 'Australia';
      /**
       * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
       * @default null
       */
      sip_subdomain: string | null;
      /**
       * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
       * @default from_anyone
       * @enum {string}
       */
      sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      /**
       * @description Time(sec) before aborting if connection is not made.
       * @default 3
       */
      timeout_1xx_secs: number;
      /**
       * @description Time(sec) before aborting if call is unanswered (min: 1, max: 600).
       * @default 90
       */
      timeout_2xx_secs: number;
      /**
       * @description When enabled the SIP Connection will receive the Identity header with Shaken/Stir data in the SIP INVITE message of inbound calls, even when using UDP transport.
       * @default false
       */
      shaken_stir_enabled: boolean;
    };
    /**
     * Inbound Ip
     * @example {
     *       "ani_number_format": "+E.164",
     *       "dns_number_format": "+e164",
     *       "codecs": "G722",
     *       "default_primary_ip_id": "192.168.0.0",
     *       "default_tertiary_ip_id": "192.168.0.0",
     *       "default_secondary_ip_id": "192.168.0.0",
     *       "default_routing_method": "sequential",
     *       "channel_limit": 10,
     *       "generate_ringback_tone": true,
     *       "isup_headers_enabled": true,
     *       "prack_enabled": true,
     *       "privacy_zone_enabled": true,
     *       "sip_compact_headers_enabled": true,
     *       "sip_region": "US",
     *       "sip_subdomain": "test",
     *       "sip_subdomain_receive_settings": "only_my_connections",
     *       "timeout_1xx_secs": 10,
     *       "timeout_2xx_secs": 20,
     *       "shaken_stir_enabled": true
     *     }
     */
    InboundIp: {
      /**
       * @description This setting allows you to set the format with which the caller's number (ANI) is sent for inbound phone calls.
       * @default E.164-national
       * @enum {string}
       */
      ani_number_format:
        | '+E.164'
        | 'E.164'
        | '+E.164-national'
        | 'E.164-national';
      /**
       * @default e164
       * @enum {string}
       */
      dnis_number_format: '+e164' | 'e164' | 'national' | 'sip_username';
      /**
       * @description Defines the list of codecs that Telnyx will send for inbound calls to a specific number on your portal account, in priority order. This only works when the Connection the number is assigned to uses Media Handling mode: default. OPUS and H.264 codecs are available only when using TCP or TLS transport for SIP.
       * @default [
       *       "G722",
       *       "G711U",
       *       "G711A",
       *       "G729",
       *       "OPUS",
       *       "H.264"
       *     ]
       */
      codecs: string[];
      /**
       * @description The default primary IP to use for the number. Only settable if the connection is
       *                   of IP authentication type. Value must be the ID of an authorized IP set on the connection.
       * @example 192.168.0.0
       */
      default_primary_ip_id?: string;
      /**
       * @description The default secondary IP to use for the number. Only settable if the connection is
       *                   of IP authentication type. Value must be the ID of an authorized IP set on the connection.
       * @example 192.168.0.0
       */
      default_secondary_ip_id?: string;
      /**
       * @description The default tertiary IP to use for the number. Only settable if the connection is
       *                   of IP authentication type. Value must be the ID of an authorized IP set on the connection.
       * @example 192.168.0.0
       */
      default_tertiary_ip_id?: string;
      /**
       * @description Default routing method to be used when a number is associated with the connection. Must be one of the routing method types or left blank, other values are not allowed.
       * @enum {string}
       */
      default_routing_method?: 'sequential' | 'round-robin';
      /**
       * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
       * @default null
       * @example 10
       */
      channel_limit: number;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description When set, inbound phone calls will receive ISUP parameters via SIP headers. (Only when available and only when using TCP or TLS transport.)
       * @default false
       */
      isup_headers_enabled: boolean;
      /**
       * @description Enable PRACK messages as defined in RFC3262.
       * @default false
       */
      prack_enabled: boolean;
      /**
       * @description By default, Telnyx does not send caller-id information when the caller has chosen to hide this information. When this option is enabled, Telnyx will send the SIP header Privacy:id plus the caller-id information so that the receiver side can choose when to hide it.
       * @default false
       */
      privacy_zone_enabled: boolean;
      /**
       * @description Defaults to true.
       * @default true
       */
      sip_compact_headers_enabled: boolean;
      /**
       * @description Selects which `sip_region` to receive inbound calls from. If null, the default region (US) will be used.
       * @default US
       * @enum {string}
       */
      sip_region: 'US' | 'Europe' | 'Australia';
      /** @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls. */
      sip_subdomain?: string;
      /**
       * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
       * @enum {string}
       */
      sip_subdomain_receive_settings?: 'only_my_connections' | 'from_anyone';
      /**
       * @description Time(sec) before aborting if connection is not made.
       * @default 3
       */
      timeout_1xx_secs: number;
      /**
       * @description Time(sec) before aborting if call is unanswered (min: 1, max: 600).
       * @default 90
       */
      timeout_2xx_secs: number;
      /**
       * @description When enabled the SIP Connection will receive the Identity header with Shaken/Stir data in the SIP INVITE message of inbound calls, even when using UDP transport.
       * @default false
       */
      shaken_stir_enabled: boolean;
    };
    /** @example {
     *       "record_type": "event",
     *       "id": "bf6307bd-884d-4c1f-b6ea-c62b8c495d3c",
     *       "event_type": "message.received",
     *       "occurred_at": "date-time",
     *       "payload": {
     *         "record_type": "message",
     *         "direction": "inbound",
     *         "id": "7ee4241c-f127-47e5-9c34-3aac291f8058",
     *         "type": "SMS",
     *         "messaging_profile_id": "0f512bda-ae1e-4597-8e11-e5f5686b97d3",
     *         "organization_id": "b448f9cc-a842-4784-98e9-03c1a5872950",
     *         "from": {
     *           "phone_number": "+18665550001",
     *           "carrier": "T-MOBILE USA, INC.",
     *           "line_type": "Wireless"
     *         },
     *         "to": [
     *           {
     *             "phone_number": "+18445550001",
     *             "status": "delivered",
     *             "carrier": "TELNYX LLC",
     *             "line_type": "VoIP"
     *           }
     *         ],
     *         "text": "Hello, World!",
     *         "subject": "From Telnyx!",
     *         "media": [],
     *         "webhook_url": "https://www.example.com/hooks",
     *         "webhook_failover_url": "https://backup.example.com/hooks",
     *         "encoding": "GSM-7",
     *         "parts": 1,
     *         "tags": [
     *           "Greetings"
     *         ],
     *         "cost": null,
     *         "received_at": "2019-01-23T18:10:02.574Z",
     *         "sent_at": null,
     *         "completed_at": null,
     *         "valid_until": null,
     *         "errors": []
     *       }
     *     } */
    InboundMessage: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      id?: string;
      /**
       * @description The type of event being delivered.
       * @example message.received
       * @enum {string}
       */
      event_type?: 'message.received';
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      occurred_at?: string;
      payload?: components['schemas']['InboundMessagePayload'];
    };
    InboundMessageEvent: {
      data?: components['schemas']['InboundMessage'];
    };
    /** @example {
     *       "record_type": "message",
     *       "direction": "inbound",
     *       "id": "7ee4241c-f127-47e5-9c34-3aac291f8058",
     *       "type": "SMS",
     *       "messaging_profile_id": "0f512bda-ae1e-4597-8e11-e5f5686b97d3",
     *       "organization_id": "b448f9cc-a842-4784-98e9-03c1a5872950",
     *       "from": {
     *         "phone_number": "+18665550001",
     *         "status": "delivered",
     *         "carrier": "T-MOBILE USA, INC.",
     *         "line_type": "Wireless"
     *       },
     *       "to": [
     *         {
     *           "phone_number": "+18445550001",
     *           "status": "delivered",
     *           "carrier": "TELNYX LLC",
     *           "line_type": "VoIP"
     *         }
     *       ],
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media": [],
     *       "webhook_url": "https://www.example.com/hooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "encoding": "GSM-7",
     *       "parts": 1,
     *       "tags": [
     *         "Greetings"
     *       ],
     *       "cost": null,
     *       "received_at": "2019-01-23T18:10:02.574Z",
     *       "sent_at": null,
     *       "completed_at": null,
     *       "valid_until": null,
     *       "errors": []
     *     } */
    InboundMessagePayload: {
      /**
       * @description Identifies the type of the resource.
       * @example message
       * @enum {string}
       */
      record_type?: 'message';
      /**
       * @description The direction of the message. Inbound messages are sent to you whereas outbound messages are sent from you.
       * @example inbound
       * @enum {string}
       */
      direction?: 'inbound';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      id?: string;
      /**
       * @description The type of message. This value can be either 'sms' or 'mms'.
       * @enum {string}
       */
      type?: 'SMS' | 'MMS';
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id?: string;
      to?: {
        /**
         * Format: address
         * @description Receiving address (+E.164 formatted phone number or short code).
         */
        phone_number?: string;
        /** @enum {string} */
        status?:
          | 'queued'
          | 'sending'
          | 'sent'
          | 'delivered'
          | 'sending_failed'
          | 'delivery_failed'
          | 'delivery_unconfirmed'
          | 'webhook_delivered';
        /** @description The carrier of the receiver. */
        carrier?: string;
        /**
         * @description The line-type of the receiver.
         * @enum {string}
         */
        line_type?:
          | 'Wireline'
          | 'Wireless'
          | 'VoWiFi'
          | 'VoIP'
          | 'Pre-Paid Wireless'
          | '';
      }[];
      cc?: {
        /**
         * Format: address
         * @description Receiving address (+E.164 formatted phone number or short code).
         */
        phone_number?: string;
        /** @enum {string} */
        status?:
          | 'queued'
          | 'sending'
          | 'sent'
          | 'delivered'
          | 'sending_failed'
          | 'delivery_failed'
          | 'delivery_unconfirmed';
        /** @description The carrier of the receiver. */
        carrier?: string;
        /**
         * @description The line-type of the receiver.
         * @enum {string}
         */
        line_type?:
          | 'Wireline'
          | 'Wireless'
          | 'VoWiFi'
          | 'VoIP'
          | 'Pre-Paid Wireless'
          | '';
      }[];
      from?: {
        /**
         * Format: address
         * @description Sending address (+E.164 formatted phone number, alphanumeric sender ID, or short code).
         */
        phone_number?: string;
        /** @enum {string} */
        status?: 'received' | 'delivered';
        /** @description The carrier of the sender. */
        carrier?: string;
        /**
         * @description The line-type of the sender.
         * @enum {string}
         */
        line_type?:
          | 'Wireline'
          | 'Wireless'
          | 'VoWiFi'
          | 'VoIP'
          | 'Pre-Paid Wireless'
          | '';
      };
      /** @description Message body (i.e., content) as a non-empty string.
       *
       *     **Required for SMS** */
      text?: string;
      media?: {
        /**
         * Format: url
         * @description The url of the media requested to be sent.
         */
        url?: string;
        /**
         * Format: mime-type
         * @description The MIME type of the requested media.
         */
        content_type?: string;
        /** @description The size of the requested media. */
        size?: number;
        /** @description The SHA256 hash of the requested media. */
        hash_sha256?: string;
      }[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string | null;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string | null;
      /** @description Encoding scheme used for the message body. */
      encoding?: string;
      /** @description Number of parts into which the message's body must be split. */
      parts?: number;
      /** @description Tags associated with the resource. */
      tags?: string[];
      cost?: {
        /**
         * Format: decimal
         * @description The amount deducted from your account.
         */
        amount?: string;
        /**
         * Format: iso4217
         * @description The ISO 4217 currency identifier.
         */
        currency?: string;
      } | null;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the message request was received.
       */
      received_at?: string;
      /**
       * Format: date-time
       * @description Not used for inbound messages.
       */
      sent_at?: string | null;
      /**
       * Format: date-time
       * @description Not used for inbound messages.
       */
      completed_at?: string | null;
      /**
       * Format: date-time
       * @description Not used for inbound messages.
       */
      valid_until?: string | null;
      /** @description These errors may point at addressees when referring to unsuccessful/unconfirmed delivery statuses. */
      errors?: components['schemas']['Error'][];
    };
    /** InferenceRequest */
    InferenceRequest: {
      /** Text */
      text: string[];
      /** @default mistralai/Mistral-7B-Instruct-v0.1 */
      model: components['schemas']['ModelNamespace'];
      /** Bucket */
      bucket?: string;
      /** Openai Api Key */
      openai_api_key?: string;
      /**
       * Max Tokens
       * @default 128
       */
      max_tokens: number;
      /**
       * Temperature
       * @default 0.9
       */
      temperature: number;
    };
    /** InferenceResponse */
    InferenceResponse: {
      /** Answer */
      answer: string[];
    };
    /** InferenceResponseData */
    InferenceResponseData: {
      data: components['schemas']['InferenceResponse'];
    };
    /** InferenceResponseStreamData */
    InferenceResponseStreamData: {
      data: components['schemas']['InferenceStreamResponse'];
    };
    /** InferenceStreamResponse */
    InferenceStreamResponse: {
      token?: string;
    };
    /**
     * Initiate Call Request
     * @example {
     *       "To": "+13121230000",
     *       "From": "+13120001234",
     *       "Url": "https://www.example.com/texml.xml",
     *       "StatusCallback": "https://www.example.com/statuscallback-listener"
     *     }
     */
    InitiateCallRequest: {
      /** @description The ID of the TeXML Application. */
      ApplicationSid: string;
      /**
       * @description The phone number of the called party. Phone numbers are formatted with a `+` and country code.
       * @example +16175551212
       */
      To: string;
      /**
       * @description The phone number of the party that initiated the call. Phone numbers are formatted with a `+` and country code.
       * @example +16175551212
       */
      From: string;
      /**
       * @description The URL from which Telnyx will retrieve the TeXML call instructions.
       * @example https://www.example.com/instructions.xml
       */
      Url?: string;
      /**
       * @description HTTP request type used for `Url`. The default value is inherited from TeXML Application setting.
       * @default POST
       * @example GET
       * @enum {string}
       */
      UrlMethod: 'GET' | 'POST';
      /**
       * @description A failover URL for which Telnyx will retrieve the TeXML call instructions if the `Url` is not responding.
       * @example https://www.example.com/instructions-fallback.xml
       */
      FallbackUrl?: string;
      /**
       * @description URL destination for Telnyx to send status callback events to for the call.
       * @example https://www.example.com/callback
       */
      StatusCallback?: string;
      /**
       * @description HTTP request type used for `StatusCallback`.
       * @default POST
       * @example GET
       * @enum {string}
       */
      StatusCallbackMethod: 'GET' | 'POST';
      /**
       * @description The call events for which Telnyx should send a webhook. Multiple events can be defined when separated by a space.
       * @default completed
       * @example iniated ringing
       * @enum {string}
       */
      StatusCallbackEvent: 'initiated' | 'ringing' | 'answered' | 'completed';
      /**
       * @description Enables Answering Machine Detection.
       * @default Disable
       * @example Enable
       * @enum {string}
       */
      MachineDetection: 'Enable' | 'Disable' | 'DetectMessageEnd';
      /**
       * @description Allows you to chose between Premium and Standard detections.
       * @default Regular
       * @example Premium
       * @enum {string}
       */
      DetectionMode: 'Premium' | 'Regular';
      /**
       * @description Select whether to perform answering machine detection in the background. By default execution is blocked until Answering Machine Detection is completed.
       * @default false
       * @example true
       */
      AsyncAmd: boolean;
      /**
       * @description URL destination for Telnyx to send AMD callback events to for the call.
       * @example https://www.example.com/callback
       */
      AsyncAmdStatusCallback?: string;
      /**
       * @description HTTP request type used for `AsyncAmdStatusCallback`. The default value is inherited from TeXML Application setting.
       * @default POST
       * @example GET
       * @enum {string}
       */
      AsyncAmdStatusCallbackMethod: 'GET' | 'POST';
      /**
       * @description Maximum timeout threshold in milliseconds for overall detection.
       * @default 30000
       * @example 5000
       */
      MachineDetectionTimeout: number;
      /**
       * @description Maximum threshold of a human greeting. If greeting longer than this value, considered machine. Ignored when `premium` detection is used.
       * @default 3500
       * @example 2000
       */
      MachineDetectionSpeechThreshold: number;
      /**
       * @description Silence duration threshold after a greeting message or voice for it be considered human. Ignored when `premium` detection is used.
       * @default 800
       * @example 2000
       */
      MachineDetectionSpeechEndThreshold: number;
      /**
       * @description If initial silence duration is greater than this value, consider it a machine. Ignored when `premium` detection is used.
       * @default 3500
       * @example 2000
       */
      MachineDetectionSilenceTimeout: number;
      /**
       * @description Whether to cancel ongoing playback on `machine` detection. Defaults to `true`.
       * @default true
       * @example false
       */
      CancelPlaybackOnMachineDetection: boolean;
      /**
       * @description Whether to cancel ongoing playback on `greeting ended` detection. Defaults to `true`.
       * @default true
       * @example false
       */
      CancelPlaybackOnDetectMessageEnd: boolean;
      /**
       * @description The list of comma-separated codecs to be offered on a call.
       * @example PCMA,PCMU
       */
      PreferredCodecs?: string;
      /**
       * @description Whether to record the entire participant's call leg. Defaults to `false`.
       * @example false
       */
      Record?: boolean;
      /**
       * @description The number of channels in the final recording. Defaults to `mono`.
       * @example dual
       * @enum {string}
       */
      RecordingChannels?: 'mono' | 'dual';
      /**
       * @description The URL the recording callbacks will be sent to.
       * @example https://example.com/recording_status_callback
       */
      RecordingStatusCallback?: string;
      /**
       * @description HTTP request type used for `RecordingStatusCallback`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      RecordingStatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description The changes to the recording's state that should generate a call to `RecoridngStatusCallback`. Can be: `in-progress`, `completed` and `absent`. Separate multiple values with a space. Defaults to `completed`.
       * @example in-progress completed absent
       */
      RecordingStatusCallbackEvent?: string;
      /**
       * @description The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected. The timer only starts when the speech is detected. Please note that the transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite)
       * @default 0
       * @example 5
       */
      RecordingTimeout: number;
      /**
       * @description The audio track to record for the call. The default is `both`.
       * @example inbound
       * @enum {string}
       */
      RecordingTrack?: 'inbound' | 'outbound' | 'both';
      /**
       * @description The password to use for SIP authentication.
       * @example 1234
       */
      SipAuthPassword?: string;
      /**
       * @description The username to use for SIP authentication.
       * @example user
       */
      SipAuthUsername?: string;
      /**
       * @description Whether to trim any leading and trailing silence from the recording. Defaults to `trim-silence`.
       * @example false
       * @enum {string}
       */
      Trim?: 'trim-silence' | 'do-not-trim';
    };
    /**
     * Initaite TeXML Call Result
     * @example {
     *       "from": "+13120001234",
     *       "to": "+13121230000",
     *       "status": "queued"
     *     }
     */
    InitiateCallResult: {
      /** @example +13120001234 */
      from?: string;
      /** @example +13120000000 */
      to?: string;
      /** @example accepted */
      status?: string;
    };
    /**
     * Int ID
     * Format: int64
     * @description Uniquely identifies the resource.
     * @example 1293384261075731499
     */
    IntId: string;
    Interface: {
      /**
       * Format: uuid
       * @description The id of the network associated with the interface.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      network_id?: string;
      /**
       * @description A user specified name for the interface.
       * @example test interface
       */
      name?: string;
      status?: components['schemas']['InterfaceStatus'];
    };
    /**
     * @description The current status of the interface deployment.
     * @example provisioned
     * @enum {string}
     */
    InterfaceStatus: 'created' | 'provisioning' | 'provisioned' | 'deleting';
    /** @example {
     *       "group": "318",
     *       "group_type": "npa",
     *       "number_range": 1,
     *       "number_type": "did",
     *       "phone_number_type": "local",
     *       "coverage_type": "number",
     *       "record_type": "inventory_coverage_group",
     *       "administrative_area": "NJ",
     *       "count": 3,
     *       "advance_requirements": true
     *     } */
    InventoryCoverage: {
      /** @example 318 */
      group?: string;
      /** @example npa */
      group_type?: string;
      /** @example 1 */
      number_range?: number;
      /**
       * @example did
       * @enum {string}
       */
      number_type?: 'did' | 'toll-free';
      /**
       * @example local
       * @enum {string}
       */
      phone_number_type?:
        | 'local'
        | 'toll_free'
        | 'national'
        | 'landline'
        | 'shared_cost'
        | 'mobile';
      /**
       * @example number
       * @enum {string}
       */
      coverage_type?: 'number' | 'block';
      /** @example inventory_coverage_group */
      record_type?: string;
      /** @example NJ */
      administrative_area?: string;
      /** @example 3 */
      count?: number;
      /**
       * @description Indicates if the phone number requires advance requirements.
       * @example true
       */
      advance_requirements?: boolean;
    };
    /** @example {
     *       "total_results": 25
     *     } */
    InventoryCoverageMetadata: {
      /** @example 25 */
      total_results?: number;
    };
    /**
     * Ip
     * @example {
     *       "id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "record_type": "ip",
     *       "connection_id": "3456789987654",
     *       "ip_address": "192.168.0.0",
     *       "port": 5060,
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     }
     */
    Ip: {
      /**
       * Format: int64
       * @description Identifies the type of resource.
       * @example 1293384261075731499
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example ip
       */
      record_type?: string;
      /** @description ID of the IP Connection to which this IP should be attached. */
      connection_id?: string;
      /**
       * @description IP adddress represented by this resource.
       * @example 192.168.0.0
       */
      ip_address?: string;
      /**
       * @description Port to use when connecting to this IP.
       * @default 5060
       * @example 5060
       */
      port: number;
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /**
     * Ip Connection
     * @example {
     *       "id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "record_type": "ip_connection",
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "transport_protocol": "UDP",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_secs": 10
     *       },
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z",
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": [
     *           "G722"
     *         ],
     *         "default_primary_ip_id": "192.0.2.1",
     *         "default_secondary_ip_id": "198.51.100.1",
     *         "default_tertiary_ip_id": "203.0.113.1",
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "sip_region": "US",
     *         "sip_subdomain": "string",
     *         "sip_subdomain_receive_settings": "only_my_connections",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 10,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "call_parking_enabled": true,
     *         "ani_override": "string",
     *         "ani_override_type": "always",
     *         "channel_limit": 10,
     *         "instant_ringback_enabled": true,
     *         "generate_ringback_tone": true,
     *         "localization": "string",
     *         "t38_reinvite_source": "customer",
     *         "tech_prefix": "string",
     *         "ip_authentication_method": "token",
     *         "ip_authentication_token": "string",
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    IpConnection: {
      /**
       * Format: int64
       * @description Identifies the type of resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example ip_connection
       */
      record_type?: string;
      /**
       * @description Defaults to true
       * @example true
       */
      active?: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      /** @example string */
      connection_name?: string;
      /**
       * @description One of UDP, TLS, or TCP. Applies only to connections with IP authentication or FQDN authentication.
       * @default UDP
       * @example UDP
       * @enum {string}
       */
      transport_protocol: 'UDP' | 'TCP' | 'TLS';
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       * @example true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       * @example true
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       * @example false
       */
      onnet_t38_passthrough_enabled: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
      inbound?: components['schemas']['InboundIp'];
      outbound?: components['schemas']['OutboundIp'];
    };
    /**
     * Join Conference Request
     * @example {
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "end_conference_on_exit": true,
     *       "hold": true,
     *       "hold_audio_url": "http://www.example.com/audio.wav",
     *       "mute": true,
     *       "start_conference_on_enter": true,
     *       "supervisor_role": "whisper",
     *       "whisper_call_control_ids": [
     *         "v2:Sg1xxxQ_U3ixxxyXT_VDNI3xxxazZdg6Vxxxs4-GNYxxxVaJPOhFMRQ",
     *         "v2:qqpb0mmvd-ovhhBr0BUQQn0fld5jIboaaX3-De0DkqXHzbf8d75xkw"
     *       ],
     *       "beep_enabled": "always"
     *     }
     */
    JoinConferenceRequest: {
      /**
       * @description Unique identifier and token for controlling the call
       * @example v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQczRrZvZakpWxBlpw48KyZQ==
       */
      call_control_id: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string. Please note that the client_state will be updated for the participient call leg and the change will not affect conferencing webhooks unless the participient is the owner of the conference.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid execution of duplicate commands. Telnyx will ignore subsequent commands with the same `command_id` as one that has already been executed.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Whether the conference should end and all remaining participants be hung up after the participant leaves the conference. Defaults to "false".
       * @example true
       */
      end_conference_on_exit?: boolean;
      /**
       * @description Whether the conference should end after the participant leaves the conference. NOTE this doesn't hang up the other participants. Defaults to "false".
       * @example true
       */
      soft_end_conference_on_exit?: boolean;
      /**
       * @description Whether the participant should be put on hold immediately after joining the conference. Defaults to "false".
       * @example true
       */
      hold?: boolean;
      /**
       * @description The URL of a file to be played to the participant when they are put on hold after joining the conference. hold_media_name and hold_audio_url cannot be used together in one request. Takes effect only when "start_conference_on_create" is set to "false". This property takes effect only if "hold" is set to "true".
       * @example http://example.com/message.wav
       */
      hold_audio_url?: string;
      /**
       * @description The media_name of a file to be played to the participant when they are put on hold after joining the conference. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file. Takes effect only when "start_conference_on_create" is set to "false". This property takes effect only if "hold" is set to "true".
       * @example my_media_uploaded_to_media_storage_api
       */
      hold_media_name?: string;
      /**
       * @description Whether the participant should be muted immediately after joining the conference. Defaults to "false".
       * @example true
       */
      mute?: boolean;
      /**
       * @description Whether the conference should be started after the participant joins the conference. Defaults to "false".
       * @example true
       */
      start_conference_on_enter?: boolean;
      /**
       * @description Sets the joining participant as a supervisor for the conference. A conference can have multiple supervisors. "barge" means the supervisor enters the conference as a normal participant. This is the same as "none". "monitor" means the supervisor is muted but can hear all participants. "whisper" means that only the specified "whisper_call_control_ids" can hear the supervisor. Defaults to "none".
       * @example whisper
       * @enum {string}
       */
      supervisor_role?: 'barge' | 'monitor' | 'none' | 'whisper';
      /**
       * @description Array of unique call_control_ids the joining supervisor can whisper to. If none provided, the supervisor will join the conference as a monitoring participant only.
       * @example [
       *       "v2:Sg1xxxQ_U3ixxxyXT_VDNI3xxxazZdg6Vxxxs4-GNYxxxVaJPOhFMRQ",
       *       "v2:qqpb0mmvd-ovhhBr0BUQQn0fld5jIboaaX3-De0DkqXHzbf8d75xkw"
       *     ]
       */
      whisper_call_control_ids?: string[];
      /**
       * @description Whether a beep sound should be played when the participant joins and/or leaves the conference. Can be used to override the conference-level setting.
       * @example on_exit
       * @enum {string}
       */
      beep_enabled?: 'always' | 'never' | 'on_enter' | 'on_exit';
    };
    /** Format: date-time */
    LastModified: string;
    /**
     * Leave Conference Request
     * @example {
     *       "call_control_id": "c46e06d7-b78f-4b13-96b6-c576af9640ff",
     *       "beep_enabled": "never"
     *     }
     */
    LeaveConferenceRequest: {
      /**
       * @description Unique identifier and token for controlling the call
       * @example f91269aa-61d1-417f-97b3-10e020e8bc47
       */
      call_control_id: string;
      /**
       * @description Use this field to avoid execution of duplicate commands. Telnyx will ignore subsequent commands with the same `command_id` as one that has already been executed.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Whether a beep sound should be played when the participant leaves the conference. Can be used to override the conference-level setting.
       * @example on_exit
       * @enum {string}
       */
      beep_enabled?: 'always' | 'never' | 'on_enter' | 'on_exit';
    };
    /**
     * Leave Queue Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    LeaveQueueRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** @example {
     *       "record_type": "ledger_billing_group_report",
     *       "id": "f5586561-8ff0-4291-a0ac-84fe544797bd",
     *       "organization_id": "f5586561-8ff0-4291-a0ac-84fe544797bd",
     *       "report_url": "https://example.com",
     *       "created_at": "2019-10-15T10:07:15.527Z",
     *       "updated_at": "2019-10-15T10:07:15.527Z"
     *     } */
    LedgerBillingGroupReport: {
      /**
       * @description Identifies the type of the resource.
       * @example ledger_billing_group_report
       * @enum {string}
       */
      record_type?: 'ledger_billing_group_report';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      id?: string;
      /**
       * Format: uuid
       * @description Uniquely identifies the organization that owns the resource.
       */
      organization_id?: string;
      /**
       * Format: string
       * @description Status of the ledger billing group report
       * @enum {string}
       */
      status?: 'pending' | 'complete' | 'failed' | 'deleted';
      /**
       * Format: string
       * @description External url of the ledger billing group report, if the status is complete
       */
      report_url?: string | null;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       */
      updated_at?: string;
    };
    ListBucketsResponse: {
      Buckets?: {
        Name?: string;
        /** Format: date-time */
        CreationDate?: string;
      }[];
    };
    ListObjectsResponse: {
      Name?: string;
      Contents?: {
        Key?: string;
        Size?: number;
        /** Format: date-time */
        LastModified?: string;
      }[];
    };
    /** ListVerificationsResponse */
    ListVerificationsResponse: {
      data: components['schemas']['Verification'][];
      meta: components['schemas']['Meta'];
    };
    /**
     * ListVerifiedNumbersResponse
     * @description A paginated list of Verified Numbers
     */
    ListVerifiedNumbersResponse: {
      data: components['schemas']['VerifiedNumberResponse'][];
      meta: components['schemas']['Meta'];
    };
    /**
     * ListVerifyProfileMessageTemplateResponse
     * @description A list of Verify profile message templates
     */
    ListVerifyProfileMessageTemplateResponse: {
      data: components['schemas']['VerifyProfileMessageTemplateResponse'][];
    };
    /**
     * ListVerifyProfilesResponse
     * @description A paginated list of Verify profiles
     */
    ListVerifyProfilesResponse: {
      data: components['schemas']['VerifyProfileResponse'][];
      meta: components['schemas']['Meta'];
    };
    /** Location */
    Location: {
      id?: components['schemas']['UUID'];
      /** @example Main building, Suite 504 */
      additional_info?: string;
      /** @example Chicago Office */
      description?: string;
      /** @description Represents whether the location is the default or not. */
      is_default?: boolean;
    };
    LocationResponse: {
      data?: {
        /** Format: uuid */
        location_id?: string;
        /** Format: uuid */
        static_emergency_address_id?: string;
        accepted_address_suggestions?: boolean;
      };
    };
    LogMessage: {
      /**
       * Format: integer
       * @example 10015
       */
      code: string;
      /** @example Invalid attribute */
      title: string;
      /** @example The value provided for the attribute is not valid. Check the value used and try again. */
      detail?: string;
      source?: {
        /**
         * Format: json-pointer
         * @description JSON pointer (RFC6901) to the offending entity.
         * @example /attribute
         */
        pointer?: string;
      };
      meta?: {
        /**
         * @description The telephone number the log message is associated with, if any.
         * @example +12345678
         */
        telephone_number?: string;
        /**
         * Format: int64
         * @description The external connection the log message is associated with, if any.
         * @example 1293384261075731499
         */
        external_connection_id?: string;
        /**
         * Format: uuid
         * @description The ticket ID for an operation that generated the log message, if any.
         * @example 542c3bca-d247-42bc-8fe7-e01d16ecd761
         */
        ticket_id?: string;
      };
    };
    Loopcount: string | number;
    /** ManagedAccount */
    ManagedAccount: {
      /**
       * @description Identifies the type of the resource.
       * @example managed_account
       * @enum {string}
       */
      record_type: 'managed_account';
      /**
       * Format: UUID
       * @description Uniquely identifies the managed account.
       * @example f65ceda4-6522-4ad6-aede-98de83385123
       */
      id: string;
      /**
       * Format: email
       * @description The managed account's email.
       * @example user@example.com
       */
      email: string;
      /**
       * @description The managed account's V2 API access key
       * @example KEY01236170692E74656C6E79782E636F6D_YmlnIGlyb24gaXMgZGVhZA
       */
      api_key: string;
      /**
       * @description The manager account's email, which serves as the V1 API user identifier
       * @example managed_account@example.com
       */
      api_user: string;
      /**
       * @description The managed account's V1 API token
       * @example x6oexQNHTs-fZ7-QsDMOeg
       */
      api_token: string;
      /**
       * @description The organization the managed account is associated with.
       * @example Example Company LLC
       */
      organization_name?: string;
      /**
       * @description The ID of the manager account associated with the managed account.
       * @example f65ceda4-6522-4ad6-aede-98de83385123
       */
      manager_account_id: string;
      balance?: components['schemas']['ManagedAccountBalance'];
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at: string;
      /**
       * @description Boolean value that indicates if the managed account is able to have custom pricing set for it or not. If false, uses the pricing of the manager account. Defaults to false. There may be time lag between when the value is changed and pricing changes take effect.
       * @example true
       */
      managed_account_allow_custom_pricing?: boolean;
      /**
       * @description Boolean value that indicates if the billing information and charges to the managed account "roll up" to the manager account. If true, the managed account will not have its own balance and will use the shared balance with the manager account. This value cannot be changed after account creation without going through Telnyx support as changes require manual updates to the account ledger. Defaults to false.
       * @example false
       */
      rollup_billing?: boolean;
    };
    /** @example {
     *       "record_type": "balance",
     *       "balance": "300.00",
     *       "credit_limit": "100.00",
     *       "available_credit": "400.00",
     *       "currency": "USD"
     *     } */
    ManagedAccountBalance: {
      /**
       * @description Identifies the type of the resource.
       * @example balance
       * @enum {string}
       */
      record_type?: 'balance';
      /**
       * Format: decimal
       * @description The account's current balance.
       * @example 300.00
       */
      balance?: string;
      /**
       * Format: decimal
       * @description The account's credit limit.
       * @example 100.00
       */
      credit_limit?: string;
      /**
       * Format: decimal
       * @description Available amount to spend (balance + credit limit)
       * @example 400.00
       */
      available_credit?: string;
      /**
       * Format: iso4217
       * @description The ISO 4217 currency identifier.
       * @example USD
       */
      currency?: string;
    };
    /** ManagedAccount */
    ManagedAccountMultiListing: {
      /**
       * @description Identifies the type of the resource.
       * @example managed_account
       * @enum {string}
       */
      record_type: 'managed_account';
      /**
       * Format: UUID
       * @description Uniquely identifies the managed account.
       * @example f65ceda4-6522-4ad6-aede-98de83385123
       */
      id: string;
      /**
       * Format: email
       * @description The managed account's email.
       * @example user@example.com
       */
      email: string;
      /**
       * @description The manager account's email, which serves as the V1 API user identifier
       * @example managed_account@example.com
       */
      api_user: string;
      /**
       * @description The organization the managed account is associated with.
       * @example Example Company LLC
       */
      organization_name?: string;
      /**
       * @description The ID of the manager account associated with the managed account.
       * @example f65ceda4-6522-4ad6-aede-98de83385123
       */
      manager_account_id: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at: string;
      /**
       * @description Boolean value that indicates if the managed account is able to have custom pricing set for it or not. If false, uses the pricing of the manager account. Defaults to false. There may be time lag between when the value is changed and pricing changes take effect.
       * @example true
       */
      managed_account_allow_custom_pricing?: boolean;
      /**
       * @description Boolean value that indicates if the billing information and charges to the managed account "roll up" to the manager account. If true, the managed account will not have its own balance and will use the shared balance with the manager account. This value cannot be changed after account creation without going through Telnyx support as changes require manual updates to the account ledger. Defaults to false.
       * @example false
       */
      rollup_billing?: boolean;
    };
    /**
     * Managed Accounts Global Outbound Channels
     * @example {
     *       "allocatable_global_outbound_channels": 500,
     *       "record_type": "allocatable_global_outbound_channels",
     *       "total_global_channels_allocated": 135
     *     }
     */
    ManagedAccountsGlobalOutboundChannels: {
      /**
       * @description Boolean value that indicates if the managed account is able to have custom pricing set for it or not. If false, uses the pricing of the manager account. Defaults to false. This value may be changed, but there may be time lag between when the value is changed and pricing changes take effect.
       * @example false
       */
      managed_account_allow_custom_pricing?: boolean;
      /**
       * @description The total amount of allocatable global outbound channels available to the authenticated manager. Will be 0 if the feature is not enabled for their account.
       * @example 500
       */
      allocatable_global_outbound_channels?: number;
      /**
       * @description The type of the data contained in this record.
       * @example allocatable_global_outbound_channels
       */
      record_type?: string;
      /**
       * @description The total number of allocatable global outbound channels currently allocated across all managed accounts for the authenticated user. This includes any amount of channels allocated by default at managed account creation time. Will be 0 if the feature is not enabled for their account.
       * @example 135
       */
      total_global_channels_allocated?: number;
    };
    MdrDeleteDetailReportResponse: {
      data?: components['schemas']['MdrDetailReportResponse'];
    };
    MdrDeleteUsageReportsResponse: {
      data?: components['schemas']['MdrUsageReportResponse'];
    };
    MdrDetailReportResponse: {
      /**
       * Format: uuid
       * @description Identifies the resource
       */
      id?: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      start_date?: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      end_date?: string;
      directions?: ('INBOUND' | 'OUTBOUND')[];
      record_types?: ('INCOMPLETE' | 'COMPLETED' | 'ERRORS')[];
      connections?: number[];
      /** @example report_name_8hvb45Gu */
      report_name?: string;
      /** @enum {string} */
      status?: 'PENDING' | 'COMPLETE' | 'FAILED' | 'EXPIRED';
      /** @example http://portal.telnyx.com/downloads/report_name_8hvb45Gu.csv */
      report_url?: string;
      filters?: components['schemas']['Filter'][];
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      created_at?: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      updated_at?: string;
      /** @example My profile */
      profiles?: string;
      /** @example mdr_report */
      record_type?: string;
    };
    MdrDetailResponse: {
      /**
       * Format: date-time
       * @description Message sent time
       * @example 2020-07-01T00:00:00-06:00
       */
      created_at?: string;
      /**
       * @description Configured profile name. New profiles can be created and configured on Telnyx portal
       * @example configured-profile-name
       */
      profile_name?: string;
      /**
       * @description Direction of message - inbound or outbound.
       * @example outbound
       */
      direction?: string;
      /**
       * @description Number of parts this message has. Max number of character is 160. If message contains more characters then that it will be broken down in multiple parts
       * @example 2
       */
      parts?: number;
      /**
       * @description Message status
       * @example DELIVERED
       * @enum {string}
       */
      status?:
        | 'GW_TIMEOUT'
        | 'DELIVERED'
        | 'DLR_UNCONFIRMED'
        | 'DLR_TIMEOUT'
        | 'RECEIVED'
        | 'GW_REJECT'
        | 'FAILED';
      /**
       * @description The destination number for a call, or the callee
       * @example +1555123456
       */
      cld?: string;
      /**
       * @description The number associated with the person initiating the call, or the caller
       * @example +1555123456
       */
      cli?: string;
      /**
       * @description Rate applied to the message
       * @example 0.05
       */
      rate?: string;
      /**
       * @description Final cost. Cost is calculated as rate * parts
       * @example 0.1
       */
      cost?: string;
      /**
       * @description Currency of the rate and cost
       * @example USD
       * @enum {string}
       */
      currency?: 'AUD' | 'CAD' | 'EUR' | 'GBP' | 'USD';
      /**
       * @description Id of message detail record
       * @example 99b637f3-07fd-45ac-b9ca-b87208c24650
       */
      id?: string;
      /**
       * @description Type of message
       * @example SMS
       * @enum {string}
       */
      message_type?: 'SMS' | 'MMS';
      /** @example mdr_report */
      record_type?: string;
    };
    MdrGetDetailReportByIdResponse: {
      data?: components['schemas']['MdrDetailReportResponse'];
    };
    MdrGetDetailReportResponse: {
      data?: components['schemas']['MdrDetailReportResponse'][];
      meta?: components['schemas']['PaginationMeta'];
    };
    MdrGetDetailResponse: {
      data?: components['schemas']['MdrDetailResponse'][];
      meta?: components['schemas']['PaginationMeta'];
    };
    MdrGetSyncUsageReportResponse: {
      data?: components['schemas']['MdrUsageReportResponse'];
    };
    MdrGetUsageReportsByIdResponse: {
      data?: components['schemas']['MdrUsageReportResponse'];
    };
    MdrGetUsageReportsResponse: {
      data?: components['schemas']['MdrUsageReportResponse'][];
      meta?: components['schemas']['PaginationMeta'];
    };
    MdrPostDetailReportRequest: {
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      start_date: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      end_date: string;
      directions?: ('INBOUND' | 'OUTBOUND')[];
      record_types?: ('INCOMPLETE' | 'COMPLETED' | 'ERRORS')[];
      connections?: number[];
      report_name?: string;
      /** @example true */
      include_message_body?: boolean;
      filters?: components['schemas']['Filter'][];
      /** @example My profile */
      profiles?: string;
    };
    MdrPostDetailReportResponse: {
      data?: components['schemas']['MdrDetailReportResponse'];
    };
    MdrPostUsageReportRequest: {
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      start_date: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      end_date: string;
      /** @enum {string} */
      aggregation_type: 'NO_AGGREGATION' | 'PROFILE' | 'TAGS';
      /** @example My profile */
      profiles?: string;
    };
    MdrPostUsageReportsResponse: {
      data?: components['schemas']['MdrUsageReportResponse'];
    };
    MdrUsageRecord: {
      /** @example 0 */
      cost?: string;
      /** @example outbound */
      direction?: string;
      /** @example outbound */
      product?: string;
      /** @example all */
      connection?: string;
      /** @example 0 */
      received?: string;
      /** @example 0 */
      delivered?: string;
      /** @example USD */
      currency?: string;
      /** @example 0 */
      parts?: string;
      /** @example 0 */
      sent?: string;
      /** @example All */
      profile_id?: string;
      /** @example All */
      tags?: string;
      /** @example SMS */
      message_type?: string;
      /** @example TF */
      tn_type?: string;
      /** @example 0 */
      carrier_passthrough_fee?: string;
    };
    MdrUsageReportResponse: {
      /**
       * Format: uuid
       * @description Identifies the resource
       */
      id?: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      start_date?: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      end_date?: string;
      connections?: number[];
      /** @enum {string} */
      aggregation_type?: 'NO_AGGREGATION' | 'PROFILE' | 'TAGS';
      /** @enum {string} */
      status?: 'PENDING' | 'COMPLETE' | 'FAILED' | 'EXPIRED';
      /** @example http://portal.telnyx.com/downloads/report_name_8hvb45Gu.csv */
      report_url?: string;
      result?: components['schemas']['MdrUsageRecord'][];
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      created_at?: string;
      /**
       * Format: date-time
       * @example 2020-07-01T00:00:00-06:00
       */
      updated_at?: string;
      /** @example My profile */
      profiles?: string;
      /** @example mdr_usage_report */
      record_type?: string;
    };
    /**
     * @description The media features settings for a phone number.
     * @example {
     *       "rtp_auto_adjust_enabled": true,
     *       "accept_any_rtp_packets_enabled": true,
     *       "t38_fax_gateway_enabled": true
     *     }
     */
    MediaFeatures: {
      /**
       * @description When RTP Auto-Adjust is enabled, the destination RTP address port will be automatically changed to match the source of the incoming RTP packets.
       * @default true
       */
      rtp_auto_adjust_enabled: boolean;
      /**
       * @description When enabled, Telnyx will accept RTP packets from any customer-side IP address and port, not just those to which Telnyx is sending RTP.
       * @default false
       */
      accept_any_rtp_packets_enabled: boolean;
      /**
       * @description Controls whether Telnyx will accept a T.38 re-INVITE for this phone number. Note that Telnyx will not send a T.38 re-INVITE; this option only controls whether one will be accepted.
       * @default false
       */
      t38_fax_gateway_enabled: boolean;
    };
    /**
     * @description The media_name used for the fax's media. Must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. media_name and media_url/contents can't be submitted together.
     * @example my_media_uploaded_to_media_storage_api
     */
    MediaName: string;
    /**
     * Media Resource
     * @example {
     *       "media_name": "f5586561-8ff0-4291-a0ac-84fe544797bd",
     *       "expires_at": "2020-01-23T18:10:02.574Z",
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z",
     *       "content_type": "application/xml"
     *     }
     */
    MediaResource: {
      /** @description Uniquely identifies a media resource. */
      media_name?: string;
      /**
       * @description ISO 8601 formatted date of when the media resource will expire and be deleted.
       * @example 2020-01-23T18:10:02.574Z
       */
      expires_at?: string;
      /**
       * @description ISO 8601 formatted date of when the media resource was created
       * @example 2019-01-23T18:10:02.574Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date of when the media resource was last updated
       * @example 2019-01-23T18:10:02.574Z
       */
      updated_at?: string;
      /**
       * @description Content type of the file
       * @example application/xml
       */
      content_type?: string;
    };
    MediaStorageDetailRecord: {
      /**
       * @description Unique identifier for the Media Storage Event
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      id?: string;
      /**
       * Format: date-time
       * @description Event creation time
       * @example 2020-07-01T00:00:00Z
       */
      created_at?: string;
      /**
       * @description Asset id
       * @example a46f4764-4ce4-4391-804c-02f00bc4ff9b
       */
      asset_id?: string;
      /**
       * @description User id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      user_id?: string;
      /**
       * @description Organization owner id
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      org_id?: string;
      /**
       * @description Type of action performed against the Media Storage API
       * @example upload
       */
      action_type?: string;
      /**
       * @description Link channel type
       * @example message
       */
      link_channel_type?: string;
      /**
       * @description Link channel id
       * @example 2065f482-64b9-4680-a3a9-c6d3142efdf7
       */
      link_channel_id?: string;
      /**
       * @description Request status
       * @example failed
       */
      status?: string;
      /**
       * @description Webhook id
       * @example b46f4764-4ce4-4391-804c-02f00bc4ff9b
       */
      webhook_id?: string;
      /**
       * @description Currency amount per billing unit used to calculate the Telnyx billing cost
       * @example 0.0001
       */
      rate?: string;
      /**
       * @description Billing unit used to calculate the Telnyx billing cost
       * @example events
       */
      rate_measured_in?: string;
      /**
       * @description Currency amount for Telnyx billing cost
       * @example 0.004
       */
      cost?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'MediaStorageDetailRecord';
    };
    /**
     * @description The URL (or list of URLs) to the PDF used for the fax's media. media_url and media_name/contents can't be submitted together.
     * @example https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf
     */
    MediaUrl: string;
    MessageDetailRecord: {
      /**
       * @description Unique identifier of the message
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      uuid?: string;
      /**
       * @description Identifier of the Telnyx account who owns the message
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      user_id?: string;
      /**
       * Format: date-time
       * @description Message completion time
       * @example 2020-07-01T00:00:00Z
       */
      completed_at?: string;
      /**
       * Format: date-time
       * @description Message creation time
       * @example 2020-07-01T00:00:00Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description Message updated time
       * @example 2020-07-01T00:00:00Z
       */
      updated_at?: string;
      /**
       * Format: date-time
       * @description Time when the message was sent
       * @example 2020-07-01T00:00:00Z
       */
      sent_at?: string;
      /**
       * @description Country-specific carrier used to send or receive the message
       * @example T-Mobile USA
       */
      carrier?: string;
      /**
       * @description Fee charged by certain carriers in order to deliver certain message types. Telnyx passes this fee on to the customer according to our pricing table
       * @example 0.003
       */
      carrier_fee?: string;
      /**
       * @description The recipient of the message (to parameter in the Messaging API)
       * @example +1555123456
       */
      cld?: string;
      /**
       * @description The sender of the message (from parameter in the Messaging API). For Alphanumeric ID messages, this is the sender ID value
       * @example +1555123456
       */
      cli?: string;
      /**
       * @description Two-letter representation of the country of the cld property using the ISO 3166-1 alpha-2 format
       * @example US
       */
      country_code?: string;
      /**
       * @description Final webhook delivery status
       * @example success: webhook succeeded
       */
      delivery_status?: string;
      /**
       * @description Failover customer-provided URL which Telnyx posts delivery status webhooks to
       * @example https://api.example.com/sms/telnyx/inbound
       */
      delivery_status_failover_url?: string;
      /**
       * @description Primary customer-provided URL which Telnyx posts delivery status webhooks to
       * @example https://api.example.com/sms/telnyx/inbound
       */
      delivery_status_webhook_url?: string;
      /**
       * @description Logical direction of the message from the Telnyx customer's perspective. It's inbound when the Telnyx customer receives the message, or outbound otherwise
       * @example outbound
       * @enum {string}
       */
      direction?: 'inbound' | 'outbound';
      /**
       * @description Indicates whether this is a Free-To-End-User (FTEU) short code message
       * @example false
       */
      fteu?: boolean;
      /**
       * @description Mobile country code. Only available for certain products, such as Global Outbound-Only from Alphanumeric Sender ID
       * @example 204
       */
      mcc?: string;
      /**
       * @description Mobile network code. Only available for certain products, such as Global Outbound-Only from Alphanumeric Sender ID
       * @example 01
       */
      mnc?: string;
      /**
       * @description Describes the Messaging service used to send the message. Available services are: Short Message Service (SMS), Multimedia Messaging Service (MMS), and Rich Communication Services (RCS)
       * @example SMS
       * @enum {string}
       */
      message_type?: 'SMS' | 'MMS' | 'RCS';
      /**
       * @description Indicates whether both sender and recipient numbers are Telnyx-managed
       * @example true
       */
      on_net?: boolean;
      /**
       * @description Unique identifier of the Messaging Profile used to send or receive the message
       * @example 30ef55db-c4a2-4c4a-9804-a68077973d07
       */
      profile_id?: string;
      /**
       * @description Name of the Messaging Profile used to send or receive the message
       * @example My Messaging Profile
       */
      profile_name?: string;
      /**
       * @description Two-letter representation of the country of the cli property using the ISO 3166-1 alpha-2 format
       * @example US
       */
      source_country_code?: string;
      /**
       * @description Final status of the message after the delivery attempt
       * @example delivered
       * @enum {string}
       */
      status?:
        | 'gw_timeout'
        | 'delivered'
        | 'dlr_unconfirmed'
        | 'dlr_timeout'
        | 'received'
        | 'gw_reject'
        | 'failed';
      /**
       * @description Comma-separated tags assigned to the Telnyx number associated with the message
       * @example tag1,tag2,tag3
       */
      tags?: string;
      /**
       * @description Currency amount per billing unit used to calculate the Telnyx billing cost
       * @example 0.003
       */
      rate?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * @description Amount, in the user currency, for the Telnyx billing cost
       * @example 0.003
       */
      cost?: string;
      /** @description Telnyx API error codes returned by the Telnyx gateway */
      errors?: string[];
      /**
       * @description Number of message parts. The message is broken down in multiple parts when its length surpasses the limit of 160 characters
       * @example 2
       */
      parts?: number;
      /**
       * @description Identifies the record schema (enum property replaced by openapi-typescript)
       * @enum {string}
       */
      record_type: 'MessageDetailRecord';
    };
    /**
     * @description The set of features available for a specific messaging use case (SMS or MMS). Features
     *     can vary depending on the characteristics the phone number, as well as its current
     *     product configuration.
     *
     * @example {
     *       "domestic_two_way": true,
     *       "international_inbound": false,
     *       "international_outbound": true
     *     }
     */
    MessagingFeatureSet: {
      /** @description Send messages to and receive messages from numbers in the same country. */
      domestic_two_way: boolean;
      /** @description Receive messages from numbers in other countries. */
      international_inbound: boolean;
      /** @description Send messages to numbers in other countries. */
      international_outbound: boolean;
    } | null;
    /** @example {
     *       "id": "86f58db9-0fe3-4adc-9d1f-46e66e6e9323",
     *       "record_type": "messaging_hosted_number_order",
     *       "messaging_profile_id": "dc8f39ac-953d-4520-b93b-786ae87db0da",
     *       "status": "pending",
     *       "phone_numbers": [
     *         {
     *           "record_type": "messaging_hosted_number",
     *           "id": "bf6307bd-884d-4c1f-b6ea-c62b8c495d3c",
     *           "phone_number": "+18665550001",
     *           "status": "pending"
     *         },
     *         {
     *           "record_type": "messaging_hosted_number",
     *           "id": "464bd54e-a328-4b11-a131-28e6793cb6f2",
     *           "phone_number": "+18665550002",
     *           "status": "pending"
     *         }
     *       ]
     *     } */
    MessagingHostedNumberOrder: {
      /**
       * @description Identifies the type of the resource.
       * @example messaging_hosted_number_order
       */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Resource unique identifier.
       */
      readonly id?: string;
      /** @description Automatically associate the number with this messaging profile ID when the order is complete. */
      messaging_profile_id?: string | null;
      /** @enum {string} */
      status?: 'failed' | 'pending' | 'successful';
      phone_numbers?: components['schemas']['HostedNumber'][];
    };
    /** @example {
     *       "record_type": "messaging_profile",
     *       "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "name": "Profile for Messages",
     *       "webhook_url": "https://www.example.com/hooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "enabled": true,
     *       "webhook_api_version": "2",
     *       "whitelisted_destinations": [
     *         "US"
     *       ],
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z",
     *       "number_pool_settings": {
     *         "toll_free_weight": 10,
     *         "long_code_weight": 2,
     *         "skip_unhealthy": false,
     *         "sticky_sender": true,
     *         "geomatch": false
     *       },
     *       "url_shortener_settings": {
     *         "domain": "example.ex",
     *         "prefix": "cmpny",
     *         "replace_blacklist_only": true,
     *         "send_webhooks": false
     *       },
     *       "v1_secret": "rP1VamejkU2v0qIUxntqLW2c"
     *     } */
    MessagingProfile: {
      /**
       * @description Identifies the type of the resource.
       * @enum {string}
       */
      readonly record_type?: 'messaging_profile';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      readonly id?: string;
      /** @description A user friendly name for the messaging profile. */
      name?: string;
      /** @description Specifies whether the messaging profile is enabled or not. */
      enabled?: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this messaging profile will be sent.
       */
      webhook_url?: string | null;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this messaging profile will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1, v2, or a legacy 2010-04-01 format.
       * @enum {string}
       */
      webhook_api_version?: '1' | '2' | '2010-04-01';
      /** @description Destinations to which the messaging profile is allowed to send. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed. */
      whitelisted_destinations?: string[];
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       */
      readonly updated_at?: string;
      /** @description Secret used to authenticate with v1 endpoints. */
      v1_secret?: string;
      number_pool_settings?: components['schemas']['NumberPoolSettings'];
      url_shortener_settings?: components['schemas']['UrlShortenerSettings'];
      /** @description The alphanumeric sender ID to use when sending to destinations that require an alphanumeric sender ID. */
      alpha_sender?: string | null;
    };
    MessagingProfileDetailedMetric: {
      /**
       * @description The timestamp of the aggregated data.
       * @example 2019-01-23T18:10:02.574Z
       */
      readonly timestamp?: string;
      metrics?: components['schemas']['MessagingProfileMessageTypeMetrics'][];
    };
    /** @example {
     *       "detailed": [
     *         {
     *           "metrics": [
     *             {
     *               "label": "longcode",
     *               "sent": 1000,
     *               "delivered": 990,
     *               "errors": 0.01,
     *               "received": 750
     *             }
     *           ],
     *           "timestamp": "2019-01-23T18:10:02.574Z"
     *         }
     *       ],
     *       "overview": {
     *         "record_type": "messaging_profile_metrics",
     *         "messaging_profile_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *         "phone_numbers": 250,
     *         "outbound": {
     *           "sent": 1000,
     *           "delivered": 990,
     *           "errors": 0.01
     *         },
     *         "inbound": {
     *           "received": 850
     *         }
     *       }
     *     } */
    MessagingProfileDetailedMetrics: {
      overview?: components['schemas']['MessagingProfileHighLevelMetrics'];
      detailed?: components['schemas']['MessagingProfileDetailedMetric'][];
    };
    /** @example {
     *       "record_type": "messaging_profile_metrics",
     *       "messaging_profile_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "phone_numbers": 250,
     *       "outbound": {
     *         "sent": 1000,
     *         "delivered": 990,
     *         "errors": 0.01
     *       },
     *       "inbound": {
     *         "received": 850
     *       }
     *     } */
    MessagingProfileHighLevelMetrics: {
      /**
       * @description Identifies the type of the resource.
       * @example messaging_profile_metrics
       * @enum {string}
       */
      readonly record_type?: 'messaging_profile_metrics';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      readonly messaging_profile_id?: string;
      /** @description The number of phone numbers associated with the messaging profile. */
      readonly phone_numbers?: number;
      outbound?: {
        /** @description The number of outbound messages sent. */
        readonly sent?: number;
        /** @description The number of outbound messages successfully delivered. */
        readonly delivered?: number;
        /** @description The ratio of messages sent that resulted in errors. */
        readonly error_ratio?: number;
      };
      inbound?: {
        /** @description The number of inbound messages received. */
        readonly received?: number;
      };
    };
    /** @example {
     *       "label": "longcode",
     *       "sent": 1000,
     *       "delivered": 990,
     *       "errors": 0.01,
     *       "received": 750
     *     } */
    MessagingProfileMessageTypeMetrics: {
      /** @description The metric type. */
      readonly label?: string;
      /** @description The number of outbound messages sent. */
      readonly sent?: number;
      /** @description The number of outbound messages successfully delivered. */
      readonly delivered?: number;
      /** @description The ratio of outbound messages sent that resulted in errors. */
      readonly outbound_error_ratio?: number;
      /** @description The number of inbound messages received. */
      readonly received?: number;
    };
    /** @example {
     *       "record_type": "messaging_url_domain",
     *       "id": "464bd54e-a328-4b11-a131-28e6793cb6f2",
     *       "url_domain": "http://example.com",
     *       "use_case": "test"
     *     } */
    MessagingUrlDomain: {
      record_type?: string;
      id?: string;
      url_domain?: string;
      use_case?: string;
    };
    Meta: {
      /** @example 3 */
      total_pages?: number;
      /** @example 55 */
      total_results?: number;
      /** @example 2 */
      page_number?: number;
      /** @example 25 */
      page_size?: number;
    };
    MetaResponse: {
      /**
       * @description This should likely be a URL to the relevant documentation
       * @example https://developers.telnyx.com/docs/overview/errors/10001
       */
      url?: string;
    };
    /** Metadata */
    Metadata: {
      /**
       * Format: double
       * @description Total number of pages based on pagination settings
       * @example 13
       */
      total_pages?: number;
      /**
       * Format: double
       * @description Total number of results
       * @example 13
       */
      total_results?: number;
      /**
       * Format: double
       * @description Current Page based on pagination settings (included when defaults are used.)
       * @example 3
       */
      page_number?: number;
      /**
       * Format: double
       * @description Number of results to return per page based on pagination settings (included when defaults are used.)
       * @example 1
       */
      page_size?: number;
    };
    MigrationParams: {
      /** @description Unique identifier for the data migration. */
      readonly id?: string;
      /** @description ID of the Migration Source from which to migrate data. */
      source_id: string;
      /** @description Bucket name to migrate the data into. Will default to the same name as the `source_bucket_name`. */
      target_bucket_name: string;
      /** @description Telnyx Cloud Storage region to migrate the data to. */
      target_region: string;
      /** @description If true, will continue to poll the source bucket to ensure new data is continually migrated over. */
      refresh?: boolean;
      /**
       * Format: date-time
       * @description Time when data migration was last copied from the source.
       * @example 2020-01-01T00:00:00Z
       */
      readonly last_copy?: string;
      /**
       * @description Status of the migration.
       * @enum {string}
       */
      readonly status?:
        | 'pending'
        | 'checking'
        | 'migrating'
        | 'complete'
        | 'error'
        | 'stopped';
      /** @description Total amount of data found in source bucket to migrate. */
      readonly bytes_to_migrate?: number;
      /** @description Total amount of data that has been succesfully migrated. */
      readonly bytes_migrated?: number;
      /** @description Current speed of the migration. */
      readonly speed?: number;
      /**
       * Format: date-time
       * @description Estimated time the migration will complete.
       * @example 2020-01-01T00:00:00Z
       */
      readonly eta?: string;
      /**
       * Format: date-time
       * @description Time when data migration was created
       * @example 2020-01-01T00:00:00Z
       */
      readonly created_at?: string;
    };
    MigrationSourceCoverageParams: {
      /**
       * @description Cloud provider from which to migrate data.
       * @enum {string}
       */
      provider?: 'aws';
      /** @description Provider region from which to migrate data. */
      source_region?: string;
    };
    MigrationSourceParams: {
      /** @description Unique identifier for the data migration source. */
      readonly id?: string;
      /**
       * @description Cloud provider from which to migrate data.
       * @enum {string}
       */
      provider: 'aws';
      provider_auth: {
        /** @description AWS Access Key. */
        access_key?: string;
        /** @description AWS Secret Access Key. */
        secret_access_key?: string;
      };
      /** @description Bucket name to migrate the data from. */
      bucket_name: string;
    };
    /** Mno */
    Mno: {
      /**
       * Networkid
       * @description Unique network identifier assigned to MNO.
       */
      networkId: number;
      /**
       * Displayname
       * @description Display name of the mobile network operator.
       */
      displayName: string;
      /**
       * Osrbitmaskindex
       * @description NetNumber OSR 'campaign_id' property's 'status' attribute holds individual MNO campaign operation status. The 'status' attribute leverages bitmasking technique to store multiple MNOs' operating status. The campaign operation status is reduced to '1' or '0' value where '1' indicate an 'ACTIVE' status and '0' represents every other non-active statuses, including REVIEW, REJECT and SUSPEND. The 'osrBitmaskIndex' holds the bitmask index of the MNO. For example, T-Mobile's bitmask index is 2, which implies T-Mobile's campaign operation status is stored in bit #2, or 3rd bit when counting from right.
       */
      osrBitmaskIndex: number;
    };
    /** MnoMetadata */
    MnoMetadata: {
      10999?: components['schemas']['MnoMetadataItem'];
    };
    /** MnoMetadataItem */
    MnoMetadataItem: {
      qualify: boolean;
      mno: string;
      noEmbeddedLink: boolean;
      reqSubscriberHelp: boolean;
      reqSubscriberOptout: boolean;
      mnoReview: boolean;
      noEmbeddedPhone: boolean;
      mnoSupport: boolean;
      reqSubscriberOptin: boolean;
      /** @example 1 */
      minMsgSamples: number;
    };
    /** MobileNetworkOperator */
    MobileNetworkOperator: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example mobile_network_operator
       */
      readonly record_type?: string;
      /**
       * @description The network operator name.
       * @example AT&T Mobility (USACG)
       */
      name?: string;
      /**
       * @description TADIG stands for Transferred Account Data Interchange Group. The TADIG code is a unique identifier for network operators in GSM mobile networks.
       * @example USACG
       */
      tadig?: string;
      /**
       * @description The mobile operator two-character (ISO 3166-1 alpha-2) origin country code.
       * @example US
       */
      country_code?: string;
      /**
       * @description MCC stands for Mobile Country Code. It's a three decimal digit that identifies a country.<br/><br/>
       *     This code is commonly seen joined with a Mobile Network Code (MNC) in a tuple that allows identifying a carrier known as PLMN (Public Land Mobile Network) code.
       * @example 310
       */
      mcc?: string;
      /**
       * @description MNC stands for Mobile Network Code. It's a two to three decimal digits that identify a network.<br/><br/>
       *      This code is commonly seen joined with a Mobile Country Code (MCC) in a tuple that allows identifying a carrier known as PLMN (Public Land Mobile Network) code.
       * @example 410
       */
      mnc?: string;
      /**
       * @description Indicate whether the mobile network operator can be set as preferred in the Network Preferences API.
       * @example true
       */
      readonly network_preferences_enabled?: boolean;
    };
    MobileNetworkOperatorPreferencesRequest: {
      /**
       * Format: uuid
       * @description The mobile network operator resource identification UUID.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      mobile_network_operator_id?: string;
      /**
       * @description It determines what is the priority of a specific network operator that should be assumed by a SIM card when connecting to a network. The highest priority is 0, the second highest is 1 and so on.
       * @example 0
       */
      priority?: number;
    };
    MobileNetworkOperatorPreferencesResponse: {
      /**
       * Format: uuid
       * @description The mobile network operator resource identification UUID.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      mobile_network_operator_id?: string;
      /**
       * @description The mobile network operator resource name.
       * @example AT&T Mobility (USACG)
       */
      mobile_network_operator_name?: string;
      /**
       * @description It determines what is the priority of a specific network operator that should be assumed by a SIM card when connecting to a network. The highest priority is 0, the second highest is 1 and so on.
       * @example 0
       */
      priority?: number;
    };
    /** @description A list of mobile network operators and the priority that should be applied when the SIM is connecting to the network. */
    MobileNetworkOperatorsPreferencesRequest: components['schemas']['MobileNetworkOperatorPreferencesRequest'][];
    /** @description A list of mobile network operators and the priority that should be applied when the SIM is connecting to the network. */
    MobileNetworkOperatorsPreferencesResponse: components['schemas']['MobileNetworkOperatorPreferencesResponse'][];
    /** ModelMetadata */
    ModelMetadata: {
      /** Id */
      id: string;
      /**
       * Object
       * @default model
       */
      object: string;
      /** Created */
      created: number;
      /** Owned By */
      owned_by: string;
    };
    /**
     * ModelNamespace
     * @description Provide a namespace to our supported models.
     * @enum {string}
     */
    ModelNamespace:
      | 'meta-llama/Llama-2-13b-chat-hf'
      | 'mistralai/Mistral-7B-Instruct-v0.1'
      | 'Trelis/Llama-2-7b-chat-hf-function-calling-v2'
      | 'openai/gpt-3.5-turbo'
      | 'openai/gpt-3.5-turbo-16k'
      | 'openai/gpt-4'
      | 'openai/gpt-4-32k';
    /** ModelsResponse */
    ModelsResponse: {
      /**
       * Object
       * @default list
       */
      object: string;
      /** Data */
      data: components['schemas']['ModelMetadata'][];
    };
    /**
     * @description The flag to enable monochrome, true black and white fax results.
     * @default false
     */
    Monochrome: boolean;
    Network: components['schemas']['Record'] & {
      /**
       * @description Identifies the type of the resource.
       * @example network
       */
      readonly record_type?: string;
      /**
       * @description A user specified name for the network.
       * @example test network
       */
      name?: string;
    };
    /** NetworkCoverage */
    NetworkCoverage: {
      /**
       * @description Identifies the type of the resource.
       * @example network_coverage
       */
      readonly record_type?: string;
      location?: components['schemas']['Location'];
      /** @description List of interface types supported in this region. */
      available_services?: components['schemas']['AvailableService'][];
    };
    NetworkCreate: components['schemas']['Network'] & Record<string, never>;
    NetworkInterface: components['schemas']['Record'] &
      components['schemas']['Interface'] &
      components['schemas']['RegionOut'] & {
        /**
         * @description Identifies the type of the resource.
         * @example network_interface
         */
        readonly record_type?: string;
        /**
         * @description Identifies the type of the interface.
         * @example wireguard_interface
         */
        readonly type?: string;
      };
    /** @example {
     *       "name": "string"
     *     } */
    NewBillingGroup: {
      /** @description A name for the billing group */
      name?: string;
    };
    /** @example {
     *       "year": 2019,
     *       "month": 10
     *     } */
    NewLedgerBillingGroupReport: {
      /**
       * @description Year of the ledger billing group report
       * @example 2019
       */
      year?: number;
      /**
       * @description Month of the ledger billing group report
       * @example 10
       */
      month?: number;
    };
    /**
     * New participant resource
     * @example {
     *       "account_sid": "4e71926f-8f13-450e-b91c-23c2ef786aa6",
     *       "call_sid": "v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ",
     *       "coaching": false,
     *       "coaching_call_sid": null,
     *       "conference_sid": "cd5a70f4-759b-4d5e-9c06-88c00f16f3c1",
     *       "end_conference_on_exit": false,
     *       "hold": false,
     *       "muted": false,
     *       "status": "completed",
     *       "uri": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Participants/v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ.json"
     *     }
     */
    NewParticipantResource: {
      /**
       * @description The id of the account the resource belongs to.
       * @example 61bf923e-5e4d-4595-a110-56190ea18a1b
       */
      account_sid?: string;
      /**
       * @description The identifier of this participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      call_sid?: string;
      /**
       * @description Whether the participant is coaching another call.
       * @example false
       */
      coaching?: boolean;
      /**
       * @description The identifier of the coached participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      coaching_call_sid?: string;
      /**
       * @description Whether the conference ends when the participant leaves.
       * @example false
       */
      end_conference_on_exit?: boolean;
      /**
       * @description Whether the participant is on hold.
       * @example false
       */
      hold?: boolean;
      /**
       * @description Whether the participant is muted.
       * @example false
       */
      muted?: boolean;
      /**
       * @description The status of the participant's call in the conference.
       * @example in-progress
       * @enum {string}
       */
      status?: 'connecting' | 'connected' | 'completed';
      /**
       * @description The relative URI for this participant.
       * @example /v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Participants/v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ.json
       */
      uri?: string;
    };
    /**
     * Noise Suppression Direction
     * @description The direction of the audio stream to be noise suppressed.
     * @default inbound
     * @example outbound
     * @enum {string}
     */
    NoiseSuppressionDirection: 'inbound' | 'outbound' | 'both';
    /**
     * Noise Suppression Start Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "direction": "both"
     *     }
     */
    NoiseSuppressionStart: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      direction?: components['schemas']['NoiseSuppressionDirection'];
    };
    /**
     * Noise Suppression Stop Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    NoiseSuppressionStop: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** NotFoundError */
    NotFoundError: {
      /** Telnyx error code */
      code?: string;
      /** Error details */
      detail: string;
      /** Error title */
      title?: string;
    };
    /** @description A Notification Channel */
    NotificationChannel: {
      /**
       * @description A UUID.
       * @example 12455643-3cf1-4683-ad23-1cd32f7d5e0a
       */
      readonly id?: string;
      /**
       * @description A UUID reference to the associated Notification Profile.
       * @example 12455643-3cf1-4683-ad23-1cd32f7d5e0a
       */
      notification_profile_id?: string;
      /**
       * @description A Channel Type ID
       * @enum {string}
       */
      channel_type_id?: 'sms' | 'voice' | 'email' | 'webhook';
      /**
       * @description The destination associated with the channel type.
       * @example +13125550000
       */
      channel_destination?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2019-10-15T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2019-10-15T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    /** @description An object representing the available notifications. */
    NotificationEvent: {
      /**
       * @description A UUID.
       * @example d5c395cd-9864-4609-b5e2-3f9fd4ce201a
       */
      readonly id?: string;
      /**
       * @description A human readable name.
       * @example Emergency Number Dialed
       */
      name?: string;
      /** @example Calls */
      notification_category?: string;
      /** @example true */
      enabled?: boolean;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2019-10-15T10:07:15.527Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2019-10-15T10:07:15.527Z
       */
      updated_at?: string;
    };
    NotificationEventCondition: {
      /**
       * @description A UUID.
       * @example 70c7c5cb-dce2-4124-accb-870d39dbe852
       */
      readonly id?: string;
      /** @example from phone number */
      name?: string;
      /** @example When emergency number dialed from phone number X */
      description?: string;
      /** @example d5c395cd-9864-4609-b5e2-3f9fd4ce201a */
      notification_event_id?: string;
      /**
       * @example phone_number
       * @enum {string}
       */
      associated_record_type?: 'account' | 'phone_number';
      parameters?: {
        /** @example phone_number */
        name?: string;
        /** @example false */
        optional?: boolean;
        /** @example string */
        data_type?: string;
      }[];
      /** @example true */
      enabled?: boolean;
      /**
       * @description Dictates whether a notification channel id needs to be provided when creating a notficiation setting.
       * @example false
       */
      allow_multiple_channels?: boolean;
      /**
       * @description Dictates whether a notification setting will take effect immediately.
       * @example true
       */
      asynchronous?: boolean;
      /**
       * @description Dictates the supported notification channel types that can be emitted.
       * @example [
       *       "webhook",
       *       "sms",
       *       "email",
       *       "voice"
       *     ]
       */
      supported_channels?: string[];
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2019-10-15T10:07:15.527Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2019-10-15T10:07:15.527Z
       */
      updated_at?: string;
    };
    /** @description A Collection of Notification Channels */
    NotificationProfile: {
      /**
       * @description A UUID.
       * @example 12455643-3cf1-4683-ad23-1cd32f7d5e0a
       */
      readonly id?: string;
      /** @description A human readable name. */
      name?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2019-10-15T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2019-10-15T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    NotificationSetting: {
      /**
       * @description A UUID.
       * @example 8eb5b5f9-5893-423c-9f15-b487713d44d4
       */
      readonly id?: string;
      /**
       * @description A UUID reference to the associated Notification Event Condition.
       * @example 70c7c5cb-dce2-4124-accb-870d39dbe852
       */
      notification_event_condition_id?: string;
      /**
       * @description A UUID reference to the associated Notification Profile.
       * @example 12455643-3cf1-4683-ad23-1cd32f7d5e0a
       */
      notification_profile_id?: string;
      /** @example phone_number */
      readonly associated_record_type?: string;
      /** @example +13125550000 */
      readonly associated_record_type_value?: string;
      /**
       * @description Most preferences apply immediately; however, other may needs to propagate.
       * @example enable-received
       * @enum {string}
       */
      readonly status?:
        | 'enabled'
        | 'enable-received'
        | 'enable-pending'
        | 'enable-submtited'
        | 'delete-received'
        | 'delete-pending'
        | 'delete-submitted'
        | 'deleted';
      /**
       * @description A UUID reference to the associated Notification Channel.
       * @example 12455643-3cf1-4683-ad23-1cd32f7d5e0a
       */
      notification_channel_id?: string;
      parameters?: {
        /** @example phone_number */
        name?: string;
        /** @example +13125550000 */
        value?: string;
      }[];
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2019-10-15T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2019-10-15T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    /** @example {
     *       "id": "12ade33a-21c0-473b-b055-b3c836e1c292",
     *       "starting_number": "+19705555000",
     *       "range": 10,
     *       "record_type": "number_block_order",
     *       "connection_id": "346789098765567",
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600",
     *       "phone_numbers_count": 10,
     *       "status": "pending",
     *       "customer_reference": "MY REF 001",
     *       "created_at": "2018-01-01T00:00:00.000000Z",
     *       "updated_at": "2018-01-01T00:00:00.000000Z",
     *       "requirements_met": true
     *     } */
    NumberBlockOrder: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example number_block_order */
      readonly record_type?: string;
      /**
       * Format: e164_phone_number
       * @description Starting phone number block
       * @example +19705555000
       */
      starting_number?: string;
      /**
       * @description The phone number range included in the block.
       * @example 10
       */
      range?: number;
      /**
       * @description The count of phone numbers in the number order.
       * @example 1
       */
      readonly phone_numbers_count?: number;
      /**
       * @description Identifies the connection associated to all numbers in the phone number block.
       * @example 346789098765567
       */
      connection_id?: string;
      /**
       * @description Identifies the messaging profile associated to all numbers in the phone number block.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      messaging_profile_id?: string;
      /**
       * @description The status of the order.
       * @example success
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number order was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
      /**
       * @description True if all requirements are met for every phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
    };
    /**
     * @description High level health metrics about the number and it's messaging sending patterns.
     *
     * @example {
     *       "message_count": 10,
     *       "inbound_outbound_ratio": 1,
     *       "success_ratio": 2,
     *       "spam_ratio": 10
     *     }
     */
    NumberHealthMetrics: {
      /** @description The number of messages analyzed for the health metrics. */
      message_count: number;
      /**
       * Format: float
       * @description The ratio of messages received to the number of messages sent.
       */
      inbound_outbound_ratio: number;
      /**
       * Format: float
       * @description The ratio of messages sucessfully delivered to the number of messages attempted.
       */
      success_ratio: number;
      /**
       * Format: float
       * @description The ratio of messages blocked for spam to the number of messages attempted.
       */
      spam_ratio: number;
    };
    /** NumberLookup */
    NumberLookupRecord: {
      /**
       * @description Identifies the type of record
       * @example number_lookup
       */
      record_type?: string;
      /**
       * @description Region code that matches the specific country calling code
       * @example US
       */
      country_code?: string;
      /**
       * @description Hyphen-separated national number, preceded by the national destination code (NDC), with a 0 prefix, if an NDC is found
       * @example (0312) 945-7420
       */
      national_format?: string;
      /**
       * @description E164-formatted phone number
       * @example +13129457420
       */
      phone_number?: string;
      /**
       * @description Unused
       * @example null
       */
      fraud?: string;
      carrier?: components['schemas']['Carrier'];
      caller_name?: components['schemas']['CallerName'];
      portability?: components['schemas']['Portability'];
    };
    /** Number Order With Phone Numbers */
    NumberOrder: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example number_order */
      readonly record_type?: string;
      /**
       * @description The count of phone numbers in the number order.
       * @example 1
       */
      readonly phone_numbers_count?: number;
      /**
       * @description Identifies the connection associated with this phone number.
       * @example 346789098765567
       */
      connection_id?: string;
      /**
       * @description Identifies the messaging profile associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      messaging_profile_id?: string;
      /**
       * @description Identifies the messaging profile associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      billing_group_id?: string;
      phone_numbers?: components['schemas']['PhoneNumbersJobPhoneNumber'][];
      sub_number_orders_ids?: string[];
      /**
       * @description The status of the order.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number order was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
      /**
       * @description True if all requirements are met for every phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
    };
    /** Number Order Event */
    NumberOrderBlockEvent: {
      data?: components['schemas']['NumberBlockOrder'];
    };
    /** @example {
     *       "id": "387d1e31-a218-4375-8151-103f2d5e2d2c",
     *       "record_type": "number_order_document",
     *       "file_id": "1e3c5822-0362-4702-8e46-5a129f0d3976",
     *       "requirements_id": "36aaf27d-986b-493c-bd1b-de16af2e4292",
     *       "customer_reference": "MY REF 001",
     *       "requirement_type": "address_proof",
     *       "created_at": "2018-01-01T00:00:00.000000Z"
     *     } */
    NumberOrderDocument: {
      /**
       * Format: uuid
       * @example 387d1e31-a218-4375-8151-103f2d5e2d2c
       */
      readonly id?: string;
      /** @example number_order_document */
      readonly record_type?: string;
      /**
       * @description The id of the file to associate as a number order document.
       * @example 1e3c5822-0362-4702-8e46-5a129f0d3976
       */
      file_id?: string;
      /**
       * @description Unique id for a requirement.
       * @example 36aaf27d-986b-493c-bd1b-de16af2e4292
       */
      requirements_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @enum {string} */
      readonly requirement_type?:
        | 'address_proof'
        | 'identification'
        | 'reg_form';
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order document was uploaded.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
    };
    NumberOrderPhoneNumber: {
      /**
       * Format: uuid
       * @example dc8e4d67-33a0-4cbb-af74-7b58f05bd494
       */
      readonly id?: string;
      /** @example number_order_phone_number */
      readonly record_type?: string;
      /**
       * Format: e164_phone_number
       * @example +19705555098
       */
      phone_number?: string;
      /**
       * Format: uuid
       * @example dc8e4d67-33a0-4cbb-af74-7b58f05bd495
       */
      order_request_id?: string;
      /**
       * Format: uuid
       * @example dc8e4d67-33a0-4cbb-af74-7b58f05bd496
       */
      sub_number_order_id?: string;
      /** @example US */
      country_code?: string;
      /**
       * @example local
       * @enum {string}
       */
      phone_number_type?:
        | 'local'
        | 'toll_free'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'landline';
      regulatory_requirements?: components['schemas']['SubNumberOrderRegulatoryRequirementWithValue'][];
      /**
       * @description True if all requirements are met for a phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
      /**
       * @description The status of the phone number in the order.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * Format: uuid
       * @example null
       */
      readonly bundle_id?: string;
      /** @example San Francisco */
      locality?: string;
      /**
       * Format: datetime
       * @example 024-05-31T11:14:00+00:00
       */
      deadline?: string;
      /**
       * @description Status of requirements (if applicable)
       * @enum {string}
       */
      readonly requirements_status?:
        | 'pending'
        | 'approved'
        | 'cancelled'
        | 'deleted'
        | 'requirement-info-exception'
        | 'requirement-info-pending'
        | 'requirement-info-under-review';
      /** @example false */
      is_block_number?: boolean;
    };
    /** NumberOrder */
    NumberOrderWithPhoneNumbers: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example number_order */
      readonly record_type?: string;
      /**
       * @description The count of phone numbers in the number order.
       * @example 1
       */
      readonly phone_numbers_count?: number;
      /**
       * @description Identifies the connection associated with this phone number.
       * @example 346789098765567
       */
      connection_id?: string;
      /**
       * @description Identifies the messaging profile associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      messaging_profile_id?: string;
      /**
       * @description Identifies the messaging profile associated with the phone number.
       * @example abc85f64-5717-4562-b3fc-2c9600
       */
      billing_group_id?: string;
      phone_numbers?: components['schemas']['PhoneNumber'][];
      sub_number_orders_ids?: string[];
      /**
       * @description The status of the order.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number order was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
      /**
       * @description True if all requirements are met for every phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
    };
    /** Number Order Event Data */
    NumberOrdered: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      id?: string;
      /**
       * @description The type of event being delivered.
       * @example number_order.complete
       */
      event_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      occurred_at?: string;
      payload?: components['schemas']['NumberOrder'];
    };
    /** Number Order Event */
    NumberOrderedEvent: {
      data?: components['schemas']['NumberOrdered'];
    };
    /**
     * @description Number Pool allows you to send messages from a pool of numbers of different types, assigning
     *     weights to each type. The pool consists of all the long code and toll free numbers
     *     assigned to the messaging profile.
     *
     *     To disable this feature, set the object field to `null`.
     *
     * @example {
     *       "toll_free_weight": 10,
     *       "long_code_weight": 1,
     *       "skip_unhealthy": true,
     *       "sticky_sender": false,
     *       "geomatch": false
     *     }
     */
    NumberPoolSettings: {
      /**
       * @description Defines the probability weight for a Toll Free number to be selected when sending a message.
       *     The higher the weight the higher the probability. The sum of the weights for all number types
       *     does not necessarily need to add to 100. Weight must be a non-negative number, and when equal
       *     to zero it will remove the number type from the pool.
       *
       * @example 10
       */
      toll_free_weight: number;
      /**
       * @description Defines the probability weight for a Long Code number to be selected when sending a message.
       *     The higher the weight the higher the probability. The sum of the weights for all number types
       *     does not necessarily need to add to 100.  Weight must be a non-negative number, and when equal
       *     to zero it will remove the number type from the pool.
       *
       * @example 1
       */
      long_code_weight: number;
      /**
       * @description If set to true all unhealthy numbers will be automatically excluded from the pool.
       *     Health metrics per number are calculated on a regular basis, taking into account the deliverability
       *     rate and the amount of messages marked as spam by upstream carriers.
       *     Numbers with a deliverability rate below 25% or spam ratio over 75% will be considered unhealthy.
       *
       * @example true
       */
      skip_unhealthy: boolean;
      /**
       * @description If set to true, Number Pool will try to choose the same sending number for all messages to a particular
       *     recipient. If the sending number becomes unhealthy and `skip_unhealthy` is set to true, a new
       *     number will be chosen.
       *
       * @default false
       */
      sticky_sender: boolean;
      /**
       * @description If set to true, Number Pool will try to choose a sending number with the same area code as the destination
       *     number. If there are no such numbers available, a nunber with a different area code will be chosen. Currently
       *     only NANP numbers are supported.
       *
       * @default false
       */
      geomatch: boolean;
    } | null;
    /** @example {
     *       "id": "12ade33a-21c0-473b-b055-b3c836e1c292",
     *       "record_type": "number_reservation",
     *       "phone_numbers": [
     *         {
     *           "id": "12ade33a-21c0-473b-b055-b3c836e1c292",
     *           "record_type": "reserved_phone_number",
     *           "phone_number": "+19705555098",
     *           "status": "pending",
     *           "created_at": "2018-01-01T00:00:00.000000Z",
     *           "updated_at": "2018-01-01T00:00:00.000000Z",
     *           "expired_at": "2018-01-01T00:00:00.000000Z",
     *           "errors": ""
     *         }
     *       ],
     *       "status": "pending",
     *       "customer_reference": "MY REF 001",
     *       "created_at": "2018-01-01T00:00:00.000000Z",
     *       "updated_at": "2018-01-01T00:00:00.000000Z"
     *     } */
    NumberReservation: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example number_reservation */
      readonly record_type?: string;
      phone_numbers?: components['schemas']['ReservedPhoneNumber'][];
      /**
       * @description The status of the entire reservation.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the numbers reservation was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number reservation was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
    };
    /** OrderExternalVetting */
    OrderExternalVetting: {
      /**
       * Evpid
       * @description External vetting provider ID for the brand.
       */
      evpId: string;
      /**
       * Vettingclass
       * @description Identifies the vetting classification.
       */
      vettingClass: string;
    };
    /**
     * @description The original URL to the PDF used for the fax's media. If media_name was supplied, this is omitted
     * @example https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf
     */
    OriginalMediaUrl: string;
    /** @example {
     *       "call_recording_type": "by_caller_phone_number",
     *       "call_recording_caller_phone_numbers": [
     *         "+19705555098"
     *       ],
     *       "call_recording_channels": "dual",
     *       "call_recording_format": "mp3"
     *     } */
    OutboundCallRecording: {
      /**
       * @description Specifies which calls are recorded.
       * @enum {string}
       */
      call_recording_type?: 'all' | 'none' | 'by_caller_phone_number';
      /**
       * @description When call_recording_type is 'by_caller_phone_number', only outbound calls using one of these numbers will be recorded. Numbers must be specified in E164 format.
       * @example [
       *       "+19705555098"
       *     ]
       */
      call_recording_caller_phone_numbers?: string[];
      /**
       * @description When using 'dual' channels, the final audio file will be a stereo recording with the first leg on channel A, and the rest on channel B.
       * @default single
       * @example dual
       * @enum {string}
       */
      call_recording_channels: 'single' | 'dual';
      /**
       * @description The audio file format for calls being recorded.
       * @default wav
       * @example mp3
       * @enum {string}
       */
      call_recording_format: 'wav' | 'mp3';
    };
    /** Connection Outbound Settings */
    OutboundFqdn: {
      /**
       * ANI override type
       * Format: E.164
       * @description Set a phone number as the ani_override value to override caller id number on outbound calls.
       */
      ani_override?: string;
      /**
       * ANI override type
       * @description Specifies when we should apply your ani_override setting. Only applies when ani_override is not blank.
       * @default always
       * @example normal
       * @enum {string}
       */
      ani_override_type: 'always' | 'normal' | 'emergency';
      /**
       * @description Forces all SIP calls originated on this connection to be \"parked\" instead of \"bridged\" to the destination specified on the URI. Parked calls will return ringback to the caller and will await for a Call Control command to define which action will be taken next.
       * @default false
       */
      call_parking_enabled: boolean | null;
      /** @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection. */
      channel_limit?: number;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description When set, ringback will not wait for indication before sending ringback tone to calling party.
       * @default false
       */
      instant_ringback_enabled: boolean;
      /**
       * @default ip-authentication
       * @example credential-authentication
       * @enum {string}
       */
      ip_authentication_method:
        | 'credential-authentication'
        | 'ip-authentication';
      ip_authentication_token?: string;
      /**
       * @description A 2-character country code specifying the country whose national dialing rules should be used. For example, if set to `US` then any US number can be dialed without preprending +1 to the number. When left blank, Telnyx will try US and GB dialing rules, in that order, by default.",
       * @default US
       * @example US
       */
      localization: string;
      outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      /**
       * @description This setting only affects connections with Fax-type Outbound Voice Profiles. The setting dictates whether or not Telnyx sends a t.38 reinvite. By default, Telnyx will send the re-invite. If set to `customer`, the caller is expected to send the t.38 reinvite.
       * @default customer
       * @enum {string}
       */
      t38_reinvite_source:
        | 'telnyx'
        | 'customer'
        | 'disabled'
        | 'passthru'
        | 'caller-passthru'
        | 'callee-passthru';
      /** @description Numerical chars only, exactly 4 characters. */
      tech_prefix?: string;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Time(sec) before aborting if connection is not made.
       * @default 3
       */
      timeout_1xx_secs: number;
      /**
       * @description Time(sec) before aborting if call is unanswered (min: 1, max: 600).
       * @default 90
       */
      timeout_2xx_secs: number;
    };
    /**
     * Outbound Ip
     * @example {
     *       "call_parking_enabled": true,
     *       "ani_override": "string",
     *       "ani_override_type": "always",
     *       "channel_limit": 10,
     *       "instant_ringback_enabled": true,
     *       "generate_ringback_tone": true,
     *       "localization": "string",
     *       "t38_reinvite_source": "customer",
     *       "tech_prefix": "string",
     *       "ip_authentication_method": "token",
     *       "ip_authentication_token": "string",
     *       "outbound_voice_profile_id": "1293384261075731499"
     *     }
     */
    OutboundIp: {
      /**
       * @description Forces all SIP calls originated on this connection to be "parked" instead of "bridged" to the destination specified on the URI. Parked calls will return ringback to the caller and will await for a Call Control command to define which action will be taken next.
       * @default false
       */
      call_parking_enabled: boolean | null;
      /**
       * @description Set a phone number as the ani_override value to override caller id number on outbound calls.
       * @default
       */
      ani_override: string;
      /**
       * @description Specifies when we apply your ani_override setting. Only applies when ani_override is not blank.
       * @default always
       * @enum {string}
       */
      ani_override_type: 'always' | 'normal' | 'emergency';
      /**
       * @description When set, this will limit the total number of outbound calls to phone numbers associated with this connection.
       * @default null
       */
      channel_limit: number;
      /**
       * @description When set, ringback will not wait for indication before sending ringback tone to calling party.
       * @default true
       */
      instant_ringback_enabled: boolean;
      /**
       * @description Generate ringback tone through 183 session progress message with early media.
       * @default false
       */
      generate_ringback_tone: boolean;
      /**
       * @description A 2-character country code specifying the country whose national dialing rules should be used. For example, if set to `US` then any US number can be dialed without preprending +1 to the number. When left blank, Telnyx will try US and GB dialing rules, in that order, by default.
       * @default null
       */
      localization: string;
      /**
       * @description This setting only affects connections with Fax-type Outbound Voice Profiles. The setting dictates whether or not Telnyx sends a t.38 reinvite.<br/><br/> By default, Telnyx will send the re-invite. If set to `customer`, the caller is expected to send the t.38 reinvite.
       * @default customer
       * @enum {string}
       */
      t38_reinvite_source:
        | 'telnyx'
        | 'customer'
        | 'disabled'
        | 'passthru'
        | 'caller-passthru'
        | 'callee-passthru';
      /**
       * @description Numerical chars only, exactly 4 characters.
       * @default
       */
      tech_prefix: string;
      /**
       * @default tech-prefixp-charge-info
       * @example tech-prefixp-charge-info
       * @enum {string}
       */
      ip_authentication_method: 'tech-prefixp-charge-info' | 'token';
      /** @default null */
      ip_authentication_token: string;
      outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
    };
    /** @example {
     *       "record_type": "event",
     *       "id": "86f58db9-0fe3-4adc-9d1f-46e66e6e9323",
     *       "event_type": "message.sent",
     *       "occurred_at": "date-time",
     *       "payload": {
     *         "record_type": "message",
     *         "direction": "outbound",
     *         "id": "40385f64-5717-4562-b3fc-2c963f66afa6",
     *         "type": "MMS",
     *         "messaging_profile_id": "4000eba1-a0c0-4563-9925-b25e842a7cb6",
     *         "organization_id": "b448f9cc-a842-4784-98e9-03c1a5872950",
     *         "from": {
     *           "phone_number": "+18445550001",
     *           "carrier": "TELNYX LLC",
     *           "line_type": "VoIP"
     *         },
     *         "to": [
     *           {
     *             "phone_number": "+18665550001",
     *             "status": "queued",
     *             "carrier": "T-MOBILE USA, INC.",
     *             "line_type": "Wireless"
     *           }
     *         ],
     *         "text": "Hello, World!",
     *         "subject": "From Telnyx!",
     *         "media": [
     *           {
     *             "url": "https://pbs.twimg.com/profile_images/1142168442042118144/AW3F4fFD_400x400.png",
     *             "content_type": null,
     *             "sha256": null,
     *             "size": null
     *           }
     *         ],
     *         "webhook_url": "https://www.example.com/hooks",
     *         "webhook_failover_url": "https://backup.example.com/hooks",
     *         "encoding": "GSM-7",
     *         "parts": 1,
     *         "tags": [
     *           "Greetings"
     *         ],
     *         "cost": null,
     *         "received_at": "2019-01-23T18:10:02.574Z",
     *         "sent_at": null,
     *         "completed_at": null,
     *         "valid_until": null,
     *         "errors": []
     *       }
     *     } */
    OutboundMessage: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      id?: string;
      /**
       * @description The type of event being delivered.
       * @example message.sent
       * @enum {string}
       */
      event_type?: 'message.sent' | 'message.finalized';
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      occurred_at?: string;
      payload?: components['schemas']['OutboundMessagePayload'];
    };
    OutboundMessageEvent: {
      data?: components['schemas']['OutboundMessage'];
      meta?: {
        /**
         * @description Number of attempts to deliver the webhook event.
         * @example 1
         */
        attempt?: number;
        /**
         * Format: url
         * @description The webhook URL the event was delivered to.
         * @example https://www.example.com/hooks
         */
        delivered_to?: string;
      };
    };
    /** @example {
     *       "record_type": "message",
     *       "direction": "outbound",
     *       "id": "40385f64-5717-4562-b3fc-2c963f66afa6",
     *       "type": "MMS",
     *       "messaging_profile_id": "4000eba1-a0c0-4563-9925-b25e842a7cb6",
     *       "organization_id": "b448f9cc-a842-4784-98e9-03c1a5872950",
     *       "from": {
     *         "phone_number": "+18445550001",
     *         "carrier": "TELNYX LLC",
     *         "line_type": "VoIP"
     *       },
     *       "to": [
     *         {
     *           "phone_number": "+18665550001",
     *           "status": "queued",
     *           "carrier": "T-MOBILE USA, INC.",
     *           "line_type": "Wireless"
     *         }
     *       ],
     *       "text": "Hello, World!",
     *       "subject": "From Telnyx!",
     *       "media": [
     *         {
     *           "url": "https://pbs.twimg.com/profile_images/1142168442042118144/AW3F4fFD_400x400.png",
     *           "content_type": null,
     *           "sha256": null,
     *           "size": null
     *         }
     *       ],
     *       "webhook_url": "https://www.example.com/hooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "encoding": "GSM-7",
     *       "parts": 1,
     *       "tags": [
     *         "Greetings"
     *       ],
     *       "cost": null,
     *       "received_at": "2019-01-23T18:10:02.574Z",
     *       "sent_at": null,
     *       "completed_at": null,
     *       "valid_until": null,
     *       "errors": []
     *     } */
    OutboundMessagePayload: {
      /**
       * @description Identifies the type of the resource.
       * @example message
       * @enum {string}
       */
      record_type?: 'message';
      /**
       * @description The direction of the message. Inbound messages are sent to you whereas outbound messages are sent from you.
       * @example outbound
       * @enum {string}
       */
      direction?: 'outbound';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      id?: string;
      /**
       * @description The type of message.
       * @enum {string}
       */
      type?: 'SMS' | 'MMS';
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id?: string;
      /**
       * Format: uuid
       * @description The id of the organization the messaging profile belongs to.
       */
      organization_id?: string;
      from?: {
        /**
         * Format: address
         * @description Sending address (+E.164 formatted phone number, alphanumeric sender ID, or short code).
         */
        phone_number?: string;
        /** @description The carrier of the receiver. */
        carrier?: string;
        /**
         * @description The line-type of the receiver.
         * @enum {string}
         */
        line_type?:
          | 'Wireline'
          | 'Wireless'
          | 'VoWiFi'
          | 'VoIP'
          | 'Pre-Paid Wireless'
          | '';
      };
      to?: {
        /**
         * Format: address
         * @description Receiving address (+E.164 formatted phone number or short code).
         */
        phone_number?: string;
        /**
         * @description The delivery status of the message.
         * @enum {string}
         */
        status?:
          | 'queued'
          | 'sending'
          | 'sent'
          | 'expired'
          | 'sending_failed'
          | 'delivery_unconfirmed'
          | 'delivered'
          | 'delivery_failed';
        /** @description The carrier of the receiver. */
        carrier?: string;
        /**
         * @description The line-type of the receiver.
         * @enum {string}
         */
        line_type?:
          | 'Wireline'
          | 'Wireless'
          | 'VoWiFi'
          | 'VoIP'
          | 'Pre-Paid Wireless'
          | '';
      }[];
      /** @description Message body (i.e., content) as a non-empty string.
       *
       *     **Required for SMS** */
      text?: string;
      /** @description Subject of multimedia message */
      subject?: string | null;
      media?: {
        /**
         * Format: url
         * @description The url of the media requested to be sent.
         */
        url?: string;
        /**
         * Format: mime-type
         * @description The MIME type of the requested media.
         */
        content_type?: string | null;
        /** @description The SHA256 hash of the requested media. */
        sha256?: string | null;
        /** @description The size of the requested media. */
        size?: number | null;
      }[];
      /**
       * Format: url
       * @description The URL where webhooks related to this message will be sent.
       */
      webhook_url?: string | null;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this message will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string | null;
      /** @description Encoding scheme used for the message body. */
      encoding?: string;
      /** @description Number of parts into which the message's body must be split. */
      parts?: number;
      /** @description Tags associated with the resource. */
      tags?: string[];
      cost?: {
        /**
         * Format: decimal
         * @description The amount deducted from your account.
         */
        amount?: string;
        /**
         * Format: iso4217
         * @description The ISO 4217 currency identifier.
         */
        currency?: string;
      } | null;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the message request was received.
       */
      received_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the message was sent.
       */
      sent_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the message was finalized.
       */
      completed_at?: string;
      /**
       * Format: date-time
       * @description Message must be out of the queue by this time or else it will be discarded and marked as 'sending_failed'. Once the message moves out of the queue, this field will be nulled
       */
      valid_until?: string | null;
      /** @description These errors may point at addressees when referring to unsuccessful/unconfirmed delivery statuses. */
      errors?: components['schemas']['Error'][];
    };
    /**
     * Outbound Voice Profile
     * @example {
     *       "id": "1293384261075731499",
     *       "record_type": "outbound_voice_profile",
     *       "name": "office",
     *       "connections_count": 12,
     *       "traffic_type": "conversational",
     *       "service_plan": "global",
     *       "concurrent_call_limit": 10,
     *       "enabled": true,
     *       "tags": [
     *         "office-profile"
     *       ],
     *       "usage_payment_method": "rate-deck",
     *       "whitelisted_destinations": [
     *         "US",
     *         "BR",
     *         "AU"
     *       ],
     *       "max_destination_rate": 10,
     *       "daily_spend_limit": "100.00",
     *       "daily_spend_limit_enabled": true,
     *       "call_recording": {
     *         "call_recording_type": "by_caller_phone_number",
     *         "call_recording_caller_phone_numbers": [
     *           "+19705555098"
     *         ],
     *         "call_recording_channels": "dual",
     *         "call_recording_format": "mp3"
     *       },
     *       "billing_group_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     }
     */
    OutboundVoiceProfile: {
      /**
       * Format: int64
       * @description Identifies the resource.
       * @example 1293384261075731499
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example outbound_voice_profile
       */
      record_type?: string;
      /**
       * @description A user-supplied name to help with organization.
       * @example office
       */
      name: string;
      /**
       * @description Amount of connections associated with this outbound voice profile.
       * @example 12
       */
      connections_count?: number;
      traffic_type?: components['schemas']['TrafficType'];
      service_plan?: components['schemas']['ServicePlan'];
      /**
       * @description Must be no more than your global concurrent call limit. Null means no limit.
       * @example 10
       */
      concurrent_call_limit?: number | null;
      /**
       * @description Specifies whether the outbound voice profile can be used. Disabled profiles will result in outbound calls being blocked for the associated Connections.
       * @default true
       * @example true
       */
      enabled: boolean;
      /** @example [
       *       "office-profile"
       *     ] */
      tags?: string[];
      usage_payment_method?: components['schemas']['UsagePaymentMethod'];
      /**
       * @description The list of destinations you want to be able to call using this outbound voice profile formatted in alpha2.
       * @default [
       *       "US",
       *       "CA"
       *     ]
       * @example [
       *       "US",
       *       "BR",
       *       "AU"
       *     ]
       */
      whitelisted_destinations: string[];
      /** @description Maximum rate (price per minute) for a Destination to be allowed when making outbound calls. */
      max_destination_rate?: number;
      /**
       * @description The maximum amount of usage charges, in USD, you want Telnyx to allow on this outbound voice profile in a day before disallowing new calls.
       * @example 100.00
       */
      daily_spend_limit?: string;
      /**
       * @description Specifies whether to enforce the daily_spend_limit on this outbound voice profile.
       * @default false
       * @example true
       */
      daily_spend_limit_enabled: boolean;
      call_recording?: components['schemas']['OutboundCallRecording'];
      /**
       * Format: uuid
       * @description The ID of the billing group associated with the outbound proflile. Defaults to null (for no group assigned).
       * @default null
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      billing_group_id: string | null;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /**
     * Outbound Voice Profile ID
     * Format: int64
     * @description Identifies the associated outbound voice profile.
     * @example 1293384261075731499
     */
    OutboundVoiceProfileId: string;
    /** @description The summary of the resource that have been assigned to the Private Wireless Gateway. */
    PWGAssignedResourcesSummary: {
      /**
       * @description The type of the resource assigned to the Private Wireless Gateway.
       * @example sim_card_group
       */
      readonly record_type?: string;
      /**
       * @description The current count of a resource type assigned to the Private Wireless Gateway.
       * @example 1
       */
      readonly count?: number;
    };
    /**
     * Paginated[VerificationRequestStatus]
     * @description A paginated response
     */
    Paginated_VerificationRequestStatus_: {
      /**
       * Records
       * @description The records yielded by this request
       * @default []
       */
      records: components['schemas']['VerificationRequestStatus'][];
      /**
       * Total Records
       * @description The total amount of records for these query parameters
       * @default 0
       */
      total_records: number;
    };
    PaginationData: {
      /**
       * @description Total number of pages.
       * @example 5
       */
      total_pages?: number;
      /**
       * @description Total number of results.
       * @example 100
       */
      total_results?: number;
      /**
       * @description Selected page number.
       * @example 1
       */
      page_number?: number;
      /**
       * @description Records per single page
       * @example 20
       */
      page_size?: number;
    };
    PaginationMeta: {
      /** @example 3 */
      total_pages?: number;
      /** @example 55 */
      total_results?: number;
      /** @example 2 */
      page_number?: number;
      /** @example 25 */
      page_size?: number;
    };
    PaginationMetaSimple: {
      /** @example 2 */
      page_number?: number;
      /** @example 25 */
      page_size?: number;
      /** @example 3 */
      total_pages?: number;
      /** @example 55 */
      total_results?: number;
    };
    /** ParameterProperties */
    ParameterProperties: {
      /** Type */
      type: string;
      /**
       * Description
       * @default
       */
      description: string;
      /** Enum */
      enum?: string[];
    };
    /**
     * Participant
     * @example {
     *       "record_type": "participant",
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z",
     *       "end_conference_on_exit": true,
     *       "soft_end_conference_on_exit": true,
     *       "status": "joining",
     *       "muted": false,
     *       "on_hold": true,
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "whisper_call_control_ids": [
     *         "v2:Sg1xxxQ_U3ixxxyXT_VDNI3xxxazZdg6Vxxxs4-GNYxxxVaJPOhFMRQ",
     *         "v2:qqpb0mmvd-ovhhBr0BUQQn0fld5jIboaaX3-De0DkqXHzbf8d75xkw"
     *       ],
     *       "id": "dfadada7-af74-47bc-83a4-554275f55f5c",
     *       "call_leg_id": "3a15df2d-c801-4729-adf5-b56dd42e2abb",
     *       "conference": {
     *         "id": "41b9acd4-f4da-4ff5-a85c-e07e90b53f46",
     *         "name": "1"
     *       }
     *     }
     */
    Participant: {
      /**
       * @example participant
       * @enum {string}
       */
      record_type: 'participant';
      /**
       * @description Uniquely identifies the participant
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      id: string;
      /**
       * @description Uniquely identifies the call leg associated with the participant
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      call_leg_id: string;
      /**
       * @description Call Control ID associated with the partiipant of the conference
       * @example v2:v2:T02llQxIyaRkhfRKxgAP8nY511EhFLizdvdUKJiSw8d6A9BborherQczRrZvZakpWxBlpw48KyZQ
       */
      call_control_id: string;
      /** @description Info about the conference that the participant is in */
      conference: {
        /**
         * @description Uniquely identifies the conference
         * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
         */
        id?: string;
        /**
         * @description Name of the conference
         * @example All hands meeting
         */
        name?: string;
      };
      /**
       * @description Array of unique call_control_ids the participant can whisper to..
       * @example [
       *       "v2:Sg1xxxQ_U3ixxxyXT_VDNI3xxxazZdg6Vxxxs4-GNYxxxVaJPOhFMRQ",
       *       "v2:qqpb0mmvd-ovhhBr0BUQQn0fld5jIboaaX3-De0DkqXHzbf8d75xkw"
       *     ]
       */
      whisper_call_control_ids: string[];
      /**
       * @description ISO 8601 formatted date of when the participant was created
       * @example 2019-01-23T18:10:02.574Z
       */
      created_at: string;
      /**
       * @description ISO 8601 formatted date of when the participant was last updated
       * @example 2019-01-23T18:10:02.574Z
       */
      updated_at: string;
      /**
       * @description Whether the conference will end and all remaining participants be hung up after the participant leaves the conference.
       * @example true
       */
      end_conference_on_exit: boolean;
      /**
       * @description Whether the conference will end after the participant leaves the conference.
       * @example true
       */
      soft_end_conference_on_exit: boolean;
      /**
       * @description The status of the participant with respect to the lifecycle within the conference
       * @example joining
       * @enum {string}
       */
      status: 'joining' | 'joined' | 'left';
      /**
       * @description Whether the participant is muted.
       * @example true
       */
      muted: boolean;
      /**
       * @description Whether the participant is put on_hold.
       * @example true
       */
      on_hold: boolean;
    };
    /**
     * Participant Joined
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.session.started",
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *         "room_id": "0ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "participant_id": "5ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "context": "Alice"
     *       }
     *     }
     */
    ParticipantJoined: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.participant.joined
       * @enum {string}
       */
      event_type?: 'video.room.participant.joined';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Session ID that identifies the session where the participant joined.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: uuid
         * @description Room ID that identifies the room where the participant joined.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
        /**
         * @description Context provided to the given participant through the client SDK
         * @example Alice
         */
        context?: string;
        /**
         * Format: uuid
         * @description Participant ID that identifies the participant that joined.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        participant_id?: string;
      };
    };
    /** Participant Joined Event */
    ParticipantJoinedEvent: {
      data?: components['schemas']['ParticipantJoined'];
    };
    /**
     * Participant Left
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.session.started",
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *         "room_id": "0ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "participant_id": "5ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "context": "Alice",
     *         "duration_secs": 34,
     *         "left_reason": "kick"
     *       }
     *     }
     */
    ParticipantLeft: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.participant.left
       * @enum {string}
       */
      event_type?: 'video.room.participant.left';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Session ID that identifies the session where the participant left.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: uuid
         * @description Room ID that identifies the room where the participant left.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
        /**
         * @description Context provided to the given participant through the client SDK
         * @example Alice
         */
        context?: string;
        /**
         * Format: uuid
         * @description Participant ID that identifies the participant that left.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        participant_id?: string;
        /**
         * @description The duration in seconds of the participant in the session
         * @example 245
         */
        duration_secs?: number;
        /**
         * @description The reason why the participant left
         * @example kicked
         */
        left_reason?: string;
      };
    };
    /** Participant Left Event */
    ParticipantLeftEvent: {
      data?: components['schemas']['ParticipantLeft'];
    };
    /**
     * Participant resource
     * @example {
     *       "account_sid": "4e71926f-8f13-450e-b91c-23c2ef786aa6",
     *       "api_version": "v2/texml",
     *       "call_sid": "v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ",
     *       "call_sid_legacy": "v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ",
     *       "coaching": false,
     *       "coaching_call_sid": null,
     *       "coaching_call_sid_legacy": null,
     *       "conference_sid": "cd5a70f4-759b-4d5e-9c06-88c00f16f3c1",
     *       "date_created": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "date_updated": "Fri, 27 Oct 2023 07:41:58 +0000",
     *       "end_conference_on_exit": false,
     *       "hold": false,
     *       "muted": false,
     *       "status": "completed",
     *       "uri": "/v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Participants/v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ.json"
     *     }
     */
    ParticipantResource: {
      /**
       * @description The id of the account the resource belongs to.
       * @example 61bf923e-5e4d-4595-a110-56190ea18a1b
       */
      account_sid?: string;
      /**
       * @description The version of the API that was used to make the request.
       * @example v2/texml
       */
      api_version?: string;
      /**
       * @description The identifier of this participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      call_sid?: string;
      /**
       * @description The identifier of this participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      call_sid_legacy?: string;
      /**
       * @description Whether the participant is coaching another call.
       * @example false
       */
      coaching?: boolean;
      /**
       * @description The identifier of the coached participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      coaching_call_sid?: string;
      /**
       * @description The identifier of the coached participant's call.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      coaching_call_sid_legacy?: string;
      /**
       * @description The timestamp of when the resource was created.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_created?: string;
      /**
       * @description The timestamp of when the resource was last updated.
       * @example Thu, 15 Jun 2023 09:56:45 +0000
       */
      date_updated?: string;
      /**
       * @description Whether the conference ends when the participant leaves.
       * @example false
       */
      end_conference_on_exit?: boolean;
      /**
       * @description Whether the participant is on hold.
       * @example false
       */
      hold?: boolean;
      /**
       * @description Whether the participant is muted.
       * @example false
       */
      muted?: boolean;
      /**
       * @description The status of the participant's call in the conference.
       * @example in-progress
       * @enum {string}
       */
      status?: 'connecting' | 'connected' | 'completed';
      /**
       * @description The relative URI for this participant.
       * @example /v2/texml/Accounts/4e71926f-8f13-450e-b91c-23c2ef786aa6/Conferences/cd5a70f4-759b-4d5e-9c06-88c00f16f3c1/Participants/v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ.json
       */
      uri?: string;
    };
    /**
     * Multiple participant resources
     * @example {
     *       "participants": [],
     *       "end": 0,
     *       "first_page_uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Participants.json?page=0&pagesize=20",
     *       "next_page_uri": null,
     *       "page": 0,
     *       "page_size": 20,
     *       "start": 0,
     *       "uri": "/v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Participants.json?page=0&pagesize=20"
     *     }
     */
    ParticipantResourceIndex: {
      participants?: components['schemas']['ParticipantResource'][];
      /**
       * @description The number of the last element on the page, zero-indexed.
       * @example 19
       */
      end?: number;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Participants.json?page=0&pagesize=20
       * @example accepted
       */
      first_page_uri?: string;
      /**
       * @description /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Participants.json?Page=1&PageSize=1&PageToken=MTY4AjgyNDkwNzIxMQ
       * @example accepted
       */
      next_page_uri?: string;
      /**
       * @description Current page number, zero-indexed.
       * @example 0
       */
      page?: number;
      /**
       * @description The number of items on the page
       * @example 20
       */
      page_size?: number;
      /**
       * @description The number of the first element on the page, zero-indexed.
       * @example 0
       */
      start?: number;
      /**
       * @description The URI of the current page.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Conferences/6dc6cc1a-1ba1-4351-86b8-4c22c95cd98f/Participants.json?Page=0&PageSize=1
       */
      uri?: string;
    };
    PatchRoomRequest: {
      /**
       * @description The unique (within the Telnyx account scope) name of the room.
       * @example My room
       */
      unique_name?: string;
      /**
       * @description The maximum amount of participants allowed in a room. If new participants try to join after that limit is reached, their request will be rejected.
       * @default 10
       * @example 10
       */
      max_participants: number;
      /**
       * @description Enable or disable recording for that room.
       * @default false
       * @example true
       */
      enable_recording: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this room will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this room will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
    };
    /** Pause Recording Request */
    PauseConferenceRecordingRequest: {
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Use this field to pause specific recording.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      recording_id?: string;
    };
    /** Pause Recording Request */
    PauseRecordingRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** @example {
     *       "id": "dc8e4d67-33a0-4cbb-af74-7b58f05bd494",
     *       "record_type": "number_order_phone_number",
     *       "phone_number": "+19705555098",
     *       "bundle_id": "bc8e4d67-33a0-4cbb-af74-7b58f05bd474",
     *       "regulatory_requirements": [
     *         {
     *           "record_type": "phone_number_regulatory_requirement",
     *           "requirement_id": "8ffb3622-7c6b-4ccc-b65f-7a3dc0099576",
     *           "field_value": "45f45a04-b4be-4592-95b1-9306b9db2b21",
     *           "field_type": "address"
     *         }
     *       ],
     *       "requirements_met": true,
     *       "status": "success"
     *     } */
    PhoneNumber: {
      /**
       * Format: uuid
       * @example dc8e4d67-33a0-4cbb-af74-7b58f05bd494
       */
      readonly id?: string;
      /** @example number_order_phone_number */
      readonly record_type?: string;
      /**
       * Format: e164_phone_number
       * @example +19705555098
       */
      phone_number?: string;
      regulatory_requirements?: components['schemas']['SubNumberOrderRegulatoryRequirementWithValue'][];
      /**
       * @description True if all requirements are met for a phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
      /**
       * @description Status of document requirements (if applicable)
       * @enum {string}
       */
      readonly requirements_status?:
        | 'pending'
        | 'approved'
        | 'cancelled'
        | 'deleted'
        | 'requirement-info-exception'
        | 'requirement-info-pending'
        | 'requirement-info-under-review';
      /**
       * @description The status of the phone number in the order.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * Format: uuid
       * @example bc8e4d67-33a0-4cbb-af74-7b58f05bd494
       */
      readonly bundle_id?: string;
      /**
       * @description Phone number type
       * @enum {string}
       */
      readonly phone_number_type?:
        | 'local'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'toll_free';
      /**
       * @description Country code of the phone number
       * @example US
       */
      readonly country_code?: string;
    };
    /** @example {
     *       "id": "42587e44-3a3e-46de-9255-0c9a7a1d1ec7",
     *       "record_type": "phone_numbers_job",
     *       "status": "pending",
     *       "type": "delete_phone_number_block",
     *       "etc": "2020-10-30T18:10:00.000Z",
     *       "created_at": "2020-10-23T18:10:00.000Z",
     *       "updated_at": "2020-10-23T18:10:01.000Z",
     *       "successful_operations": [],
     *       "failed_operations": []
     *     } */
    PhoneNumberBlocksJob: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 42587e44-3a3e-46de-9255-0c9a7a1d1ec7
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example phone_number_block_job
       */
      readonly record_type?: string;
      /**
       * @description Indicates the completion status of the background operation.
       * @default pending
       * @example pending
       * @enum {string}
       */
      readonly status: 'pending' | 'in_progress' | 'completed' | 'failed';
      /**
       * @description Identifies the type of the background job.
       * @example delete_phone_number_block
       * @enum {string}
       */
      readonly type?: 'delete_phone_number_block';
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the estimated time of completion of the background job.
       */
      readonly etc?: string;
      /** @description ISO 8601 formatted date indicating when the resource was created. */
      readonly created_at?: string;
      /** @description ISO 8601 formatted date indicating when the resource was updated. */
      readonly updated_at?: string;
      readonly successful_operations?: components['schemas']['PhoneNumberBlocksJobSuccessfulOperation'][];
      readonly failed_operations?: components['schemas']['PhoneNumberBlocksJobFailedOperation'][];
    };
    /** @example {
     *       "phone_number_block_id": "f3946371-7199-4261-9c3d-81a0d7935146"
     *     } */
    PhoneNumberBlocksJobDeletePhoneNumberBlockRequest: {
      phone_number_block_id: string;
    };
    PhoneNumberBlocksJobFailedOperation: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       */
      phone_number?: string;
      /**
       * Format: int64
       * @description The phone number's ID
       */
      id?: string;
      errors?: components['schemas']['Error'][];
    };
    PhoneNumberBlocksJobSuccessfulOperation: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       */
      phone_number?: string;
      /**
       * Format: int64
       * @description The phone number's ID
       */
      id?: string;
    };
    /** PhoneNumberCampaign */
    PhoneNumberCampaign: {
      /**
       * Phonenumber
       * @example +18005550199
       */
      phoneNumber: string;
      /**
       * BrandId
       * @description Brand ID. Empty if the number is associated to a shared campaign.
       * @example 7ba705b7-22af-493f-addc-ac04b7ca071c
       */
      brandId?: string;
      /**
       * TcrBrandId
       * @description TCR's alphanumeric ID for the brand.
       * @example BBRAND1
       */
      tcrBrandId?: string;
      /**
       * Campaignid
       * @description For shared campaigns, this is the TCR campaign ID, otherwise it is the campaign ID
       */
      campaignId: string;
      /**
       * TcrCampaignid
       * @description TCR's alphanumeric ID for the campaign.
       * @example CCAMPA1
       */
      tcrCampaignId?: string;
      /**
       * Telnyxcampaignid
       * @description Campaign ID. Empty if the number is associated to a shared campaign.
       * @example 3008dd9f-66d7-40e0-bf23-bf2d8d1a96ba
       */
      telnyxCampaignId?: string;
      /**
       * AssignmentStatus
       * @description The assignment status of the number.
       * @example ASSIGNED
       * @enum {unknown}
       */
      assignmentStatus?:
        | 'FAILED_ASSIGNMENT'
        | 'PENDING_ASSIGNMENT'
        | 'ASSIGNED'
        | 'PENDING_UNASSIGNMENT'
        | 'FAILED_UNASSIGNMENT';
      /** @description Extra info about a failure to assign/unassign a number. Relevant only if the assignmentStatus is either FAILED_ASSIGNMENT or FAILED_UNASSIGNMENT */
      failureReasons?: unknown;
      /**
       * Createdat
       * Format: date-time
       */
      createdAt: string;
      /**
       * Updatedat
       * Format: date-time
       */
      updatedAt: string;
    };
    /** PhoneNumberCampaignCreate */
    PhoneNumberCampaignCreate: {
      /**
       * Phonenumber
       * @description The phone number you want to link to a specified campaign.
       * @example +18005550199
       */
      phoneNumber: string;
      /**
       * Campaignid
       * @description The ID of the campaign you want to link to the specified phone number.
       * @example 4b300178-131c-d902-d54e-72d90ba1620j
       */
      campaignId: string;
    };
    /** PhoneNumberCampaignPaginated */
    PhoneNumberCampaignPaginated: {
      /** Records */
      records: components['schemas']['PhoneNumberCampaign'][];
      /** Page */
      page: number;
      /** Totalrecords */
      totalRecords: number;
    };
    /** PhoneNumberCampaignUpdate */
    PhoneNumberCampaignUpdate: {
      /**
       * Campaignid
       * @example 4b300178-131c-d902-d54e-72d90ba1620j
       */
      campaignId: string;
    };
    /** @example {
     *       "id": "1293384261075731499",
     *       "record_type": "phone_number",
     *       "phone_number": "+19705555098",
     *       "status": "deleted",
     *       "tags": [
     *         "tag_1",
     *         "tag_2"
     *       ],
     *       "external_pin": "1234",
     *       "connection_id": "1293384261075731499",
     *       "connection_name": "connection-name",
     *       "customer_reference": "customer-reference",
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600000000",
     *       "messaging_profile_name": "regional-customers",
     *       "billing_group_id": "86f58db9-0fe3-4adc-9d1f-46e66e6e9323",
     *       "emergency_enabled": true,
     *       "emergency_address_id": "1315261609962112019",
     *       "call_forwarding_enabled": true,
     *       "cnam_listing_enabled": true,
     *       "caller_id_name_enabled": true,
     *       "call_recording_enabled": true,
     *       "t38_fax_gateway_enabled": true,
     *       "number_level_routing": "disabled",
     *       "phone_number_type": "local",
     *       "purchased_at": "2019-10-23T18:10:00.000Z",
     *       "created_at": "2019-10-23T18:10:00.000Z",
     *       "updated_at": "2019-10-24T18:10:00.000Z",
     *       "hd_voice_enabled": true
     *     } */
    PhoneNumberDeletedDetailed: {
      id?: components['schemas']['IntId'];
      /**
       * @description Identifies the type of the resource.
       * @example phone_number
       */
      readonly record_type?: string;
      /** @description The +E.164-formatted phone number associated with this record. */
      readonly phone_number?: string;
      /**
       * @description The phone number's current status.
       * @enum {string}
       */
      readonly status?:
        | 'purchase-pending'
        | 'purchase-failed'
        | 'port-pending'
        | 'port-failed'
        | 'active'
        | 'deleted'
        | 'emergency-only'
        | 'ported-out'
        | 'port-out-pending';
      /** @description A list of user-assigned tags to help manage the phone number. */
      tags?: string[];
      /** @description If someone attempts to port your phone number away from Telnyx and your phone number has an external PIN set, Telnyx will attempt to verify that you provided the correct external PIN to the winning carrier. Note that not all carriers cooperate with this security mechanism. */
      external_pin?: string;
      /** @description The user-assigned name of the connection to be associated with this phone number. */
      readonly connection_name?: string;
      /** @description Identifies the connection associated with the phone number. */
      connection_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @description Identifies the messaging profile associated with the phone number. */
      messaging_profile_id?: string;
      /**
       * @description The name of the messaging profile associated with the phone number.
       * @example regional-customers
       */
      messaging_profile_name?: string;
      /** @description Identifies the billing group associated with the phone number. */
      billing_group_id?: string;
      /** @description Indicates whether emergency services are enabled for this number. */
      readonly emergency_enabled?: boolean;
      /**
       * Format: int64
       * @description Identifies the emergency address associated with the phone number.
       */
      readonly emergency_address_id?: string;
      /**
       * @description Indicates if call forwarding will be enabled for this number if forwards_to and forwarding_type are filled in. Defaults to true for backwards compatibility with APIV1 use of numbers endpoints.
       * @default true
       */
      readonly call_forwarding_enabled: boolean;
      /** @description Indicates whether a CNAM listing is enabled for this number. */
      readonly cnam_listing_enabled?: boolean;
      /** @description Indicates whether caller ID is enabled for this number. */
      readonly caller_id_name_enabled?: boolean;
      /** @description Indicates whether call recording is enabled for this number. */
      readonly call_recording_enabled?: boolean;
      /** @description Indicates whether T38 Fax Gateway for inbound calls to this number. */
      readonly t38_fax_gateway_enabled?: boolean;
      /** @description ISO 8601 formatted date indicating the time the request was made to purchase the number. */
      readonly purchased_at?: string;
      /** @description ISO 8601 formatted date indicating when the time it took to activate after the purchase. */
      readonly created_at?: string;
      /** @description ISO 8601 formatted date indicating when the resource was updated. */
      readonly updated_at?: string;
      /**
       * @description Deprecated field, the only value for this is 'disabled'. All routing for numbers should be configured via connection settings.
       * @default disabled
       * @enum {string}
       */
      number_level_routing: 'disabled';
      /**
       * @description The phone number's type.
       * @enum {string}
       */
      readonly phone_number_type?:
        | 'local'
        | 'toll_free'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'landline';
    };
    /** @example {
     *       "id": "1293384261075731499",
     *       "record_type": "phone_number",
     *       "phone_number": "+19705555098",
     *       "status": "active",
     *       "tags": [
     *         "tag_1",
     *         "tag_2"
     *       ],
     *       "external_pin": "1234",
     *       "connection_id": "1293384261075731499",
     *       "connection_name": "connection-name",
     *       "customer_reference": "customer-reference",
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600000000",
     *       "messaging_profile_name": "regional-customers",
     *       "billing_group_id": "86f58db9-0fe3-4adc-9d1f-46e66e6e9323",
     *       "emergency_enabled": true,
     *       "emergency_address_id": "1315261609962112019",
     *       "call_forwarding_enabled": true,
     *       "cnam_listing_enabled": true,
     *       "caller_id_name_enabled": true,
     *       "call_recording_enabled": true,
     *       "t38_fax_gateway_enabled": true,
     *       "number_level_routing": "disabled",
     *       "phone_number_type": "local",
     *       "inbound_call_screening": "disabled",
     *       "purchased_at": "2019-10-23T18:10:00.000Z",
     *       "created_at": "2019-10-23T18:10:00.000Z",
     *       "updated_at": "2019-10-24T18:10:00.000Z",
     *       "hd_voice_enabled": true
     *     } */
    PhoneNumberDetailed: {
      id?: components['schemas']['IntId'];
      /**
       * @description Identifies the type of the resource.
       * @example phone_number
       */
      readonly record_type?: string;
      /** @description The +E.164-formatted phone number associated with this record. */
      readonly phone_number?: string;
      /**
       * @description The phone number's current status.
       * @enum {string}
       */
      readonly status?:
        | 'purchase-pending'
        | 'purchase-failed'
        | 'port-pending'
        | 'port-failed'
        | 'active'
        | 'deleted'
        | 'emergency-only'
        | 'ported-out'
        | 'port-out-pending'
        | 'requirement-info-pending'
        | 'requirement-info-under-review'
        | 'requirement-info-exception'
        | 'provision-pending';
      /** @description A list of user-assigned tags to help manage the phone number. */
      tags?: string[];
      /** @description If someone attempts to port your phone number away from Telnyx and your phone number has an external PIN set, Telnyx will attempt to verify that you provided the correct external PIN to the winning carrier. Note that not all carriers cooperate with this security mechanism. */
      external_pin?: string;
      /** @description The user-assigned name of the connection to be associated with this phone number. */
      readonly connection_name?: string;
      /** @description Identifies the connection associated with the phone number. */
      connection_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @description Identifies the messaging profile associated with the phone number. */
      messaging_profile_id?: string;
      /**
       * @description The name of the messaging profile associated with the phone number.
       * @example regional-customers
       */
      messaging_profile_name?: string;
      /** @description Identifies the billing group associated with the phone number. */
      billing_group_id?: string;
      /** @description Indicates whether emergency services are enabled for this number. */
      readonly emergency_enabled?: boolean;
      /**
       * Format: int64
       * @description Identifies the emergency address associated with the phone number.
       */
      readonly emergency_address_id?: string;
      /**
       * @description Indicates if call forwarding will be enabled for this number if forwards_to and forwarding_type are filled in. Defaults to true for backwards compatibility with APIV1 use of numbers endpoints.
       * @default true
       */
      readonly call_forwarding_enabled: boolean;
      /** @description Indicates whether a CNAM listing is enabled for this number. */
      readonly cnam_listing_enabled?: boolean;
      /** @description Indicates whether caller ID is enabled for this number. */
      readonly caller_id_name_enabled?: boolean;
      /** @description Indicates whether call recording is enabled for this number. */
      readonly call_recording_enabled?: boolean;
      /** @description Indicates whether T38 Fax Gateway for inbound calls to this number. */
      readonly t38_fax_gateway_enabled?: boolean;
      /** @description ISO 8601 formatted date indicating when the resource was purchased. */
      readonly purchased_at?: string;
      /** @description ISO 8601 formatted date indicating when the resource was created. */
      readonly created_at?: string;
      /**
       * @description Deprecated field, the only value for this is 'disabled'. All routing for numbers should be configured via connection settings.
       * @default disabled
       * @enum {string}
       */
      number_level_routing: 'disabled';
      /**
       * @description The phone number's type.
       *     Note: For numbers purchased prior to July 2023 or when fetching a number's details immediately after a purchase completes, the legacy values `tollfree`, `shortcode` or `longcode` may be returned instead.
       * @enum {string}
       */
      readonly phone_number_type?:
        | 'local'
        | 'toll_free'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'landline'
        | 'tollfree'
        | 'shortcode'
        | 'longcode';
      /**
       * @description The inbound_call_screening setting is a phone number configuration option variable that allows users to configure their settings to block or flag fraudulent calls. It can be set to disabled, reject_calls, or flag_calls. This feature has an additional per-number monthly cost associated with it.
       * @default disabled
       * @enum {string}
       */
      inbound_call_screening: 'disabled' | 'reject_calls' | 'flag_calls';
    };
    /** @example {
     *       "emergency_enabled": true,
     *       "emergency_address_id": "53829456729313"
     *     } */
    PhoneNumberEnableEmergencyRequest: {
      /** @description Indicates whether to enable emergency services on this number. */
      emergency_enabled: boolean;
      /**
       * Format: int64
       * @description Identifies the address to be used with emergency services.
       */
      emergency_address_id: string;
    };
    /** PhoneNumberStatus */
    PhoneNumberStatus: {
      /**
       * Phonenumber
       * @description A phone number that is intended to be linked to a campaign.
       * @example +12193849584
       */
      phoneNumber: string;
      /**
       * @description The current status of the phone number.
       * @example pending
       */
      status: components['schemas']['AssignmentStatus'];
      /**
       * Assigned At
       * Format: date-time
       * @description The date and time that the this phone number was assigned.
       * @example 2021-06-30T10:49:04-07:00
       */
      assigned_at?: string;
      /**
       * Error
       * @description Errors related to an individual phone number assignment.
       * @example Detailed error description here.
       */
      error?: string;
    };
    /** PhoneNumberStatusResponsePaginated */
    PhoneNumberStatusResponsePaginated: {
      /** Records */
      records: components['schemas']['ProfileAssignmentPhoneNumbers'][];
    };
    /** @example {
     *       "record_type": "messaging_settings",
     *       "id": "1293384261075731499",
     *       "phone_number": "+18005550001",
     *       "messaging_profile_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z",
     *       "country_code": "US",
     *       "type": "toll-free",
     *       "health": {
     *         "message_count": 122,
     *         "inbound_outbound_ratio": 0.43,
     *         "success_ratio": 0.94,
     *         "spam_ratio": 0.06
     *       },
     *       "eligible_messaging_products": [
     *         "A2P"
     *       ],
     *       "traffic_type": "A2P",
     *       "messaging_product": "A2P",
     *       "features": {
     *         "sms": {
     *           "domestic_two_way": true,
     *           "international_inbound": true,
     *           "international_outbound": true
     *         },
     *         "mms": null
     *       }
     *     } */
    PhoneNumberWithMessagingSettings: {
      /**
       * @description Identifies the type of the resource.
       * @example messaging_settings
       * @enum {string}
       */
      readonly record_type?: 'messaging_phone_number' | 'messaging_settings';
      /** @description Identifies the type of resource. */
      readonly id?: string;
      /**
       * Format: e164
       * @description +E.164 formatted phone number.
       */
      readonly phone_number?: string;
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id?: string | null;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       */
      readonly updated_at?: string;
      /**
       * @description ISO 3166-1 alpha-2 country code.
       * @example US
       */
      readonly country_code?: string;
      /**
       * @description The type of the phone number
       * @enum {string}
       */
      readonly type?:
        | 'long-code'
        | 'toll-free'
        | 'short-code'
        | 'longcode'
        | 'tollfree'
        | 'shortcode';
      health?: components['schemas']['NumberHealthMetrics'];
      /** @description The messaging products that this number can be registered to use */
      readonly eligible_messaging_products?: string[];
      /**
       * @description The messaging traffic or use case for which the number is currently configured.
       * @example P2P
       */
      readonly traffic_type?: string;
      /**
       * @description The messaging product that the number is registered to use
       * @example P2P
       */
      messaging_product?: string;
      readonly features?: {
        sms?: components['schemas']['MessagingFeatureSet'];
        mms?: components['schemas']['MessagingFeatureSet'];
      };
    };
    /** @example {
     *       "id": "1293384261075731499",
     *       "record_type": "voice_settings",
     *       "connection_id": "1d0e6cb8-8668-462e-94c6-49ae0f0ed48b",
     *       "customer_reference": "customer-reference",
     *       "tech_prefix_enabled": false,
     *       "translated_number": "+13035559999",
     *       "call_forwarding": {
     *         "call_forwarding_enabled": true,
     *         "forwards_to": "+13035559123",
     *         "forwarding_type": "always"
     *       },
     *       "cnam_listing": {
     *         "cnam_listing_enabled": true,
     *         "cnam_listing_details": "example"
     *       },
     *       "emergency": {
     *         "emergency_enabled": true,
     *         "emergency_address_id": "1315261609962112019"
     *       },
     *       "usage_payment_method": "pay-per-minute",
     *       "media_features": {
     *         "rtp_auto_adjust_enabled": true,
     *         "accept_any_rtp_packets_enabled": true,
     *         "t38_fax_gateway_enabled": true
     *       },
     *       "call_recording": {
     *         "inbound_call_recording_enabled": true,
     *         "inbound_call_recording_format": "wav",
     *         "inbound_call_recording_channels": "single"
     *       },
     *       "inbound_call_screening": "disabled"
     *     } */
    PhoneNumberWithVoiceSettings: {
      /**
       * @description Identifies the type of resource.
       * @example 1293384261075731499
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example voice_settings
       */
      readonly record_type?: string;
      /**
       * @description The phone number in +E164 format.
       * @example +13035551234
       */
      readonly phone_number?: string;
      /**
       * @description Identifies the connection associated with this phone number.
       * @example 1d0e6cb8-8668-462e-94c6-49ae0f0ed48b
       */
      connection_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * @description Controls whether a tech prefix is enabled for this phone number.
       * @default false
       * @example false
       */
      tech_prefix_enabled: boolean;
      /**
       * @description This field allows you to rewrite the destination number of an inbound call before the call is routed to you. The value of this field may be any alphanumeric value, and the value will replace the number originally dialed.
       * @default
       * @example +13035559999
       */
      translated_number: string;
      call_forwarding?: components['schemas']['CallForwarding'];
      cnam_listing?: components['schemas']['CnamListing'];
      emergency?: components['schemas']['EmergencySettings'];
      /**
       * @description Controls whether a number is billed per minute or uses your concurrent channels.
       * @default pay-per-minute
       * @example pay-per-minute
       * @enum {string}
       */
      usage_payment_method: 'pay-per-minute' | 'channel';
      media_features?: components['schemas']['MediaFeatures'];
      call_recording?: components['schemas']['CallRecording'];
      /**
       * @description The inbound_call_screening setting is a phone number configuration option variable that allows users to configure their settings to block or flag fraudulent calls. It can be set to disabled, reject_calls, or flag_calls. This feature has an additional per-number monthly cost associated with it.
       * @default disabled
       * @enum {string}
       */
      inbound_call_screening: 'disabled' | 'reject_calls' | 'flag_calls';
    };
    PhoneNumbersBulkUpdateError: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       */
      phone_number?: string;
      errors?: components['schemas']['Error'][];
    };
    /** @example {
     *       "id": "42587e44-3a3e-46de-9255-0c9a7a1d1ec7",
     *       "record_type": "phone_numbers_job",
     *       "status": "pending",
     *       "type": "update_emergency_settings",
     *       "etc": "2020-10-30T18:10:00.000Z",
     *       "created_at": "2020-10-23T18:10:00.000Z",
     *       "updated_at": "2020-10-23T18:10:01.000Z",
     *       "phone_numbers": [
     *         {
     *           "id": "2637816387126861836"
     *         },
     *         {
     *           "phone_number": "+19715555098"
     *         },
     *         {
     *           "phone_number": "+19705555099"
     *         },
     *         {
     *           "id": "3388768018273"
     *         }
     *       ],
     *       "successful_operations": [
     *         {
     *           "id": "2637816387126861836",
     *           "phone_number": "+19705555098"
     *         },
     *         {
     *           "id": "33081887126861836",
     *           "phone_number": "+19715555098"
     *         }
     *       ],
     *       "pending_operations": [
     *         {
     *           "id": "2637816387126861837",
     *           "phone_number": "+19705555099"
     *         }
     *       ],
     *       "failed_operations": [
     *         {
     *           "id": "3388768018273",
     *           "phone_number": "+19705551234",
     *           "errors": [
     *             {
     *               "code": "10015",
     *               "title": "Bad Request",
     *               "detail": "The field is invalid.",
     *               "source": "/emergency_address_id"
     *             }
     *           ]
     *         }
     *       ]
     *     } */
    PhoneNumbersJob: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 42587e44-3a3e-46de-9255-0c9a7a1d1ec7
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example phone_numbers_job
       */
      readonly record_type?: string;
      /**
       * @description Indicates the completion status of the background update.
       * @default pending
       * @example pending
       * @enum {string}
       */
      readonly status:
        | 'pending'
        | 'in_progress'
        | 'completed'
        | 'failed'
        | 'expired';
      /**
       * @description Identifies the type of the background job.
       * @example update_emergency_settings
       * @enum {string}
       */
      readonly type?:
        | 'update_emergency_settings'
        | 'delete_phone_numbers'
        | 'update_phone_numbers';
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the estimated time of completion of the background job.
       */
      readonly etc?: string;
      /** @description ISO 8601 formatted date indicating when the resource was created. */
      readonly created_at?: string;
      /** @description ISO 8601 formatted date indicating when the resource was updated. */
      readonly updated_at?: string;
      phone_numbers?: components['schemas']['PhoneNumbersJobPhoneNumber'][];
      readonly successful_operations?: components['schemas']['PhoneNumbersJobSuccessfulOperation'][];
      readonly pending_operations?: components['schemas']['PhoneNumbersJobPendingOperation'][];
      readonly failed_operations?: components['schemas']['PhoneNumbersJobFailedOperation'][];
    };
    /** @example {
     *       "phone_numbers": [
     *         "+19705555098",
     *         "+19715555098",
     *         "32873127836"
     *       ]
     *     } */
    PhoneNumbersJobDeletePhoneNumbersRequest: {
      phone_numbers: string[];
    };
    PhoneNumbersJobFailedOperation: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       */
      phone_number?: string;
      /**
       * Format: int64
       * @description The phone number's ID
       */
      id?: string;
      errors?: components['schemas']['Error'][];
    };
    PhoneNumbersJobPendingOperation: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       */
      phone_number?: string;
      /**
       * Format: int64
       * @description The phone number's ID
       */
      id?: string;
    };
    PhoneNumbersJobPhoneNumber: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       * @example +19705555000
       */
      phone_number?: string;
      /**
       * Format: int64
       * @description The phone number's ID
       */
      id?: string;
    };
    PhoneNumbersJobSuccessfulOperation: {
      /**
       * Format: e164
       * @description The phone number in e164 format.
       */
      phone_number?: string;
      /**
       * Format: int64
       * @description The phone number's ID
       */
      id?: string;
    };
    /** @example {
     *       "emergency_enabled": true,
     *       "emergency_address_id": "53829456729313",
     *       "phone_numbers": [
     *         "+19705555098",
     *         "+19715555098",
     *         "32873127836"
     *       ]
     *     } */
    PhoneNumbersJobUpdateEmergencySettingsRequest: {
      phone_numbers: string[];
      /** @description Indicates whether to enable emergency services on this number. */
      emergency_enabled: boolean;
      /**
       * Format: int64
       * @description Identifies the address to be used with emergency services.
       */
      emergency_address_id: string;
    };
    /** @example {
     *       "phone_numbers": [
     *         "1583466971586889004",
     *         "+13127367254"
     *       ],
     *       "tags": [
     *         "tag"
     *       ],
     *       "external_pin": "123456",
     *       "customer_reference": "customer-reference",
     *       "connection_id": "dc8e4d67-33a0-4cbb-af74-7b58f05bd494",
     *       "billing_group_id": "dc8e4d67-33a0-4cbb-af74-7b58f05bd494",
     *       "voice": {
     *         "call_forwarding": {
     *           "call_forwarding_enabled": true,
     *           "forwards_to": "+13035559123",
     *           "forwarding_type": "always"
     *         }
     *       }
     *     } */
    PhoneNumbersJobUpdatePhoneNumbersRequest: {
      /** @description Array of phone number ids and/or phone numbers in E164 format to update */
      phone_numbers: string[];
      /** @description A list of user-assigned tags to help organize phone numbers. */
      tags?: string[];
      /** @description If someone attempts to port your phone number away from Telnyx and your phone number has an external PIN set, we will attempt to verify that you provided the correct external PIN to the winning carrier. Note that not all carriers cooperate with this security mechanism. */
      external_pin?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @description Identifies the connection associated with the phone number. */
      connection_id?: string;
      /** @description Identifies the billing group associated with the phone number. */
      billing_group_id?: string;
      voice?: components['schemas']['UpdatePhoneNumberVoiceSettingsRequest'];
    };
    /**
     * Play Audio URL Request
     * @example {
     *       "audio_url": "http://www.example.com/sounds/greeting.wav",
     *       "loop": "infinity",
     *       "overlay": true,
     *       "stop": "current",
     *       "target_legs": "self",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    PlayAudioUrlRequest: {
      /**
       * @description The URL of a file to be played back on the call. The URL can point to either a WAV or MP3 file. media_name and audio_url cannot be used together in one request.
       * @example http://example.com/message.wav
       */
      audio_url?: string;
      /**
       * @description The media_name of a file to be played back on the call. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      media_name?: string;
      /**
       * @description The number of times the audio file should be played. If supplied, the value must be an integer between 1 and 100, or the special string `infinity` for an endless loop.
       * @default 1
       * @example infinity
       */
      loop: components['schemas']['Loopcount'];
      /**
       * @description When enabled, audio will be mixed on top of any other audio that is actively being played back. Note that `overlay: true` will only work if there is another audio file already being played on the call.
       * @default false
       * @example true
       */
      overlay: boolean;
      /**
       * @description When specified, it stops the current audio being played. Specify `current` to stop the current audio being played, and to play the next file in the queue. Specify `all` to stop the current audio file being played and to also clear all audio files from the queue.
       * @example current
       */
      stop?: string;
      /**
       * @description Specifies the leg or legs on which audio will be played. If supplied, the value must be either `self`, `opposite` or `both`.
       * @default self
       * @example self
       */
      target_legs: string;
      /**
       * @description Caches the audio file. Useful when playing the same audio file multiple times during the call.
       * @default true
       * @example true
       */
      cache_audio: boolean;
      /**
       * @description Specifies the type of audio provided in `audio_url` or `playback_content`.
       * @default mp3
       * @example wav
       * @enum {string}
       */
      audio_type: 'mp3' | 'wav';
      /**
       * @description Allows a user to provide base64 encoded mp3 or wav. Note: when using this parameter, `media_url` and `media_name` in the `playback_started` and `playback_ended` webhooks will be empty
       * @example SUQzAwAAAAADf1...
       */
      playback_content?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * @description Whether to play a beep when recording is started.
     * @default true
     * @example false
     */
    PlayBeep: boolean;
    /**
     * Playback Stop Request
     * @example {
     *       "overlay": false,
     *       "stop": "all",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    PlaybackStopRequest: {
      /**
       * @description When enabled, it stops the audio being played in the overlay queue.
       * @default false
       * @example true
       */
      overlay: boolean;
      /**
       * @description Use `current` to stop the current audio being played. Use `all` to stop the current audio file being played and clear all audio files from the queue.
       * @default all
       * @example current
       */
      stop: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** @example {
     *       "id": "5a16902a-2ee9-4882-a247-420fc6627b62",
     *       "record_type": "supporting_document",
     *       "type": "loa",
     *       "portout_id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "document_id": "f1c5e079-9d82-4f50-95bc-ae2f6b8d84d7",
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     } */
    PortOutSupportingDocument: {
      /**
       * Format: uuid
       * @example 5a16902a-2ee9-4882-a247-420fc6627b62
       */
      id: string;
      /**
       * @description Identifies the type of the resource.
       * @example supporting_document
       */
      readonly record_type: string;
      /**
       * @description Identifies the type of the document
       * @example loa
       * @enum {string}
       */
      readonly type: 'loa' | 'invoice';
      /**
       * Format: uuid
       * @description Identifies the associated port request
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      readonly portout_id: string;
      /**
       * Format: uuid
       * @description Identifies the associated document
       * @example f1c5e079-9d82-4f50-95bc-ae2f6b8d84d7
       */
      document_id: string;
      /**
       * @description Supporting document creation timestamp in ISO 8601 format
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at: string;
      /**
       * @description Supporting document last changed timestamp in ISO 8601 format
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at: string;
    };
    Portability: {
      /**
       * @description Local Routing Number, if assigned to the requested phone number
       * @example 2245701999
       */
      lrn?: string;
      /**
       * @description Indicates whether or not the requested phone number has been ported
       * @example Y
       * @enum {string}
       */
      ported_status?: 'Y' | 'N' | '';
      /**
       * @description ISO-formatted date when the requested phone number has been ported
       * @example 2017-10-20
       */
      ported_date?: string;
      /**
       * @description Operating Company Name (OCN) as per the Local Exchange Routing Guide (LERG) database
       * @example 073H
       */
      ocn?: string;
      /**
       * @description Type of number
       * @example voip
       */
      line_type?: string;
      /**
       * @description SPID (Service Provider ID)
       * @example 073H
       */
      spid?: string;
      /**
       * @description Service provider name
       * @example Telnyx/4
       */
      spid_carrier_name?: string;
      /**
       * @description Service provider type
       * @example 3
       */
      spid_carrier_type?: string;
      /**
       * @description Alternative SPID (Service Provider ID). Often used when a carrier is using a number from another carrier
       * @example 073H
       */
      altspid?: string;
      /**
       * @description Alternative service provider name
       * @example Telnyx/4
       */
      altspid_carrier_name?: string;
      /**
       * @description Alternative service provider type
       * @example 3
       */
      altspid_carrier_type?: string;
      /**
       * @description City name extracted from the locality in the Local Exchange Routing Guide (LERG) database
       * @example WAUKEGAN
       */
      city?: string;
      /** @example Illinois */
      state?: string;
    };
    PortabilityCheckDetails: {
      /**
       * @description Identifies the type of the resource.
       * @example portability_check_result
       */
      readonly record_type?: string;
      /**
       * @description Indicates whether this phone number is FastPort eligible
       * @example true
       */
      readonly fast_portable?: boolean;
      /**
       * @description If this phone number is not portable, explains why. Empty string if the number is portable.
       * @example No coverage
       */
      readonly not_portable_reason?: string;
      /**
       * @description The +E.164 formatted phone number this result is about
       * @example +13125550123
       */
      readonly phone_number?: string;
      /**
       * @description Indicates whether this phone number is portable
       * @example true
       */
      readonly portable?: boolean;
    };
    /**
     * @description Specifies whether Telnyx is able to confirm portability this number in the United States & Canada. International phone numbers are provisional by default.
     * @example confirmed
     * @enum {string}
     */
    PortabilityStatus: 'pending' | 'confirmed' | 'provisional';
    PortingAdditionalDocument: {
      /**
       * Format: uuid
       * @description Uniquely identifies this additional document
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * @description Identifies the type of additional document
       * @example loa
       * @enum {string}
       */
      document_type?: 'loa' | 'invoice' | 'csr' | 'other';
      /**
       * Format: uuid
       * @description Identifies the associated document
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      document_id?: string;
      /**
       * @description The filename of the related document.
       * @example file.txt
       */
      filename?: string;
      /**
       * @description The content type of the related document.
       * @example text/plain
       */
      content_type?: string;
      /**
       * Format: uuid
       * @description Identifies the associated porting order
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      porting_order_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_additional_document
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PortingEvent: {
      /**
       * Format: uuid
       * @description Uniquely identifies the event.
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * @description Identifies the event type
       * @example porting_order.deleted
       * @enum {string}
       */
      event_type?:
        | 'porting_order.deleted'
        | 'porting_order.loa_updated'
        | 'porting_order.messaging_changed'
        | 'porting_order.status_changed'
        | 'porting_order.sharing_token_expired'
        | 'porting_order.new_comment'
        | 'porting_order.split';
      /**
       * Format: uuid
       * @description Identifies the porting order associated with the event.
       * @example 9471c873-e3eb-4ca1-957d-f9a451334d52
       */
      porting_order_id?: string;
      /** @description Indicates the notification methods used. */
      available_notification_methods?: ('email' | 'webhook' | 'webhook_v1')[];
      /**
       * @description The status of the payload generation.
       * @example created
       * @enum {string}
       */
      payload_status?: 'created' | 'completed';
      payload?:
        | components['schemas']['WebhookPortingOrderDeletedPayload']
        | components['schemas']['WebhookPortingOrderMessagingChangedPayload']
        | components['schemas']['WebhookPortingOrderStatusChangedPayload']
        | components['schemas']['WebhookPortingOrderNewCommentPayload']
        | components['schemas']['WebhookPortingOrderSplitPayload'];
      /**
       * @description Identifies the type of the resource.
       * @example porting_event
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PortingLOAConfiguration: {
      /**
       * Format: uuid
       * @description Uniquely identifies the LOA configuration.
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * @description The name of the company
       * @example Telnyx
       */
      company_name?: string;
      /**
       * @description The organization that owns the LOA configuration
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      organization_id?: string;
      /**
       * @description The name of the LOA configuration
       * @example My LOA Configuration
       */
      name?: string;
      /** @description The logo to be used in the LOA. */
      logo?: {
        /**
         * Format: uuid
         * @description Identifies the document that contains the logo.
         * @example f1486bae-f067-460c-ad43-73a92848f902
         */
        document_id?: string;
        /**
         * @description The content type of the logo.
         * @example image/png
         * @enum {string}
         */
        content_type?: 'image/png';
      };
      /** @description The address of the company. */
      address?: {
        /**
         * @description The street address of the company
         * @example 311 W. Superior St
         */
        street_address?: string;
        /**
         * @description The extended address of the company
         * @example Suite 504
         */
        extended_address?: string;
        /**
         * @description The locality of the company
         * @example Chicago
         */
        city?: string;
        /**
         * @description The administrative area of the company
         * @example IL
         */
        state?: string;
        /**
         * @description The postal code of the company
         * @example 60654
         */
        zip_code?: string;
        /**
         * @description The country code of the company
         * @example US
         */
        country_code?: string;
      };
      /** @description The contact information of the company. */
      contact?: {
        /**
         * Format: email
         * @description The email address of the contact
         * @example testing@telnyx.com
         */
        email?: string;
        /**
         * @description The phone number of the contact
         * @example +12003270001
         */
        phone_number?: string;
      };
      /**
       * @description Identifies the type of the resource.
       * @example porting_loa_configuration
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PortingOrder: {
      /**
       * Format: uuid
       * @description Uniquely identifies this porting order
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      readonly id?: string;
      /**
       * @description A customer-specified reference number for customer bookkeeping purposes
       * @example Acct 123abc
       */
      customer_reference?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly updated_at?: string;
      status?: components['schemas']['PortingOrderStatus'];
      /**
       * @description A key to reference this porting order when contacting Telnyx customer support. This information is not available in draft porting orders.
       * @example sr_123abc
       */
      readonly support_key?: string;
      /**
       * @description A key to reference for the porting order group when contacting Telnyx customer support. This information is not available for porting orders in `draft` state
       * @example pr_123abc
       */
      readonly parent_support_key?: string;
      /**
       * @description Count of phone numbers associated with this porting order
       * @example 1
       */
      readonly porting_phone_numbers_count?: number;
      /**
       * @description Identifies the old service provider
       * @example Unreal Communications
       */
      readonly old_service_provider_ocn?: string;
      documents?: components['schemas']['PortingOrderDocuments'];
      misc?: components['schemas']['PortingOrderMisc'];
      end_user?: components['schemas']['PortingOrderEndUser'];
      activation_settings?: components['schemas']['PortingOrderActivationSettings'];
      phone_number_configuration?: components['schemas']['PortingOrderPhoneNumberConfiguration'];
      /**
       * @description The type of the phone number
       * @example local
       * @enum {string}
       */
      phone_number_type?:
        | 'landline'
        | 'local'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'toll_free';
      /**
       * @description A description of the porting order
       * @example FP Telnyx
       */
      readonly description?: string;
      /** @description List of documentation requirements for porting numbers. Can be set directly or via the `requirement_group_id` parameter. */
      requirements?: components['schemas']['PortingOrderRequirement'][];
      /**
       * @description Is true when the required documentation is met
       * @example false
       */
      requirements_met?: boolean;
      user_feedback?: components['schemas']['PortingOrderUserFeedback'];
      /**
       * Format: uuid
       * @description Identifies the user (or organization) who requested the porting order
       * @example 40d68ba2-0847-4df2-be9c-b0e0cb673e75
       */
      user_id?: string;
      /**
       * Format: uri
       * @example https://example.com/porting_webhooks
       */
      webhook_url?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_order
       */
      readonly record_type?: string;
      messaging?: components['schemas']['PortingOrderMessaging'];
    };
    PortingOrderActivationSettings: {
      /**
       * Format: date-time
       * @description ISO 8601 formatted Date/Time requested for the FOC date
       * @example 2021-03-19T10:07:15.527Z
       */
      foc_datetime_requested?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted Date/Time of the FOC date
       * @example 2021-03-19T10:07:15.527Z
       */
      foc_datetime_actual?: string;
      /**
       * @description Indicates whether this porting order is eligible for FastPort
       * @example true
       */
      readonly fast_port_eligible?: boolean;
      activation_status?: components['schemas']['PortingOrderActivationStatus'];
    };
    /**
     * @description Activation status
     * @example Active
     * @enum {string}
     */
    PortingOrderActivationStatus:
      | 'New'
      | 'Pending'
      | 'Conflict'
      | 'Cancel Pending'
      | 'Failed'
      | 'Concurred'
      | 'Activate RDY'
      | 'Disconnect Pending'
      | 'Concurrence Sent'
      | 'Old'
      | 'Sending'
      | 'Active'
      | 'Cancelled';
    /** @description Can be specified directly or via the `requirement_group_id` parameter. */
    PortingOrderDocuments: {
      /**
       * Format: uuid
       * @description Returned ID of the submitted LOA via the Documents endpoint
       * @example 64ffb720-04c7-455b-92d6-20fcca92e935
       */
      loa?: string;
      /**
       * Format: uuid
       * @description Returned ID of the submitted Invoice via the Documents endpoint
       * @example ce74b771-d23d-4960-81ec-8741b3862146
       */
      invoice?: string;
    };
    PortingOrderEndUser: {
      admin?: components['schemas']['PortingOrderEndUserAdmin'];
      location?: components['schemas']['PortingOrderEndUserLocation'];
    };
    PortingOrderEndUserAdmin: {
      /**
       * @description Person Name or Company name requesting the port
       * @example Porter McPortersen
       */
      entity_name?: string;
      /**
       * @description Name of person authorizing the porting order
       * @example Porter McPortersen II
       */
      auth_person_name?: string;
      /**
       * @description Billing phone number associated with these phone numbers
       * @example 13035551234
       */
      billing_phone_number?: string;
      /**
       * @description The authorized person's account number with the current service provider
       * @example 123abc
       */
      account_number?: string;
      /**
       * @description European tax identification number. Applicable only in the European Union
       * @example 1234abcd
       */
      tax_identifier?: string;
      /**
       * @description PIN/passcode possibly required by the old service provider for extra verification
       * @example 1234
       */
      pin_passcode?: string;
      /**
       * @description European business identification number. Applicable only in the European Union
       * @example abc123
       */
      business_identifier?: string;
    };
    PortingOrderEndUserLocation: {
      /**
       * @description First line of billing address
       * @example 311 W. Superior St
       */
      street_address?: string;
      /**
       * @description Second line of billing address
       * @example Suite 504
       */
      extended_address?: string;
      /**
       * @description City or municipality of billing address
       * @example Chicago
       */
      locality?: string;
      /**
       * @description State, province, or similar of billing address
       * @example IL
       */
      administrative_area?: string;
      /**
       * @description Postal Code of billing address
       * @example 60654
       */
      postal_code?: string;
      /**
       * @description ISO3166-1 alpha-2 country code of billing address
       * @example US
       */
      country_code?: string;
    };
    /** @description Information about messaging porting process. */
    PortingOrderMessaging: {
      /**
       * @description Indicates whether the porting order can also port messaging capabilities.
       * @example true
       */
      messaging_capable?: boolean;
      /**
       * @description Indicates whether Telnyx will port messaging capabilities from the losing carrier. If false, any messaging capabilities will stay with their current provider.
       * @example true
       */
      enable_messaging?: boolean;
      /**
       * @description The current status of the messaging porting.
       * @example pending
       * @enum {string}
       */
      messaging_port_status?:
        | 'not_applicable'
        | 'pending'
        | 'activating'
        | 'exception'
        | 'canceled'
        | 'partial_port_complete'
        | 'ported';
      /**
       * @description Indicates whether the messaging porting has been completed.
       * @example false
       */
      messaging_port_completed?: boolean;
    };
    PortingOrderMisc: {
      type?: components['schemas']['PortingOrderType'];
      /**
       * @description Remaining numbers can be either kept with their current service provider or disconnected. 'new_billing_telephone_number' is required when 'remaining_numbers_action' is 'keep'.
       * @example disconnect
       * @enum {string}
       */
      remaining_numbers_action?: 'keep' | 'disconnect';
      /** @description New billing phone number for the remaining numbers. Used in case the current billing phone number is being ported to Telnyx. This will be set on your account with your current service provider and should be one of the numbers remaining on that account. */
      new_billing_phone_number?: string;
    };
    PortingOrderPhoneNumberConfiguration: {
      /**
       * @description identifies the billing group to set on the numbers when ported
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      billing_group_id?: string;
      /**
       * @description identifies the connection to set on the numbers when ported
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      connection_id?: string;
      /**
       * @description identifies the messaging profile to set on the numbers when ported
       * @example f1486bae-f067-460c-ad43-73a92848f901
       */
      messaging_profile_id?: string;
      /**
       * @description identifies the emergency address to set on the numbers when ported
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      emergency_address_id?: string;
      /** @example [
       *       "abc",
       *       "123"
       *     ] */
      tags?: string[];
    };
    PortingOrderRequirement: {
      /**
       * @description Type of value expected on field_value field
       * @example document
       * @enum {string}
       */
      field_type?: 'document';
      /**
       * @description identifies the document that satisfies this requirement
       * @example 9787fb5f-cbe5-4de4-b765-3303774ee9fe
       */
      field_value?: string;
      /**
       * @description Identifies the requirement type that meets this requirement
       * @example 59b0762a-b274-4f76-ac32-4d5cf0272e66
       */
      requirement_type_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_requirement
       */
      record_type?: string;
    };
    PortingOrderRequirementDetail: {
      /**
       * @description Type of value expected on field_value field
       * @example document
       * @enum {string}
       */
      field_type?: 'document' | 'textual';
      /**
       * @description Identifies the document that satisfies this requirement
       * @example 9787fb5f-cbe5-4de4-b765-3303774ee9fe
       */
      field_value?: string;
      /** @description Identifies the requirement type that meets this requirement */
      requirement_type?: {
        /**
         * @description The acceptance criteria for the requirement type
         * @example {
         *       "acceptable_values": []
         *     }
         */
        acceptance_criteria?: Record<string, never>;
        /**
         * @description A description of the requirement type
         * @example A copy of the latest phone bill from the current provider
         */
        description?: string;
        /**
         * @description An example of the requirement type
         * @example Most recent phone bill
         */
        example?: string;
        /**
         * @description Identifies the requirement type
         * @example 53970723-fbff-4f46-a975-f62be6c1a585
         */
        id?: string;
        /**
         * @description The name of the requirement type
         * @example Latest Invoice
         */
        name?: string;
        /**
         * @description The type of the requirement type
         * @example document
         */
        type?: string;
      };
      /**
       * @description Status of the requirement
       * @example approved
       */
      requirement_status?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_requirement
       */
      record_type?: string;
    };
    PortingOrderSharingToken: {
      /**
       * Format: uuid
       * @description Uniquely identifies this sharing token
       * @example 0a4b78a0-d416-4761-94f7-46c72ec56547
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identifies the porting order resource being shared
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      porting_order_id?: string;
      /**
       * @description The number of seconds until the sharing token expires
       * @example 3600
       */
      expires_in_seconds?: number;
      /**
       * @description The permissions granted to the sharing token
       * @example [
       *       "porting_order.document.read",
       *       "porting_order.document.update"
       *     ]
       */
      permissions?: (
        | 'porting_order.document.read'
        | 'porting_order.document.update'
      )[];
      /**
       * @description A signed JWT token that can be used to access the shared resource
       * @example eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE2ODk4OTQ2NzcsImlzdCI6MTY4OTg5MTA3NywicGVybWlzc2lvbnMiOlsicG9ydGluZ19vcmRlci5kb2N1bWVudC5yZWFkIl0sInBvcnRpbmdfb3JkZXJfaWQiOiJmZDRiODZjOC00OTdkLTRjNmQtOTYwOS1hNzg5ZTRlMTRjZmUifQ.CT0HRF6OLj7VPZ8p5Y_0S8rOL8SEUznwJJkR-YReKwc
       */
      token?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the sharing token expires.
       * @example 2021-03-19T10:07:15.527000Z
       */
      expires_at?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_order_sharing_token
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
    };
    /** @description Porting order status */
    PortingOrderStatus: {
      /** @description A list of 0 or more details about this porting order's status */
      details?: components['schemas']['PortingOrdersExceptionType'][];
      /**
       * @description The current status of the porting order
       * @example ported
       * @enum {string}
       */
      value?:
        | 'draft'
        | 'in-process'
        | 'submitted'
        | 'exception'
        | 'foc-date-confirmed'
        | 'ported'
        | 'cancelled'
        | 'cancel-pending';
    };
    /**
     * @description A port can be either 'full' or 'partial'. When type is 'full' the other attributes should be omitted.
     * @example full
     * @enum {string}
     */
    PortingOrderType: 'full' | 'partial';
    PortingOrderUserFeedback: {
      /**
       * @description Once an order is ported, cancellation is requested or the request is cancelled, the user may rate their experience
       * @example 5
       */
      user_rating?: number;
      /**
       * @description A comment related to the customer rating.
       * @example I loved my experience porting numbers with Telnyx
       */
      user_comment?: string;
    };
    PortingOrdersActivationJob: {
      /**
       * Format: uuid
       * @description Uniquely identifies this activation job
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      readonly id?: string;
      /**
       * @description Specifies the status of this activation job
       * @enum {string}
       */
      status?: 'created' | 'in-process' | 'completed' | 'failed';
      /**
       * @description Specifies the type of this activation job
       * @enum {string}
       */
      activation_type?: 'scheduled' | 'on-demand';
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the activation job should be executed. This time should be between some activation window.
       * @example 2021-03-19T10:07:15.527Z
       */
      activate_at?: string;
      /** @description List of allowed activation windows for this activation job */
      activation_windows?: {
        /**
         * Format: date-time
         * @description ISO 8601 formatted date indicating when the activation window starts
         * @example 2021-03-19T10:07:15.527Z
         */
        start_at?: string;
        /**
         * Format: date-time
         * @description ISO 8601 formatted date indicating when the activation window ends
         * @example 2021-03-19T10:07:15.527Z
         */
        end_at?: string;
      }[];
      /**
       * @description Identifies the type of the resource.
       * @example porting_activation_job
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    /** PortingOrdersAllowedFocWindow */
    PortingOrdersAllowedFocWindow: {
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating the start of the range of foc window.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly started_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating the end of the range of foc window
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly ended_at?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_order
       */
      readonly record_type?: string;
    };
    PortingOrdersComment: {
      /**
       * Format: uuid
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      id?: string;
      /**
       * @description Body of comment
       * @example Great experience so far
       */
      body?: string;
      /**
       * Format: uuid
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      porting_order_id?: string;
      /**
       * @description Indicates whether this comment was created by a Telnyx Admin, user, or system
       * @example user
       * @enum {string}
       */
      user_type?: 'admin' | 'user' | 'system';
      /**
       * @description Identifies the type of the resource.
       * @example porting_comment
       */
      record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      created_at?: string;
    };
    PortingOrdersExceptionType: {
      /**
       * @description Identifier of an exception type
       * @example ENTITY_NAME_MISMATCH
       * @enum {string}
       */
      code?:
        | 'ACCOUNT_NUMBER_MISMATCH'
        | 'AUTH_PERSON_MISMATCH'
        | 'BTN_ATN_MISMATCH'
        | 'ENTITY_NAME_MISMATCH'
        | 'FOC_EXPIRED'
        | 'FOC_REJECTED'
        | 'LOCATION_MISMATCH'
        | 'LSR_PENDING'
        | 'MAIN_BTN_PORTING'
        | 'OSP_IRRESPONSIVE'
        | 'OTHER'
        | 'PASSCODE_PIN_INVALID'
        | 'PHONE_NUMBER_HAS_SPECIAL_FEATURE'
        | 'PHONE_NUMBER_MISMATCH'
        | 'PHONE_NUMBER_NOT_PORTABLE'
        | 'PORT_TYPE_INCORRECT'
        | 'PORTING_ORDER_SPLIT_REQUIRED'
        | 'POSTAL_CODE_MISMATCH'
        | 'RATE_CENTER_NOT_PORTABLE'
        | 'SV_CONFLICT'
        | 'SV_UNKNOWN_FAILURE';
      /**
       * @description Description of an exception type
       * @example Entity name does not match that on the CSR
       */
      description?: string;
    };
    PortingPhoneNumber: {
      /**
       * @description The current status of the porting order
       * @example in-process
       * @enum {string}
       */
      porting_order_status?:
        | 'draft'
        | 'in-process'
        | 'submitted'
        | 'exception'
        | 'foc-date-confirmed'
        | 'cancel-pending'
        | 'ported'
        | 'cancelled';
      /**
       * @description The type of the phone number
       * @example local
       * @enum {string}
       */
      phone_number_type?:
        | 'landline'
        | 'local'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'toll_free';
      /**
       * @description E164 formatted phone number
       * @example 13035550987
       */
      phone_number?: string;
      /**
       * Format: uuid
       * @description Identifies the associated port request
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      porting_order_id?: string;
      /**
       * @description A key to reference this porting order when contacting Telnyx customer support
       * @example sr_a12345
       */
      support_key?: string;
      activation_status?: components['schemas']['PortingOrderActivationStatus'];
      portability_status?: components['schemas']['PortabilityStatus'];
      /**
       * @description The current status of the requirements in a INTL porting order
       * @example approved
       * @enum {string}
       */
      requirements_status?:
        | 'requirement-info-pending'
        | 'requirement-info-under-review'
        | 'requirement-info-exception'
        | 'approved';
      /**
       * @description Identifies the type of the resource.
       * @example porting_phone_number
       */
      readonly record_type?: string;
    };
    PortingPhoneNumberBlock: {
      /**
       * Format: uuid
       * @description Uniquely identifies this porting phone number block.
       * @example f24151b6-3389-41d3-8747-7dd8c681e5e2
       */
      readonly id?: string;
      /**
       * @description Specifies the country code for this porting phone number block. It is a two-letter ISO 3166-1 alpha-2 country code.
       * @example DE
       */
      country_code?: string;
      /**
       * @description Specifies the phone number type for this porting phone number block.
       * @example local
       * @enum {string}
       */
      phone_number_type?:
        | 'landline'
        | 'local'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'toll_free';
      /** @description Specifies the phone number range for this porting phone number block. */
      phone_number_range?: {
        /**
         * @description Specifies the start of the phone number range for this porting phone number block.
         * @example +4930244999901
         */
        start_at?: string;
        /**
         * @description Specifies the end of the phone number range for this porting phone number block.
         * @example +4930244999910
         */
        end_at?: string;
      };
      /** @description Specifies the activation ranges for this porting phone number block. The activation range must be within the phone number range and should not overlap with other activation ranges. */
      activation_ranges?: {
        /**
         * @description Specifies the start of the activation range. Must be greater or equal the start of the phone number range.
         * @example +4930244999901
         */
        start_at?: string;
        /**
         * @description Specifies the end of the activation range. It must be no more than the end of the phone number range.
         * @example +4930244999910
         */
        end_at?: string;
      }[];
      /**
       * @description Identifies the type of the resource.
       * @example porting_phone_number_block
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was last updated.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    PortingPhoneNumberConfiguration: {
      /**
       * Format: uuid
       * @description Uniquely identifies this phone number configuration
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identifies the associated user bundle
       * @example daa4308e-742f-4867-97f2-3073db13319a
       */
      user_bundle_id?: string;
      /**
       * Format: uuid
       * @description Identifies the associated porting phone number
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      porting_phone_number_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_phone_number_configuration
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PortingPhoneNumberExtension: {
      /**
       * Format: uuid
       * @description Uniquely identifies this porting phone number extension.
       * @example f24151b6-3389-41d3-8747-7dd8c681e5e2
       */
      readonly id?: string;
      /**
       * Format: uuid
       * @description Identifies the porting phone number associated with this porting phone number extension.
       * @example f24151b6-3389-41d3-8747-7dd8c681e5e2
       */
      porting_phone_number_id?: string;
      /** @description Specifies the extension range for this porting phone number extension. */
      extension_range?: {
        /**
         * @description Specifies the start of the extension range for this porting phone number extension.
         * @example 1
         */
        start_at?: number;
        /**
         * @description Specifies the end of the extension range for this porting phone number extension.
         * @example 10
         */
        end_at?: number;
      };
      /** @description Specifies the activation ranges for this porting phone number extension. The activation range must be within the extension range and should not overlap with other activation ranges. */
      activation_ranges?: {
        /**
         * @description Specifies the start of the activation range. Must be greater or equal the start of the extension range.
         * @example 1
         */
        start_at?: number;
        /**
         * @description Specifies the end of the activation range. It must be no more than the end of the extension range.
         * @example 10
         */
        end_at?: number;
      }[];
      /**
       * @description Identifies the type of the resource.
       * @example porting_phone_number_extension
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was last updated.
       * @example 2021-03-19T10:07:15.527Z
       */
      readonly updated_at?: string;
    };
    PortingReport: {
      /**
       * Format: uuid
       * @description Uniquely identifies the report.
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * @description Identifies the type of report
       * @example export_porting_orders_csv
       * @enum {string}
       */
      report_type?: 'export_porting_orders_csv';
      /**
       * @description The current status of the report generation.
       * @example completed
       * @enum {string}
       */
      status?: 'pending' | 'completed';
      params?: components['schemas']['ExportPortingOrdersCSVReport'];
      /**
       * Format: uuid
       * @description Identifies the document that was uploaded when report was generated. This field is only populated when the report is under completed status.
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      document_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_report
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PortingVerificationCode: {
      /**
       * Format: uuid
       * @description Uniquely identifies this porting verification code
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      id?: string;
      /**
       * @description E164 formatted phone number
       * @example +13035550987
       */
      phone_number?: string;
      /**
       * @description Indicates whether the verification code has been verified
       * @example true
       */
      verified?: boolean;
      /**
       * Format: uuid
       * @description Identifies the associated porting order
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      porting_order_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example porting_verification_code
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    /** @example {
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "record_type": "portout",
     *       "body": "This is a comment",
     *       "portout_id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "user_id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "created_at": "2018-02-02T22:25:27.521Z"
     *     } */
    PortoutComment: {
      /** @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0 */
      id: string;
      /**
       * @description Identifies the type of the resource.
       * @example portout
       */
      readonly record_type?: string;
      /**
       * @description Comment body
       * @example This is a comment
       */
      body: string;
      /**
       * @description Identifies the associated port request
       * @default null
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      portout_id: string;
      /**
       * @description Identifies the user who created the comment. Will be null if created by Telnyx Admin
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      user_id: string;
      /**
       * @description Comment creation timestamp in ISO 8601 format
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at: string;
    };
    PortoutDetails: {
      /** @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0 */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example portout
       */
      readonly record_type?: string;
      /**
       * @description Phone numbers associated with this portout
       * @example [
       *       "+35312345678"
       *     ]
       */
      phone_numbers?: string[];
      /**
       * @description Name of person authorizing the porting order
       * @example McPortersen
       */
      authorized_name?: string;
      /**
       * @description Carrier the number will be ported out to
       * @example test
       */
      carrier_name?: string;
      /**
       * @description The current carrier
       * @example telnyx
       */
      current_carrier?: string;
      /**
       * @description Person name or company name requesting the port
       * @example McPortersen
       */
      end_user_name?: string;
      /**
       * @description City or municipality of billing address
       * @example Chicago
       */
      city?: string;
      /**
       * @description State, province, or similar of billing address
       * @example IL
       */
      state?: string;
      /**
       * @description Postal Code of billing address
       * @example 00000
       */
      zip?: string;
      /**
       * @description The Local Service Request
       * @example [
       *       "https://example.com/files/lsr.pdf"
       *     ]
       */
      lsr?: string[];
      /**
       * @description Port order number assigned by the carrier the number will be ported out to
       * @example 00000000
       */
      pon?: string;
      /**
       * @description The reason why the order is being rejected by the user. If the order is authorized, this field can be left null
       * @example null
       */
      reason?: string;
      /**
       * @description First line of billing address (street address)
       * @example 000 Example Street
       */
      service_address?: string;
      /**
       * @description ISO 8601 formatted Date/Time of the FOC date
       * @example 2018-02-02T22:25:27.521Z
       */
      foc_date?: string;
      /**
       * @description ISO 8601 formatted Date/Time of the user requested FOC date
       * @example 2018-02-02T22:25:27.521Z
       */
      requested_foc_date?: string;
      /**
       * @description New service provider spid
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      spid?: string;
      /**
       * @description A key to reference this port out request when contacting Telnyx customer support
       * @example PO_764725
       */
      support_key?: string;
      /**
       * @description Status of portout request
       * @example rejected
       * @enum {string}
       */
      status?:
        | 'pending'
        | 'authorized'
        | 'ported'
        | 'rejected'
        | 'rejected-pending'
        | 'canceled';
      /**
       * @description Is true when the number is already ported
       * @example false
       */
      already_ported?: boolean;
      /**
       * Format: uuid
       * @description Identifies the user (or organization) who requested the port out
       * @example 7865816a-ee85-4e50-b19e-52983dcc6d4a
       */
      user_id?: string;
      /**
       * Format: uuid
       * @description Telnyx partner providing network coverage
       * @example 0e66ed3b-37e6-4fed-93d6-a30ce2493661
       */
      vendor?: string;
      /**
       * @description ISO 8601 formatted date of when the portout was created
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO 8601 formatted date of when the portout was created
       * @example 2018-02-02T22:25:27.521Z
       */
      inserted_at?: string;
      /**
       * @description ISO 8601 formatted date of when the portout was last updated
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    PortoutEvent: {
      /**
       * Format: uuid
       * @description Uniquely identifies the event.
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * @description Identifies the event type
       * @example portout.status_changed
       * @enum {string}
       */
      event_type?:
        | 'portout.status_changed'
        | 'portout.foc_date_changed'
        | 'portout.new_comment';
      /**
       * Format: uuid
       * @description Identifies the port-out order associated with the event.
       * @example 9471c873-e3eb-4ca1-957d-f9a451334d52
       */
      portout_id?: string;
      /** @description Indicates the notification methods used. */
      available_notification_methods?: ('email' | 'webhook')[];
      /**
       * @description The status of the payload generation.
       * @example created
       * @enum {string}
       */
      payload_status?: 'created' | 'completed';
      payload?:
        | components['schemas']['WebhookPortoutStatusChangedPayload']
        | components['schemas']['WebhookPortoutNewCommentPayload']
        | components['schemas']['WebhookPortoutFocDateChangedPayload'];
      /**
       * @description Identifies the type of the resource.
       * @example portout_event
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PortoutReport: {
      /**
       * Format: uuid
       * @description Uniquely identifies the report.
       * @example eef3340b-8903-4466-b445-89b697315a3a
       */
      id?: string;
      /**
       * @description Identifies the type of report
       * @example export_portouts_csv
       * @enum {string}
       */
      report_type?: 'export_portouts_csv';
      /**
       * @description The current status of the report generation.
       * @example completed
       * @enum {string}
       */
      status?: 'pending' | 'completed';
      params?: components['schemas']['ExportPortoutsCSVReport'];
      /**
       * Format: uuid
       * @description Identifies the document that was uploaded when report was generated. This field is only populated when the report is under completed status.
       * @example f1486bae-f067-460c-ad43-73a92848f902
       */
      document_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example portout_report
       */
      readonly record_type?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2021-03-19T10:07:15.527000Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2021-03-19T10:07:15.527000Z
       */
      updated_at?: string;
    };
    PresignedObjectUrl: {
      content?: {
        /** @description The token for the object */
        token?: string;
        /** @description The presigned URL for the object */
        presigned_url?: string;
        /**
         * Format: date-time
         * @description The expiration time of the token
         */
        expires_at?: string;
      };
    };
    PresignedObjectUrlParams: {
      /**
       * @description The time to live of the token in seconds
       * @example 60
       */
      ttl?: number;
    };
    PrivateWirelessGateway: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * Format: uuid
       * @description The identification of the related network resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      network_id?: string;
      /** @example private_wireless_gateway */
      readonly record_type?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
      /**
       * @description The private wireless gateway name.
       * @example My private wireless gateway
       */
      name?: string;
      /**
       * @description The geographical region where the Private Wireless Gateway is deployed to.
       * @default ashburn-va
       * @example ashburn-va
       */
      region_code: string;
      status?: components['schemas']['PrivateWirelessGatewayStatus'];
      /**
       * @description IP block used to assign IPs to the SIM cards in the Private Wireless Gateway.
       * @default null
       * @example 100.64.1.0/24
       */
      readonly ip_range: string;
      /** @description A list of the resources that have been assigned to the Private Wireless Gateway. */
      assigned_resources?: components['schemas']['PWGAssignedResourcesSummary'][];
    };
    /** @example {
     *       "network_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "name": "My private wireless gateway"
     *     } */
    PrivateWirelessGatewayRequest: {
      /**
       * Format: uuid
       * @description The identification of the related network resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      network_id?: string;
      /**
       * @description The private wireless gateway name.
       * @example My private wireless gateway
       */
      name?: string;
    };
    /** @description The current status or failure details of the Private Wireless Gateway. */
    PrivateWirelessGatewayStatus: {
      /**
       * @description The current status or failure details of the Private Wireless Gateway. <ul>
       *      <li><code>provisioning</code> - the Private Wireless Gateway is being provisioned.</li>
       *      <li><code>provisioned</code> - the Private Wireless Gateway was provisioned and able to receive connections.</li>
       *      <li><code>failed</code> - the provisioning had failed for a reason and it requires an intervention.</li>
       *      <li><code>decommissioning</code> - the Private Wireless Gateway is being removed from the network.</li>
       *      </ul>
       *      Transitioning between the provisioning and provisioned states may take some time.
       * @default provisioning
       * @example provisioned
       * @enum {string}
       */
      readonly value:
        | 'provisioning'
        | 'provisioned'
        | 'failed'
        | 'decommissioning';
      /**
       * @description This attribute provides a human-readable explanation of why a failure happened.
       * @default null
       * @example null
       */
      readonly error_description: string;
      /**
       * @description This attribute is an [error code](https://developers.telnyx.com/api/errors) related to the failure reason.
       * @default null
       * @example null
       */
      readonly error_code: string;
    };
    /** ProfileAssignmentPhoneNumbers */
    ProfileAssignmentPhoneNumbers: {
      /**
       * Taskid
       * @description The ID of the task associated with the phone number.
       * @example 667a80f8-b0a9-49d0-b9ab-a7a1bcc45086
       */
      taskId: string;
      /**
       * Phonenumber
       * @description The phone number that the status is being checked for.
       * @example +12024567890
       */
      phoneNumber: string;
      /**
       * Status
       * @description The status of the associated phone number assignment.
       * @example pending
       */
      status: string;
    };
    /** PublicCompany */
    PublicCompany: {
      /** Symbol */
      symbol?: string;
      exchange?: components['schemas']['Exchange'];
      /** Iso2 */
      iso2?: string;
      /** Isin */
      isin?: string;
      /** Displayname */
      displayName?: string;
    };
    /** PublicCompanyRecordSet */
    PublicCompanyRecordSet: {
      /** Records */
      records?: components['schemas']['PublicCompany'][];
      /** Page */
      page?: number;
      /** Totalrecords */
      totalRecords?: number;
    };
    PublicInternetGateway: components['schemas']['Record'] &
      components['schemas']['Interface'] & {
        /**
         * @description Identifies the type of the resource.
         * @example public_internet_gateway
         */
        readonly record_type?: string;
        /**
         * @description The publically accessible ip for this interface.
         * @example 127.0.0.1
         */
        readonly public_ip?: string;
      };
    PublicInternetGatewayCreate: components['schemas']['PublicInternetGateway'] &
      components['schemas']['RegionIn'] &
      Record<string, never>;
    PublicInternetGatewayRead: components['schemas']['PublicInternetGateway'] &
      components['schemas']['RegionOut'];
    /** Successful response with details about a push credential */
    PushCredential: {
      /**
       * @description Unique identifier of a push credential
       * @example 0ccc7b54-4df3-4bcb-a65a-3da1ecc997d7
       */
      id: string;
      /**
       * @description Apple certificate for sending push notifications. For iOS only
       * @example -----BEGIN CERTIFICATE----- MIIGVDCCBTKCAQEAsNlRJVZn9ZvXcECQm65czs... -----END CERTIFICATE-----
       */
      certificate: string;
      /**
       * @description Apple private key for a given certificate for sending push notifications. For iOS only
       * @example -----BEGIN RSA PRIVATE KEY----- MIIEpQIBAAKCAQEAsNlRJVZn9ZvXcECQm65czs... -----END RSA PRIVATE KEY-----
       */
      private_key: string;
      /**
       * @description Google server key for sending push notifications. For Android only
       * @example {
       *       "private_key": "BBBB0J56jd8kda:APA91vjb11BCjvxx3Jxja...",
       *       "client_email": "account@customer.org"
       *     }
       */
      project_account_json_file: Record<string, never>;
      /**
       * @description Alias to uniquely identify a credential
       * @example LucyCredential
       */
      alias: string;
      /**
       * @description Type of mobile push credential. Either <code>ios</code> or <code>android</code>
       * @example ios
       */
      type: string;
      /** @example push_credential */
      readonly record_type: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room was created
       * @example 2021-03-26T17:51:59.588408Z
       */
      created_at: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room was updated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      updated_at: string;
    };
    /**
     * @description The quality of the fax. The `ultra` settings provides the highest quality available, but also present longer fax processing times. `ultra_light` is best suited for images, wihle `ultra_dark` is best suited for text.
     * @default high
     * @example high
     * @enum {string}
     */
    Quality: 'normal' | 'high' | 'very_high' | 'ultra_light' | 'ultra_dark';
    /**
     * Queue
     * @example {
     *       "record_type": "queue",
     *       "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "name": "support",
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z",
     *       "current_size": 20,
     *       "max_size": 50,
     *       "average_wait_time_secs": 175
     *     }
     */
    Queue: {
      /**
       * @example queue
       * @enum {string}
       */
      record_type: 'queue';
      /**
       * @description Uniquely identifies the queue
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      id: string;
      /**
       * @description Name of the queue
       * @example support
       */
      name: string;
      /**
       * @description ISO 8601 formatted date of when the queue was created
       * @example 2019-01-23T18:10:02.574Z
       */
      created_at: string;
      /**
       * @description ISO 8601 formatted date of when the queue was last updated
       * @example 2019-01-23T18:10:02.574Z
       */
      updated_at: string;
      /**
       * @description The number of calls currently in the queue
       * @example 20
       */
      current_size: number;
      /**
       * @description The maximum number of calls allowed in the queue
       * @example 50
       */
      max_size: number;
      /**
       * @description The average time that the calls currently in the queue have spent waiting, given in seconds.
       * @example 175
       */
      average_wait_time_secs: number;
    };
    /**
     * QueueCall
     * @example {
     *       "call_control_id": "v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg",
     *       "call_leg_id": "2dc6fc34-f9e0-11ea-b68e-02420a0f7768",
     *       "call_session_id": "2dc1b3c8-f9e0-11ea-bc5a-02420a0f7768",
     *       "record_type": "queue_call",
     *       "connection_id": "7267xxxxxxxxxxxxxx",
     *       "from": "+18005550101",
     *       "to": "+18005550102",
     *       "enqueued_at": "2019-01-23T18:10:02.574Z",
     *       "wait_time_secs": 145,
     *       "queue_position": 3,
     *       "queue_id": "ae1626cc-6f42-11ea-becd-02420a0f8b69"
     *     }
     */
    QueueCall: {
      /**
       * @example queue_call
       * @enum {string}
       */
      record_type: 'queue_call';
      /**
       * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call
       * @example 428c31b6-7af4-4bcb-b68e-5013ef9657c1
       */
      call_session_id: string;
      /**
       * @description ID that is unique to the call and can be used to correlate webhook events
       * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
       */
      call_leg_id: string;
      /**
       * @description Unique identifier and token for controlling the call.
       * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
       */
      call_control_id: string;
      /**
       * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
       * @example 7267xxxxxxxxxxxxxx
       */
      connection_id: string;
      /**
       * @description Number or SIP URI placing the call.
       * @example +35319605860
       */
      from: string;
      /**
       * @description Destination number or SIP URI of the call.
       * @example +13129457420
       */
      to: string;
      /**
       * @description ISO 8601 formatted date of when the call was put in the queue
       * @example 2019-01-23T18:10:02.574Z
       */
      enqueued_at: string;
      /**
       * @description The time the call has been waiting in the queue, given in seconds
       * @example 272
       */
      wait_time_secs: number;
      /**
       * @description Current position of the call in the queue
       * @example 3
       */
      queue_position: number;
      /**
       * @description Unique identifier of the queue the call is in.
       * @example ae1626cc-6f42-11ea-becd-02420a0f8b69
       */
      queue_id: string;
    };
    ReadComment: components['schemas']['Comment'];
    Record: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example sample_record_type
       */
      readonly record_type?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** @description An object following one of the schemas published in https://developers.telnyx.com/docs/api/v2/detail-records */
    RecordType: {
      /**
       * @description Telnyx Product type
       * @example conversation_event
       */
      record_type?: string;
      /**
       * @description Telnyx Product Dimensions
       * @example ['direction', 'currency', 'message_type']
       */
      product_dimensions?: string[];
      /**
       * @description Telnyx Product Metrics
       * @example ['cost', 'billed_sec']
       */
      product_metrics?: string[];
    };
    /**
     * Recording Completed
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.recording.started",
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *         "room_id": "0ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "participant_id": "5ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "recording_id": "1ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "type": "audio",
     *         "download_url": "https://www.example.com",
     *         "duration_secs": 3660,
     *         "size_mb": 5.6,
     *         "codec": "opus"
     *       }
     *     }
     */
    RecordingCompleted: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.recording.completed
       * @enum {string}
       */
      event_type?: 'video.room.recording.completed';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Session ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: uuid
         * @description Room ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
        /**
         * Format: uuid
         * @description Participant ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        participant_id?: string;
        /**
         * Format: uuid
         * @description Recording ID that identifies the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        recording_id?: string;
        /**
         * @description Type of the recording.
         * @example audio
         * @enum {string}
         */
        type?: 'audio' | 'video';
        /**
         * Format: float
         * @description Recording size in MB.
         * @example 10.5
         */
        size_mb?: number;
        /**
         * @description Url to download the recording.
         * @example https://www.example.com
         */
        download_url?: string;
        /**
         * @description Codec used for the recording.
         * @example opus
         */
        codec?: string;
        /**
         * @description Recording duration in seconds.
         * @example 67
         */
        duration_secs?: number;
      };
    };
    /** Recording Completed Event */
    RecordingCompletedEvent: {
      data?: components['schemas']['RecordingCompleted'];
    };
    /** RecordingResponse */
    RecordingResponse: {
      data?: components['schemas']['RecordingResponseData'];
    };
    /** RecordingResponseData */
    RecordingResponseData: {
      /**
       * @description Unique identifier and token for controlling the call.
       * @example v3:e-31OnvjEM7Y4wvxr3TKNk8M3QyLcGZPiUIzCGtwQtOtEjY-B0urkw
       */
      call_control_id?: string;
      /**
       * @description ID that is unique to the call and can be used to correlate webhook events.
       * @example 84a97d76-e40f-11ed-9074-02420a0daa69
       */
      call_leg_id?: string;
      /**
       * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
       * @example 84a97d76-e40f-11ed-9074-02420a0daa69
       */
      call_session_id?: string;
      /**
       * @description When `dual`, final audio file has the first leg on channel A, and the rest on channel B.
       * @example dual
       * @enum {string}
       */
      channels?: 'single' | 'dual';
      /**
       * @description Uniquely identifies the conference.
       * @example 84a97d76-e40f-11ed-9074-02420a0daa69
       */
      conference_id?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /** @description The links to download the recording files. */
      download_urls?: {
        /** @description Link to download the recording in mp3 format. */
        mp3?: string;
        /** @description Link to download the recording in wav format. */
        wav?: string;
      };
      /**
       * Format: int32
       * @description The duration of the recording in milliseconds.
       * @example 60000
       */
      duration_millis?: number;
      /**
       * @description Uniquely identifies the recording.
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      id?: string;
      /**
       * @example recording
       * @enum {string}
       */
      record_type?: 'recording';
      /**
       * @description ISO 8601 formatted date of when the recording started.
       * @example 2019-01-23T18:10:02.574Z
       */
      recording_started_at?: string;
      /**
       * @description ISO 8601 formatted date of when the recording ended.
       * @example 2019-01-23T18:10:02.574Z
       */
      recording_ended_at?: string;
      /**
       * @description The kind of event that led to this recording being created.
       * @example conference
       * @enum {string}
       */
      source?: 'conference' | 'call';
      /**
       * @description The status of the recording. Only resources for `completed` recordings are currently supported.
       * @example completed
       * @enum {string}
       */
      status?: 'completed';
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /**
     * @description Defines how the recording was created.
     * @enum {string}
     */
    RecordingSource:
      | 'StartCallRecordingAPI'
      | 'StartConferenceRecordingAPI'
      | 'OutboundAPI'
      | 'DialVerb'
      | 'Conference'
      | 'RecordVerb'
      | 'Trunking';
    /**
     * Recording Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.recording.started",
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *         "room_id": "0ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "participant_id": "5ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "recording_id": "1ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "type": "audio"
     *       }
     *     }
     */
    RecordingStarted: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.recording.started
       * @enum {string}
       */
      event_type?: 'video.room.recording.started';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Session ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: uuid
         * @description Room ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
        /**
         * Format: uuid
         * @description Participant ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        participant_id?: string;
        /**
         * Format: uuid
         * @description Recording ID associated with the recording.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        recording_id?: string;
        /**
         * @description Type of the recording.
         * @example audio
         * @enum {string}
         */
        type?: 'audio' | 'video';
      };
    };
    /** Recording Started Event */
    RecordingStartedEvent: {
      data?: components['schemas']['RecordingStarted'];
    };
    /**
     * @description The changes to the recording's state that should generate a call to `RecoridngStatusCallback`. Can be: `in-progress`, `completed` and `absent`. Separate multiple values with a space. Defaults to `completed`.
     * @example in-progress completed absent
     */
    RecordingStatusCallbackEvent: string;
    /**
     * @description The audio track to record for the call. The default is `both`.
     * @example inbound
     * @enum {string}
     */
    RecordingTrack: 'inbound' | 'outbound' | 'both';
    /** RecordingTranscriptionsResponseData */
    RecordingTranscription: {
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * Format: int32
       * @description The duration of the recording transcription in milliseconds.
       * @example 60000
       */
      duration_millis?: number;
      /**
       * @description Uniquely identifies the recording transcription.
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      id?: string;
      /**
       * @description Uniquely identifies the recording associated with this transcription.
       * @example 3fa85f64-5717-4562-b3fc-2c963f66afa6
       */
      recording_id?: string;
      /**
       * @example recording_transcription
       * @enum {string}
       */
      record_type?: 'recording_transcription';
      /**
       * @description The status of the recording transcriptions. The transcription text will be available only when the status is completed.
       * @example completed
       * @enum {string}
       */
      status?: 'in-progress' | 'completed';
      /**
       * @description The recording's transcribed text
       * @example Good morning, how may I help you?
       */
      transcription_text?: string;
      /**
       * @description ISO 8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
    };
    /**
     * Refer request
     * @example {
     *       "sip_address": "sip:username@sip.non-telnyx-address.com"
     *     }
     */
    ReferRequest: {
      /**
       * @description The SIP URI to which the call will be referred to.
       * @example sip:username@sip.non-telnyx-address.com
       */
      sip_address: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid execution of duplicate commands. Telnyx will ignore subsequent commands with the same `command_id` as one that has already been executed.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Custom headers to be added to the SIP INVITE.
       * @example [
       *       {
       *         "name": "head_1",
       *         "value": "val_1"
       *       },
       *       {
       *         "name": "head_2",
       *         "value": "val_2"
       *       }
       *     ]
       */
      custom_headers?: components['schemas']['CustomSipHeader'][];
      /** @description SIP Authentication username used for SIP challenges. */
      sip_auth_username?: string;
      /** @description SIP Authentication password used for SIP challenges. */
      sip_auth_password?: string;
      /**
       * @description SIP headers to be added to the request. Currently only User-to-User header is supported.
       * @example [
       *       {
       *         "name": "User-to-User",
       *         "value": "value"
       *       }
       *     ]
       */
      sip_headers?: components['schemas']['SipHeader'][];
    };
    RefreshRoomClientTokenRequest: {
      /**
       * @description The time to live in seconds of the Client Token, after that time the Client Token is invalid and can't be used to join a Room.
       * @default 600
       * @example 600
       */
      token_ttl_secs: number;
      /**
       * Format: jwt
       * @example eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJ0ZWxueXhfdGVsZXBob255IiwiZXhwIjoxNTkwMDEwMTQzLCJpYXQiOjE1ODc1OTA5NDMsImlzcyI6InRlbG55eF90ZWxlcGhvbnkiLCJqdGkiOiJiOGM3NDgzNy1kODllLTRhNjUtOWNmMi0zNGM3YTZmYTYwYzgiLCJuYmYiOjE1ODc1OTA5NDIsInN1YiI6IjVjN2FjN2QwLWRiNjUtNGYxMS05OGUxLWVlYzBkMWQ1YzZhZSIsInRlbF90b2tlbiI6InJqX1pra1pVT1pNeFpPZk9tTHBFVUIzc2lVN3U2UmpaRmVNOXMtZ2JfeENSNTZXRktGQUppTXlGMlQ2Q0JSbWxoX1N5MGlfbGZ5VDlBSThzRWlmOE1USUlzenl6U2xfYURuRzQ4YU81MHlhSEd1UlNZYlViU1ltOVdJaVEwZz09IiwidHlwIjoiYWNjZXNzIn0.gNEwzTow5MLLPLQENytca7pUN79PmPj6FyqZWW06ZeEmesxYpwKh0xRtA0TzLh6CDYIRHrI8seofOO0YFGDhpQ
       */
      refresh_token: string;
    };
    /**
     * @description Region where the bucket is located.
     * @example us-east-1
     */
    Region: string;
    RegionIn: {
      /**
       * @description The region the interface should be deployed to.
       * @example ashburn-va
       */
      region_code?: string;
    };
    /** @example {
     *       "region_type": "country_code",
     *       "region_name": "US"
     *     } */
    RegionInformation: {
      /**
       * @example country_code
       * @enum {string}
       */
      region_type?: 'country_code' | 'rate_center' | 'state' | 'location';
      /** @example US */
      region_name?: string;
    };
    RegionOut: {
      /**
       * @description The region interface is deployed to.
       * @example ashburn-va
       */
      region_code?: string;
      region?: {
        /**
         * @description Region code of the interface.
         * @example ashburn-va
         */
        code?: string;
        /**
         * @description Region name of the interface.
         * @example Ashburn
         */
        name?: string;
        /**
         * @description Identifies the type of the resource.
         * @example region
         */
        readonly record_type?: string;
      };
    };
    RegulatoryRequirements: {
      /** @example DE */
      readonly country_code?: string;
      /** @example local */
      readonly phone_number_type?: string;
      /** @example ordering */
      readonly action?: string;
      regulatory_requirements?: {
        /** @example Address matching the DID area code (street, building number, postal code, city and country) */
        readonly description?: string;
        /**
         * Format: uuid
         * @example 12ade33a-21c0-473b-b055-b3c836e1c292
         */
        readonly id?: string;
        /** @example 311 W Superior St, Chicago, IL 60654 */
        readonly example?: string;
        /** @example Address matching the DID area code */
        name?: string;
        /** @example address_id */
        field_type?: string;
        acceptance_criteria?: {
          /** @example Identical locality as the numbers desired */
          locality_limit?: string;
          /** @example Less than 5 months old */
          time_limit?: string;
          /** @example regex field value must match */
          regex?: string;
          /** @example Whether field value is case sensitive */
          case_sensitive?: string;
          /** @example Characters that can be included in field value */
          acceptable_characters?: string;
          acceptable_values?: unknown[];
          /** @example 10 */
          max_length?: string;
          /** @example 5 */
          min_length?: string;
        };
      }[];
    };
    RegulatoryRequirementsPhoneNumbers: {
      /** @example +41215471644 */
      readonly phone_number?: string;
      /** @example local */
      readonly phone_number_type?: string;
      region_information?: {
        /** @example CH */
        region_name?: string;
        /** @example country_code */
        region_type?: string;
      }[];
      /** @example phone_number_regulatory_requirements */
      readonly record_type?: string;
      regulatory_requirements?: {
        /** @example Address matching the DID area code (street, building number, postal code, city and country) */
        readonly description?: string;
        /**
         * Format: uuid
         * @example 12ade33a-21c0-473b-b055-b3c836e1c292
         */
        readonly id?: string;
        /** @example 311 W Superior St, Chicago, IL 60654 */
        readonly example?: string;
        /** @example Address matching the DID area code */
        label?: string;
        /** @example address_id */
        field_type?: string;
        acceptance_criteria?: {
          /** @example Identical locality as the numbers desired */
          locality_limit?: string;
          /** @example 45f45a04-b4be-4592-95b1-9306b9db2b21 */
          field_value?: string;
          /** @example address */
          field_type?: string;
        };
        /** @example regulatory_requirement */
        readonly record_type?: string;
      }[];
    };
    /**
     * Reject Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "cause": "USER_BUSY"
     *     }
     */
    RejectRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Cause for call rejection.
       * @example USER_BUSY
       * @enum {string}
       */
      cause: 'CALL_REJECTED' | 'USER_BUSY';
    };
    /** Phone Number Release */
    Release: {
      ticket_id?: components['schemas']['UUID'];
      /**
       * Format: uuid
       * @example ea175aba-f47c-4702-9400-efaa42688048
       */
      tenant_id?: string;
      /**
       * @description Represents the status of the release on Microsoft Teams.
       * @default pending_upload
       * @example pending
       * @enum {string}
       */
      status:
        | 'pending_upload'
        | 'pending'
        | 'in_progress'
        | 'complete'
        | 'failed'
        | 'expired'
        | 'unknown';
      /** @description A message set if there is an error with the upload process. */
      error_message?: string;
      telephone_numbers?: components['schemas']['TnReleaseEntry'][];
      /**
       * @description ISO 8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
    };
    /** @example {
     *       "record_type": "link_clicked",
     *       "url": "https://telnyx.com",
     *       "to": "18445550001",
     *       "message_id": "7ee4241c-f127-47e5-9c34-3aac291f8058",
     *       "time_clicked": "2019-04-01T14:45:45.450Z"
     *     } */
    ReplacedLinkClick: {
      /**
       * @description Identifies the type of the resource.
       * @example link_clicked
       */
      record_type?: string;
      /**
       * @description The original link that was sent in the message.
       * @example link_clicked
       */
      url?: string;
      /**
       * Format: address
       * @description Sending address (+E.164 formatted phone number, alphanumeric sender ID, or short code).
       */
      to?: string;
      /**
       * Format: uuid
       * @description The message ID associated with the clicked link.
       */
      message_id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the message request was received.
       */
      time_clicked?: string;
    };
    ReplacedLinkClickEvent: {
      data?: components['schemas']['ReplacedLinkClick'];
    };
    RequirementGroup: {
      id?: string;
      country_code?: string;
      phone_number_type?: string;
      /** @enum {string} */
      status?: 'approved' | 'unapproved' | 'pending-approval' | 'declined';
      action?: string;
      customer_reference?: string;
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
      /** @example requirement_group */
      record_type?: string;
      regulatory_requirements?: components['schemas']['UserRequirement'][];
    };
    /** @example {
     *       "id": "12ade33a-21c0-473b-b055-b3c836e1c292",
     *       "record_type": "reserved_phone_number",
     *       "phone_number": "+19705555098",
     *       "status": "pending",
     *       "created_at": "2018-01-01T00:00:00.000000Z",
     *       "updated_at": "2018-01-01T00:00:00.000000Z",
     *       "expired_at": "2018-01-01T00:00:00.000000Z"
     *     } */
    ReservedPhoneNumber: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /** @example reserved_phone_number */
      readonly record_type?: string;
      /**
       * Format: e164_phone_number
       * @example +19705555098
       */
      phone_number?: string;
      /**
       * @description The status of the phone number's reservation.
       * @example success
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the individual number reservation was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the the individual number reservation was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the individual number reservation is going to expire
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly expired_at?: string;
    };
    ResourceNotFoundError: {
      errors?: {
        /** @description Error code identifying the error type. */
        code?: string;
        /** @description A human-readable explanation of the error. */
        detail?: string;
        meta?: {
          /**
           * Format: uri
           * @description A URL to the detailed documentation for the error.
           */
          url?: string;
        };
        /** @description A short, human-readable summary of the problem. */
        title?: string;
      }[];
    };
    /** Pause Recording Request */
    ResumeConferenceRecordingRequest: {
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Use this field to resume specific recording.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      recording_id?: string;
    };
    /** Pause Recording Request */
    ResumeRecordingRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** Retrieval */
    Retrieval: {
      /** @enum {string} */
      type: 'retrieval';
      retrieval: components['schemas']['BucketIds'];
    };
    /** RetrievalDetail */
    RetrievalDetail: {
      /** Bucket Ids */
      bucket_ids: string[];
    };
    /** RetrieveVerificationResponse */
    RetrieveVerificationResponse: {
      data: components['schemas']['Verification'];
    };
    /** @example {
     *       "id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "max_participants": 50,
     *       "unique_name": "My Room",
     *       "created_at": "2021-04-16T09:46:20.954863Z",
     *       "updated_at": "2021-04-16T10:24:55.962200Z",
     *       "active_session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e74",
     *       "enable_recording": true,
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_timeout_secs": 25,
     *       "webhook_event_url": "https://www.example.com",
     *       "sessions": [
     *         {
     *           "id": "7b61621f-62e0-4aad-ab11-9fd19e272e74",
     *           "room_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *           "active": true,
     *           "created_at": "2021-04-16T09:46:20.954863Z",
     *           "updated_at": "2021-04-16T10:24:55.962200Z",
     *           "participants": [],
     *           "record_type": "room_session"
     *         }
     *       ],
     *       "record_type": "room"
     *     } */
    Room: {
      /**
       * Format: uuid
       * @description A unique identifier for the room.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * @description Maximum participants allowed in the room.
       * @example 50
       */
      max_participants?: number;
      /**
       * @description The unique (within the Telnyx account scope) name of the room.
       * @example My room
       */
      unique_name?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room was created.
       * @example 2021-03-26T17:51:59.588408Z
       */
      created_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room was updated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      updated_at?: string;
      /**
       * Format: uuid
       * @description The identifier of the active room session if any.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      active_session_id?: string;
      sessions?: components['schemas']['RoomSession'][];
      /**
       * @description Enable or disable recording for that room.
       * @default false
       * @example true
       */
      enable_recording: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this room will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this room will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      /** @example room */
      readonly record_type?: string;
    };
    /** @example {
     *       "completed_at": "2022-02-25T05:39:56.377426Z",
     *       "download_url": null,
     *       "duration_secs": 84,
     *       "ended_at": "2022-02-24T23:22:24.577677Z",
     *       "format": "mp4",
     *       "id": "7103dc53-ee59-4b54-a58b-c77d99ceb037",
     *       "record_type": "composition",
     *       "resolution": "1280x720",
     *       "room_id": "f981dbb3-228a-44e9-ac54-e87f0e2658b0",
     *       "session_id": "8f728d7b-00e2-4c59-8c27-f564b828df87",
     *       "size_mb": 6,
     *       "started_at": "2022-02-24T23:21:00.077209Z",
     *       "status": "enqueued",
     *       "user_id": "12a04ec9-0f91-4a91-9f3a-a19d9931182e",
     *       "video_layout": {
     *         "first": {
     *           "height": 720,
     *           "video_sources": [
     *             "*"
     *           ],
     *           "width": 1280,
     *           "x_pos": 0,
     *           "y_pos": 0,
     *           "z_pos": 0
     *         }
     *       },
     *       "webhook_event_url": "https://webhook.site/544663ce-b692-4f9c-80ed-e5ad97cd5c02"
     *     } */
    RoomComposition: {
      /**
       * Format: uuid
       * @description A unique identifier for the room composition.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identify the room associated with the room composition.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      room_id?: string;
      /**
       * Format: uuid
       * @description Identify the room session associated with the room composition.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      session_id?: string;
      /**
       * Format: uuid
       * @description Identify the user associated with the room composition.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      user_id?: string;
      /**
       * @description Shows the room composition status.
       * @example completed
       * @enum {string}
       */
      status?: 'completed' | 'enqueued' | 'processing';
      /**
       * Format: float
       * @description Shows the room composition size in MB.
       * @example 10.5
       */
      size_mb?: number;
      /**
       * @description Url to download the composition.
       * @example https://www.example.com
       */
      download_url?: string;
      /**
       * @description Shows the room composition duration in seconds.
       * @example 67
       */
      duration_secs?: number;
      /**
       * @description Shows format of the room composition.
       * @example mp4
       * @enum {string}
       */
      format?: 'mp4';
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room composition was created.
       * @example 2021-03-26T17:51:59.588408Z
       */
      created_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room composition was updated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      updated_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room composition has ended.
       * @example 2021-03-26T17:51:59.588408Z
       */
      ended_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room composition has stated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      started_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room composition has completed.
       * @example 2021-03-26T17:51:59.588408Z
       */
      completed_at?: string;
      /** @description Describes the video layout of the room composition in terms of regions. Limited to 2 regions. */
      video_layout?: {
        [key: string]: components['schemas']['VideoRegion'];
      };
      /**
       * Format: url
       * @description The URL where webhooks related to this room composition will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this room composition will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      /** @example room_composition */
      readonly record_type?: string;
    };
    /** @example {
     *       "id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "session_id": "7b61621f-5fe4-4aad-ab11-9fd19e272e73",
     *       "context": "Alice",
     *       "joined_at": "2021-04-16T09:46:20.954863Z",
     *       "updated_at": "2021-04-16T10:24:55.962200Z",
     *       "left_at": "2021-04-16T10:24:55.962200Z",
     *       "record_type": "room_participant"
     *     } */
    RoomParticipant: {
      /**
       * Format: uuid
       * @description A unique identifier for the room participant.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identify the room session that participant is part of.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      session_id?: string;
      /**
       * @description Context provided to the given participant through the client SDK
       * @example Alice
       */
      context?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the participant joined the session.
       * @example 2021-03-26T17:51:59.588408Z
       */
      joined_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the participant was updated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      updated_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the participant left the session.
       * @example 2021-03-26T17:51:59.588408Z
       */
      left_at?: string;
      /** @example room_participant */
      readonly record_type?: string;
    };
    /** @example {
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "room_id": "7b61621f-5fe4-4aad-ab11-9fd19e272e73",
     *       "session_id": "8b61621f-5fe4-4aad-ab11-9fd19e272e73",
     *       "participant_id": "9b61621f-5fe4-4aad-ab11-9fd19e272e73",
     *       "status": "completed",
     *       "download_url": "https://www.example.com",
     *       "type": "audio",
     *       "duration_secs": 3660,
     *       "size_mb": 5.6,
     *       "codec": "opus",
     *       "created_at": "2021-04-16T09:46:20.954863Z",
     *       "updated_at": "2021-04-16T10:24:55.962200Z",
     *       "started_at": "2021-04-16T09:24:55.962200Z",
     *       "ended_at": "2021-04-16T10:24:55.962200Z",
     *       "completed_at": "2021-04-16T10:25:55.962200Z",
     *       "record_type": "room_session"
     *     } */
    RoomRecording: {
      /**
       * Format: uuid
       * @description A unique identifier for the room recording.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identify the room associated with the room recording.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      room_id?: string;
      /**
       * Format: uuid
       * @description Identify the room session associated with the room recording.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      session_id?: string;
      /**
       * Format: uuid
       * @description Identify the room participant associated with the room recording.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      participant_id?: string;
      /**
       * @description Shows the room recording status.
       * @example completed
       * @enum {string}
       */
      status?: 'completed' | 'processing';
      /**
       * @description Shows the room recording type.
       * @example audio
       * @enum {string}
       */
      type?: 'audio' | 'video';
      /**
       * Format: float
       * @description Shows the room recording size in MB.
       * @example 10.5
       */
      size_mb?: number;
      /**
       * @description Url to download the recording.
       * @example https://www.example.com
       */
      download_url?: string;
      /**
       * @description Shows the codec used for the room recording.
       * @example opus
       */
      codec?: string;
      /**
       * @description Shows the room recording duration in seconds.
       * @example 67
       */
      duration_secs?: number;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room recording was created.
       * @example 2021-03-26T17:51:59.588408Z
       */
      created_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room recording was updated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      updated_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room recording has ended.
       * @example 2021-03-26T17:51:59.588408Z
       */
      ended_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room recording has stated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      started_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room recording has completed.
       * @example 2021-03-26T17:51:59.588408Z
       */
      completed_at?: string;
      /** @example room_recording */
      readonly record_type?: string;
    };
    /** @example {
     *       "id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "room_id": "7b61621f-5fe4-4aad-ab11-9fd19e272e73",
     *       "active": false,
     *       "created_at": "2021-04-16T09:46:20.954863Z",
     *       "updated_at": "2021-04-16T10:24:55.962200Z",
     *       "ended_at": "2021-04-16T10:24:55.962200Z",
     *       "participants": [],
     *       "record_type": "room_session"
     *     } */
    RoomSession: {
      /**
       * Format: uuid
       * @description A unique identifier for the room session.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identify the room hosting that room session.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777b0
       */
      room_id?: string;
      /**
       * @description Shows if the room session is active or not.
       * @example false
       */
      active?: boolean;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room session was created.
       * @example 2021-03-26T17:51:59.588408Z
       */
      created_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room session was updated.
       * @example 2021-03-26T17:51:59.588408Z
       */
      updated_at?: string;
      /**
       * Format: datetime
       * @description ISO 8601 timestamp when the room session has ended.
       * @example 2021-03-26T17:51:59.588408Z
       */
      ended_at?: string;
      participants?: components['schemas']['RoomParticipant'][];
      /** @example room_session */
      readonly record_type?: string;
    };
    /** AWS S3 Storage Configuration Data */
    S3ConfigurationData: {
      bucket?: components['schemas']['Bucket'];
      region?: components['schemas']['Region'];
      aws_access_key_id?: components['schemas']['AwsAccessKeyId'];
      aws_secret_access_key?: components['schemas']['AwsSecretAccessKey'];
    };
    /** SIMCard */
    SIMCard: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /** @example sim_card */
      readonly record_type?: string;
      status?: components['schemas']['SIMCardStatus'];
      /**
       * @description The type of SIM card
       * @example physical
       * @enum {string}
       */
      readonly type?: 'physical' | 'esim';
      /**
       * @description The ICCID is the identifier of the specific SIM card/chip. Each SIM is internationally identified by its integrated circuit card identifier (ICCID). ICCIDs are stored in the SIM card's memory and are also engraved or printed on the SIM card body during a process called personalization.
       *
       * @example 89310410106543789301
       */
      readonly iccid?: string;
      /**
       * @description SIM cards are identified on their individual network operators by a unique International Mobile Subscriber Identity (IMSI). <br/>
       *     Mobile network operators connect mobile phone calls and communicate with their market SIM cards using their IMSIs. The IMSI is stored in the Subscriber  Identity Module (SIM) inside the device and is sent by the device to the appropriate network. It is used to acquire the details of the device in the Home  Location Register (HLR) or the Visitor Location Register (VLR).
       *
       * @example 081932214823362973
       */
      readonly imsi?: string;
      /**
       * @description Mobile Station International Subscriber Directory Number (MSISDN) is a number used to identify a mobile phone number internationally. <br/>
       *     MSISDN is defined by the E.164 numbering plan. It includes a country code and a National Destination Code which identifies the subscriber's operator.
       *
       * @example +13109976224
       */
      readonly msisdn?: string;
      /**
       * Format: uuid
       * @description The group SIMCardGroup identification. This attribute can be <code>null</code> when it's present in an associated resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_group_id?: string;
      /**
       * @description Searchable tags associated with the SIM card
       * @example [
       *       "personal",
       *       "customers",
       *       "active-customers"
       *     ]
       */
      tags?: string[];
      /**
       * @description List of IMEIs authorized to use a given SIM card.
       * @example [
       *       "106516771852751",
       *       "534051870479563",
       *       "508821468377961"
       *     ]
       */
      authorized_imeis?: string[];
      /**
       * Format: int64
       * @description IMEI of the device where a given SIM card is currently being used.
       * @example 457032284023794
       */
      readonly current_imei?: string;
      /** @description The SIM card individual data limit configuration. */
      data_limit?: {
        /**
         * Format: decimal
         * @example 2048.1
         */
        amount?: string;
        /**
         * @example MB
         * @enum {string}
         */
        unit?: 'MB' | 'GB';
      };
      /** @description The SIM card consumption so far in the current billing cycle. */
      readonly current_billing_period_consumed_data?: {
        /**
         * Format: decimal
         * @example 2049.0
         */
        amount?: string;
        /**
         * @default MB
         * @example MB
         */
        unit: string;
      };
      /**
       * @description Indicate whether the SIM card has any pending (in-progress) actions.
       * @default false
       * @example true
       */
      readonly actions_in_progress: boolean;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
      /**
       * @description The SIM's address in the currently connected network. This IPv4 address is usually obtained dynamically, so it may vary according to the location or new connections.
       *
       * @example 192.168.0.0
       */
      readonly ipv4?: string;
      /**
       * @description The SIM's address in the currently connected network. This IPv6 address is usually obtained dynamically, so it may vary according to the location or new connections.
       *
       * @example 2001:cdba:0000:0000:0000:0000:3257:9652
       */
      readonly ipv6?: string;
      /** @description Current physical location data of a given SIM card. Accuracy is given in meters. */
      readonly current_device_location?: {
        /**
         * Format: float
         * @example 41.143
         */
        latitude?: string;
        /**
         * Format: float
         * @example -8.605
         */
        longitude?: string;
        /** @example 1250 */
        accuracy?: number;
        /**
         * @default m
         * @example m
         */
        accuracy_unit: string;
      };
      /**
       * @description Mobile Network Code of the current network to which the SIM card is connected. It's a two to three decimal digits that identify a network.<br/><br/>
       *      This code is commonly seen joined with a Mobile Country Code (MCC) in a tuple that allows identifying a carrier known as PLMN (Public Land Mobile Network) code.
       * @example 260
       */
      readonly current_mnc?: string;
      /**
       * @description Mobile Country Code of the current network to which the SIM card is connected. It's a three decimal digit that identifies a country.<br/><br/>
       *     This code is commonly seen joined with a Mobile Network Code (MNC) in a tuple that allows identifying a carrier known as PLMN (Public Land Mobile Network) code.
       * @example 410
       */
      readonly current_mcc?: string;
      /**
       * @description Indicates whether the device is actively connected to a network and able to run data.
       * @example connected
       * @enum {string}
       */
      readonly live_data_session?: 'connected' | 'disconnected' | 'unknown';
    };
    /**
     * SIMCardAction
     * @description This object represents a SIM card action. It allows tracking the current status of an operation that impacts the SIM card.
     */
    SIMCardAction: {
      id?: components['schemas']['Id'];
      /** @example sim_card_action */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description The related SIM card identifier.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly sim_card_id?: string;
      /**
       * @description The operation type. It can be one of the following: <br/>
       *     <ul>
       *      <li><code>enable</code> - move the SIM card to the <code>enabled</code> status</li>
       *      <li><code>enable_standby_sim_card</code> - move a SIM card previously on the <code>standby</code> status to the <code>enabled</code> status after it consumes data.</li>
       *      <li><code>disable</code> - move the SIM card to the <code>disabled</code> status</li>
       *      <li><code>set_standby</code> - move the SIM card to the <code>standby</code> status</li>
       *      </ul>
       * @example enable
       * @enum {string}
       */
      readonly action_type?:
        | 'enable'
        | 'enable_standby_sim_card'
        | 'disable'
        | 'set_standby';
      status?: {
        /**
         * @description The current status of the SIM card action.
         * @example completed
         * @enum {string}
         */
        readonly value?: 'in-progress' | 'completed' | 'failed' | 'interrupted';
        /**
         * @description It describes why the SIM card action is in the current status. This will be <code>null</code> for self-explanatory statuses, such as <code>in-progress</code> and <code>completed</code> but will include further information on statuses like <code>interrupted</code> and <code>failed</code>.
         * @example The data limit was exceeded.
         */
        readonly reason?: string;
      };
      /**
       * @description A JSON object representation of the action params.
       * @example {}
       */
      readonly settings?: Record<string, never>;
      created_at?: components['schemas']['CreatedAt'];
      updated_at?: components['schemas']['UpdatedAt'];
    };
    SIMCardActionsSummary: {
      /**
       * @example in-progress
       * @enum {string}
       */
      status?: 'in-progress' | 'completed' | 'failed' | 'interrupted';
      count?: number;
    };
    /** SIMCardActivationCode */
    SIMCardActivationCode: {
      /** @example sim_card_activation_code */
      readonly record_type?: string;
      /**
       * @description Contents of the eSIM activation QR code.
       * @example LPA:1$....
       */
      readonly activation_code?: string;
    };
    /** SIMCardDeviceDetails */
    SIMCardDeviceDetails: {
      /** @example device_details */
      readonly record_type?: string;
      /**
       * Format: int64
       * @description IMEI of the device where the SIM card is being used in.
       * @example 457032284023794
       */
      readonly imei?: string;
      /**
       * @description Brand of the device where the SIM card is being used in.
       * @example iPad Pro 11 2020 Cellular
       */
      readonly model_name?: string;
      /**
       * @description Brand of the device where the SIM card is being used in.
       * @example Apple
       */
      readonly brand_name?: string;
      /**
       * @description Type of the device where the SIM card is being used in.
       * @example Tablet
       */
      readonly device_type?: string;
      /**
       * @description Operating system of the device where the SIM card is being used in.
       * @example iOS 12
       */
      readonly operating_system?: string;
    };
    /** SIMCardGroup */
    SIMCardGroup: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example sim_card_group
       */
      readonly record_type?: string;
      /**
       * @description Indicates whether the SIM card group is the users default group.<br/>The default group is created for the user and can not be removed.
       * @example true
       */
      readonly default?: boolean;
      /**
       * @description A user friendly name for the SIM card group.
       * @example My Test Group
       */
      name?: string;
      /** @description Upper limit on the amount of data the SIM cards, within the group, can use. */
      data_limit?: {
        /**
         * Format: decimal
         * @example 2048.1
         */
        amount?: string;
        /** @example MB */
        unit?: string;
      };
      consumed_data?: components['schemas']['ConsumedData'];
      /**
       * Format: uuid
       * @description The identification of the related Private Wireless Gateway resource.
       * @default null
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      private_wireless_gateway_id: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /**
     * SIMCardGroupAction
     * @description This object represents a SIM card group action request. It allows tracking the current status of an operation that impacts the SIM card group and SIM card in it.
     */
    SIMCardGroupAction: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /** @example sim_card_group_action */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description The SIM card group identification.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_group_id?: string;
      /**
       * @description Represents the type of the operation requested.
       * @example set_private_wireless_gateway
       * @enum {string}
       */
      type?: 'set_private_wireless_gateway' | 'remove_private_wireless_gateway';
      /**
       * @example in-progress
       * @enum {string}
       */
      status?: 'in-progress' | 'completed' | 'failed';
      /** @description A JSON object representation of the action params. */
      settings?: {
        /**
         * Format: uuid
         * @description The identification of the related Private Wireless Gateway resource.
         * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
         */
        private_wireless_gateway_id?: string;
      };
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SIMCardGroupCreate */
    SIMCardGroupCreate: {
      /**
       * @description A user friendly name for the SIM card group.
       * @example My Test Group
       */
      name: string;
      /** @description Upper limit on the amount of data the SIM cards, within the group, can use. */
      data_limit?: {
        /**
         * Format: decimal
         * @example 2048.1
         */
        amount?: string;
        /** @example MB */
        unit?: string;
      };
    };
    /** SIMCardGroupPatch */
    SIMCardGroupPatch: {
      /**
       * @description A user friendly name for the SIM card group.
       * @example My Test Group
       */
      name?: string;
      /** @description Upper limit on the amount of data the SIM cards, within the group, can use. */
      data_limit?: {
        /**
         * Format: decimal
         * @example 2048.1
         */
        amount?: string;
        /** @example MB */
        unit?: string;
      };
    };
    /** SIMCardNetworkPreference */
    SIMCardNetworkPreference: {
      /** @example sim_card_network_preferences */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @example 6b14e151-8493-4fa1-8664-1cc4e6d14158
       */
      sim_card_id?: string;
      mobile_network_operators_preferences?: components['schemas']['MobileNetworkOperatorsPreferencesResponse'];
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SIMCardNetworkPreferenceWithOTAUpdates */
    SIMCardNetworkPreferenceWithOTAUpdates: {
      /** @example sim_card_network_preferences */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @example 6b14e151-8493-4fa1-8664-1cc4e6d14158
       */
      sim_card_id?: string;
      mobile_network_operators_preferences?: components['schemas']['MobileNetworkOperatorsPreferencesResponse'];
      ota_updates?: components['schemas']['CompleteOTAUpdate'][];
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SIMCardOrder */
    SIMCardOrder: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example sim_card_order
       */
      readonly record_type?: string;
      /**
       * @description The amount of SIM cards requested in the SIM card order.
       * @example 21
       */
      quantity?: number;
      /**
       * @description An object representing the total cost of the order.
       * @example {
       *       "amount": "2.52",
       *       "currency": "USD"
       *     }
       */
      cost?: {
        /**
         * @description A string representing the cost amount.
         * @example 2.32
         */
        amount?: string;
        /**
         * Format: currency
         * @description Filter by ISO 4217 currency string.
         * @example USD
         */
        currency?: string;
      };
      /**
       * @description An object representing the address information from when the order was submitted.
       * @example {
       *       "id": "1293384261075731499",
       *       "street_address": "311 W Superior St",
       *       "extended_address": "Suite 504",
       *       "locality": "Chicago",
       *       "administrative_area": "IL",
       *       "country_code": "US",
       *       "postal_code": "60654"
       *     }
       */
      readonly order_address?: {
        /**
         * Format: int64
         * @description Uniquely identifies the address for the order.
         * @example 1293384261075731499
         */
        id?: string;
        /**
         * @description The first name of the shipping recipient.
         * @example John
         */
        first_name?: string;
        /**
         * @description The last name of the shipping recipient.
         * @example Smith
         */
        last_name?: string;
        /**
         * @description The name of the business where the address is located.
         * @example Telnyx LLC
         */
        business_name?: string;
        /**
         * @description The name of the street where the address is located.
         * @example 311 W Superior St
         */
        street_address?: string;
        /**
         * @description Supplemental field for address information.
         * @example Suite 504
         */
        extended_address?: string;
        /**
         * @description The name of the city where the address is located.
         * @example Chicago
         */
        locality?: string;
        /**
         * @description State or province where the address is located.
         * @example IL
         */
        administrative_area?: string;
        /**
         * @description The mobile operator two-character (ISO 3166-1 alpha-2) origin country code.
         * @example US
         */
        country_code?: string;
        /**
         * @description Postal code for the address.
         * @example 60654
         */
        postal_code?: string;
      };
      /**
       * Format: url
       * @description The URL used to get tracking information about the order.
       * @example http://www.example.com/
       */
      tracking_url?: string;
      /**
       * @description The current status of the SIM Card order.<ul> <li><code>pending</code> - the order is waiting to be processed.</li> <li><code>processing</code> - the order is currently being processed.</li> <li><code>ready_to_ship</code> - the order is ready to be shipped to the specified <b>address</b>.</li> <li><code>shipped</code> - the order was shipped and is on its way to be delivered to the specified <b>address</b>.</li> <li><code>delivered</code> - the order was delivered to the specified <b>address</b>.</li> <li><code>canceled</code> - the order was canceled.</li> </ul>
       * @example pending
       * @enum {string}
       */
      status?:
        | 'pending'
        | 'processing'
        | 'ready_to_ship'
        | 'shipped'
        | 'delivered'
        | 'canceled';
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was last created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was last updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SIMCardOrderPreview */
    SIMCardOrderPreview: {
      total_cost?: {
        /**
         * @description A string representing the cost amount.
         * @example 2.32
         */
        amount?: string;
        /**
         * Format: currency
         * @description ISO 4217 currency string.
         * @example USD
         */
        currency?: string;
      };
      shipping_cost?: {
        /**
         * @description A string representing the cost amount.
         * @example 2.32
         */
        amount?: string;
        /**
         * Format: currency
         * @description ISO 4217 currency string.
         * @example USD
         */
        currency?: string;
      };
      sim_cards_cost?: {
        /**
         * @description A string representing the cost amount.
         * @example 2.32
         */
        amount?: string;
        /**
         * Format: currency
         * @description ISO 4217 currency string.
         * @example USD
         */
        currency?: string;
      };
      /**
       * @description Identifies the type of the resource.
       * @example sim_card_order_preview
       */
      readonly record_type?: string;
      /**
       * @description The amount of SIM cards requested in the SIM card order.
       * @example 21
       */
      quantity?: number;
    };
    /** SIMCardPublicIP */
    SIMCardPublicIP: {
      /** @example sim_card_public_ip */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @example 6b14e151-8493-4fa1-8664-1cc4e6d14158
       */
      sim_card_id?: string;
      /**
       * @default ipv4
       * @example ipv4
       * @enum {string}
       */
      readonly type: 'ipv4';
      /**
       * @description The provisioned IP address. This attribute will only be available when underlying resource status is in a "provisioned" status.
       * @default null
       * @example 192.168.0.0
       */
      readonly ip: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SIMCardRegistration */
    SIMCardRegistration: {
      /**
       * Format: uuid
       * @description The group SIMCardGroup identification. This attribute can be <code>null</code> when it's present in an associated resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_group_id?: string;
      /**
       * @description Searchable tags associated with the SIM card
       * @example [
       *       "personal",
       *       "customers",
       *       "active-customers"
       *     ]
       */
      tags?: string[];
      /** @example [
       *       "0000000001",
       *       "0000000002",
       *       "0000000003"
       *     ] */
      registration_codes: string[];
      /**
       * @description Status on which the SIM card will be set after being successful registered.
       * @default enabled
       * @example standby
       * @enum {string}
       */
      status: 'enabled' | 'disabled' | 'standby';
    };
    SIMCardRegistrationCodeValidation: {
      /** @example sim_card_registration_code_validation */
      record_type?: string;
      /**
       * @description The 10-digit SIM card registration code
       * @example 0123456789
       */
      registration_code?: string;
      /**
       * @description The attribute that denotes whether the code is valid or not
       * @example false
       */
      valid?: boolean;
      /**
       * @description The validation message
       * @example This code has already been used.
       */
      invalid_detail?: string | null;
    };
    SIMCardRegistrationCodeValidations: {
      data?: components['schemas']['SIMCardRegistrationCodeValidation'][];
    };
    SIMCardStatus: {
      /**
       * @description The current status of the SIM card. It will be one of the following: <br/>
       *     <ul>
       *      <li><code>registering</code> - the card is being registered</li>
       *      <li><code>enabling</code> - the card is being enabled</li>
       *      <li><code>enabled</code> - the card is enabled and ready for use</li>
       *      <li><code>disabling</code> - the card is being disabled</li>
       *      <li><code>disabled</code> - the card has been disabled and cannot be used</li>
       *      <li><code>data_limit_exceeded</code> - the card has exceeded its data consumption limit</li>
       *      <li><code>setting_standby</code> - the process to set the card in stand by is in progress</li>
       *      <li><code>standby</code> - the card is in stand by</li>
       *     </ul>
       *     Transitioning between the enabled and disabled states may take a period of time.
       *
       * @example enabled
       * @enum {string}
       */
      readonly value?:
        | 'registering'
        | 'enabling'
        | 'enabled'
        | 'disabling'
        | 'disabled'
        | 'data_limit_exceeded'
        | 'setting_standby'
        | 'standby';
      /**
       * @description It describes why the SIM card is in the current status.
       * @example The SIM card is active, ready to connect to networks and consume data.
       */
      readonly reason?: string;
    };
    SSLCertificate: {
      /** @description Unique identifier for the SSL certificate */
      id?: string;
      issued_to?: {
        /** @description The common name of the entity the certificate was issued to */
        common_name?: string;
        /** @description The organization the certificate was issued to */
        organization?: string;
        /** @description The organizational unit the certificate was issued to */
        organization_unit?: string;
      };
      issued_by?: {
        /** @description The common name of the entity the certificate was issued by */
        common_name?: string;
        /** @description The organization the certificate was issued by */
        organization?: string;
        /** @description The organizational unit the certificate was issued by */
        organization_unit?: string;
      };
      /**
       * Format: date-time
       * @description The time the certificate is valid from
       * @example 2020-01-01T00:00:00Z
       */
      valid_from?: string;
      /**
       * Format: date-time
       * @description The time the certificate is valid to
       * @example 2020-01-01T00:00:00Z
       */
      valid_to?: string;
      /**
       * Format: date-time
       * @description Time when SSL certificate was uploaded
       * @example 2020-01-01T00:00:00Z
       */
      created_at?: string;
    };
    /** SIMCardGroup */
    SearchedSIMCardGroup: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example sim_card_group
       */
      readonly record_type?: string;
      /**
       * @description Indicates whether the SIM card group is the users default group.<br/>The default group is created for the user and can not be removed.
       * @example true
       */
      readonly default?: boolean;
      /**
       * @description A user friendly name for the SIM card group.
       * @example My Test Group
       */
      name?: string;
      /** @description Upper limit on the amount of data the SIM cards, within the group, can use. */
      data_limit?: {
        /**
         * Format: decimal
         * @example 2048.1
         */
        amount?: string;
        /** @example MB */
        unit?: string;
      };
      consumed_data?: components['schemas']['ConsumedData'];
      /**
       * @description The number of SIM cards associated with the group.
       * @default 0
       * @example 10
       */
      sim_card_count: number;
      /**
       * Format: uuid
       * @description The identification of the related Private Wireless Gateway resource.
       * @default null
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      private_wireless_gateway_id: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /**
     * Send DTMF Request
     * @example {
     *       "digits": "1www2WABCDw9",
     *       "duration_millis": 500,
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    SendDTMFRequest: {
      /**
       * @description DTMF digits to send. Valid digits are 0-9, A-D, *, and #. Pauses can be added using w (0.5s) and W (1s).
       * @example 1www2WABCDw9
       */
      digits: string;
      /**
       * Format: int32
       * @description Specifies for how many milliseconds each digit will be played in the audio stream. Ranges from 100 to 500ms
       * @default 250
       * @example 500
       */
      duration_millis: number;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /** Send fax multipart request */
    SendFaxMultipartRequest: {
      connection_id: components['schemas']['ConnectionId'];
      /**
       * Format: binary
       * @description The file you want to upload. The maximum allowed size is 20 MB. contents and media_name/media_url can't be submitted together.
       */
      contents: string;
      to: components['schemas']['To'];
      from: components['schemas']['From'];
      quality?: components['schemas']['Quality'];
      t38_enabled?: components['schemas']['T38Enabled'];
      monochrome?: components['schemas']['Monochrome'];
      store_media?: components['schemas']['StoreMedia'];
      store_preview?: components['schemas']['StorePreview'];
    };
    /** Send fax request */
    SendFaxRequest: {
      /**
       * @description The connection ID to send the fax with.
       * @example 234423
       */
      connection_id: string;
      media_url?: components['schemas']['MediaUrl'];
      media_name?: components['schemas']['MediaName'];
      to: components['schemas']['To'];
      from: components['schemas']['From'];
      /**
       * @description The `from_display_name` string to be used as the caller id name (SIP From Display Name) presented to the destination (`to` number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and -_~!.+ special characters. If ommited, the display name will be the same as the number in the `from` field.
       * @example Company Name
       */
      from_display_name?: string;
      quality?: components['schemas']['Quality'];
      /**
       * @description The flag to disable the T.38 protocol.
       * @default true
       */
      t38_enabled: boolean;
      /**
       * @description The flag to enable monochrome, true black and white fax results.
       * @default false
       */
      monochrome: boolean;
      /**
       * @description Should fax media be stored on temporary URL. It does not support media_name, they can't be submitted together.
       * @default false
       */
      store_media: boolean;
      /**
       * @description Should fax preview be stored on temporary URL.
       * @default false
       */
      store_preview: boolean;
      /**
       * @description Use this field to override the URL to which Telnyx will send subsequent webhooks for this fax.
       * @example https://www.example.com/server-b/
       */
      webhook_url?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
    };
    /**
     * Send SIP Info Request
     * @example {
     *       "content_type": "application/json",
     *       "body": "{\"key\": \"value\", \"numValue\": 100}",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    SendSIPInfoRequest: {
      /**
       * @description Content type of the INFO body. Must be MIME type compliant. There is a 1,400 bytes limit
       * @example application/json
       */
      content_type: string;
      /**
       * @description Content of the SIP INFO
       * @example {"key": "value", "numValue": 100}
       */
      body: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * @description Indicates the coverage of the termination regions.
     * @default global
     * @example global
     * @enum {string}
     */
    ServicePlan: 'global';
    /**
     * Session Ended
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.session.ended",
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *         "room_id": "0ccc7b54-4df3-4bca-a65a-35a1ecc777f0",
     *         "duration_secs": 235,
     *         "ended_reason": "stale"
     *       }
     *     }
     */
    SessionEnded: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.session.ended
       * @enum {string}
       */
      event_type?: 'video.room.session.ended';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Session ID that identifies the session that ended.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: uuid
         * @description Room ID that identifies the room where the session ended.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
        /**
         * @description The duration in seconds of the session
         * @example 245
         */
        duration_secs?: number;
        /**
         * @description The reason why the session ended
         * @example stale
         */
        ended_reason?: string;
      };
    };
    /** Session Ended Event */
    SessionEndedEvent: {
      data?: components['schemas']['SessionEnded'];
    };
    /**
     * Session Started
     * @example {
     *       "record_type": "event",
     *       "event_type": "video.room.session.started",
     *       "id": "6b61621f-62e0-4aad-ab11-9fd19e272e73",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "session_id": "7b61621f-62e0-4aad-ab11-9fd19e272e73",
     *         "room_id": "0ccc7b54-4df3-4bca-a65a-35a1ecc777f0"
     *       }
     *     }
     */
    SessionStarted: {
      /**
       * @description An identifier for the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example video.room.session.started
       * @enum {string}
       */
      event_type?: 'video.room.session.started';
      /**
       * Format: uuid
       * @description Uniquely identify the event.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * Format: uuid
         * @description Session ID that identifies the session that started.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        session_id?: string;
        /**
         * Format: uuid
         * @description Room ID that identifies the room where the session started.
         * @example 0ccc7b54-4df3-4bca-a65a-35a1ecc777f0
         */
        room_id?: string;
      };
    };
    /** Session Started Event */
    SessionStartedEvent: {
      data?: components['schemas']['SessionStarted'];
    };
    /** SettingsDataErrorMessage */
    SettingsDataErrorMessage: {
      /** Message */
      message: string;
    };
    /**
     * SharedCampaign
     * @description Campaign is generated by the 10DLC registry once the corresponding campaign request is approved. Each campaign is assigned a unique identifier - **campaignId**. Once a campaign is activated, limited information is published to the NetNumber OSR service for consumption by members of the ecosystem. When a campaign is suspended(reversible) or expired(non-reversible), campaign data is deleted from the OSR service. Most attributes of campaignare immutable, including **usecase**, **vertical**, **brandId** and **cspId**.
     */
    SharedCampaign: {
      /**
       * Brandid
       * @description Alphanumeric identifier of the brand associated with this campaign.
       */
      brandId: string;
      /**
       * Campaignid
       * @description Alphanumeric identifier assigned by the registry for a campaign. This identifier is required by the NetNumber OSR SMS enabling process of 10DLC.
       */
      campaignId: string;
      /**
       * Createdate
       * @description Unix timestamp when campaign was created.
       */
      createDate?: string;
      /**
       * Status
       * @description Current campaign status. Possible values: ACTIVE, EXPIRED. A newly created campaign defaults to ACTIVE status.
       */
      status?: string;
      /**
       * Usecase
       * @description Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase` operation to retrieve usecases available for given brand.
       */
      usecase: string;
    };
    /** SharedCampaignRecordSet */
    SharedCampaignRecordSet: {
      /** Page */
      page?: number;
      /** Records */
      records?: components['schemas']['SharedCampaign'][];
      /** Totalrecords */
      totalRecords?: number;
    };
    /** @example {
     *       "record_type": "short_code",
     *       "id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "short_code": "12345",
     *       "country_code": "US",
     *       "messaging_profile_id": "3fa85f64-5717-4562-b3fc-2c963f66afa6",
     *       "created_at": "2019-01-23T18:10:02.574Z",
     *       "updated_at": "2019-01-23T18:10:02.574Z"
     *     } */
    ShortCode: {
      /**
       * @description Identifies the type of the resource.
       * @example short_code
       * @enum {string}
       */
      readonly record_type?: 'short_code';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      readonly id?: string;
      /** @description Short digit sequence used to address messages. */
      readonly short_code?: string;
      /**
       * @description ISO 3166-1 alpha-2 country code.
       * @example US
       */
      readonly country_code?: string;
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id: string | null;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       */
      readonly updated_at?: string;
    };
    /**
     * @description The SIM card individual data usage notification information.
     * @example {
     *       "id": "79228acc-3f08-4e70-ac68-cb5aae8b537a",
     *       "sim_card_id": "b34c1683-cd85-4493-b9a5-315eb4bc5e19",
     *       "threshold": {
     *         "amount": "2048.0",
     *         "unit": "MB"
     *       },
     *       "created_at": "2018-02-02T22:25:27.521Z",
     *       "updated_at": "2018-02-02T22:25:27.521Z"
     *     }
     */
    SimCardDataUsageNotification: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 79228acc-3f08-4e70-ac68-cb5aae8b537a
       */
      readonly id?: string;
      /**
       * Format: uuid
       * @description The identification UUID of the related SIM card resource.
       * @example b34c1683-cd85-4493-b9a5-315eb4bc5e19
       */
      sim_card_id?: string;
      /** @example sim_card_data_usage_notification */
      readonly record_type?: string;
      /** @description Data usage threshold that will trigger the notification. */
      threshold?: {
        /**
         * Format: decimal
         * @example 2048.1
         */
        amount?: string;
        /**
         * @example MB
         * @enum {string}
         */
        unit?: 'MB' | 'GB';
      };
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /** SimCardOrderCreate */
    SimCardOrderCreate: {
      /**
       * Format: int64
       * @description Uniquely identifies the address for the order.
       * @example 1293384261075731499
       */
      address_id: string;
      /**
       * @description The amount of SIM cards to order.
       * @example 23
       */
      quantity: number;
    };
    SimCardUsageDetailRecord: {
      /**
       * Format: uuid
       * @description Unique identifier for this SIM Card Usage
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      id?: string;
      /**
       * Format: date-time
       * @description Event creation time
       * @example 2020-07-01T00:00:00Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description Event close time
       * @example 2020-07-01T00:00:00Z
       */
      closed_at?: string;
      /**
       * @description Ip address that generated the event
       * @example 100.64.1.2
       */
      ip_address?: string;
      /**
       * @description Number of megabytes downloaded
       * @example 0.1240
       */
      downlink_data?: number;
      /**
       * @description International Mobile Subscriber Identity
       * @example 311210393720093
       */
      imsi?: string;
      /**
       * @description Mobile country code
       * @example 204
       */
      mcc?: string;
      /**
       * @description Mobile network code
       * @example 69
       */
      mnc?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * @description Unit of wireless link consumption
       * @example MB
       */
      data_unit?: string;
      /**
       * Format: monetary_value
       * @description Currency amount per billing unit used to calculate the Telnyx billing cost
       * @example 0.06000
       */
      data_rate?: string;
      /**
       * @description Sim group name for sim card
       * @example SIMBillingInfo test - otheraccount
       */
      sim_group_name?: string;
      /**
       * @description Unique identifier for SIM card
       * @example 7aa66686-b39f-456d-8edc-5b6cffb1432a
       */
      sim_card_id?: string;
      /**
       * @description Unique identifier for SIM group
       * @example 6c07e2e9-cbc0-49ba-ac0d-c59b59646bb1
       */
      sim_group_id?: string;
      /**
       * @description User-provided tags
       * @example mytag
       */
      sim_card_tags?: string;
      /**
       * @description Telephone number associated to SIM card
       * @example +15188490209
       */
      phone_number?: string;
      /**
       * @description Number of megabytes uploaded
       * @example 0.7653
       */
      uplink_data?: number;
      /**
       * @description Data cost
       * @example 0.0292830
       */
      data_cost?: number;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'SimCardUsageDetailRecord';
    };
    /** SIMCard */
    SimpleSIMCard: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /** @example sim_card */
      readonly record_type?: string;
      status?: components['schemas']['SIMCardStatus'];
      /**
       * @description The type of SIM card
       * @example physical
       * @enum {string}
       */
      readonly type?: 'physical' | 'esim';
      /**
       * @description The ICCID is the identifier of the specific SIM card/chip. Each SIM is internationally identified by its integrated circuit card identifier (ICCID). ICCIDs are stored in the SIM card's memory and are also engraved or printed on the SIM card body during a process called personalization.
       *
       * @example 89310410106543789301
       */
      readonly iccid?: string;
      /**
       * @description SIM cards are identified on their individual network operators by a unique International Mobile Subscriber Identity (IMSI). <br/>
       *     Mobile network operators connect mobile phone calls and communicate with their market SIM cards using their IMSIs. The IMSI is stored in the Subscriber  Identity Module (SIM) inside the device and is sent by the device to the appropriate network. It is used to acquire the details of the device in the Home  Location Register (HLR) or the Visitor Location Register (VLR).
       *
       * @example 081932214823362973
       */
      readonly imsi?: string;
      /**
       * @description Mobile Station International Subscriber Directory Number (MSISDN) is a number used to identify a mobile phone number internationally. <br/>
       *     MSISDN is defined by the E.164 numbering plan. It includes a country code and a National Destination Code which identifies the subscriber's operator.
       *
       * @example +13109976224
       */
      readonly msisdn?: string;
      /**
       * Format: uuid
       * @description The group SIMCardGroup identification. This attribute can be <code>null</code> when it's present in an associated resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_group_id?: string;
      /**
       * @description Searchable tags associated with the SIM card
       * @example [
       *       "personal",
       *       "customers",
       *       "active-customers"
       *     ]
       */
      tags?: string[];
      /** @description The SIM card individual data limit configuration. */
      readonly data_limit?: {
        /**
         * Format: decimal
         * @example 2048.0
         */
        amount?: string;
        /**
         * @example MB
         * @enum {string}
         */
        unit?: 'MB' | 'GB';
      };
      /** @description The SIM card consumption so far in the current billing cycle. */
      readonly current_billing_period_consumed_data?: {
        /**
         * Format: decimal
         * @example 2049.0
         */
        amount?: string;
        /**
         * @default MB
         * @example MB
         */
        unit: string;
      };
      /**
       * @description Indicate whether the SIM card has any pending (in-progress) actions.
       * @default false
       * @example true
       */
      readonly actions_in_progress: boolean;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /**
     * OTAUpdate
     * @description This object represents an Over the Air (OTA) update request. It allows tracking the current status of a operation that apply settings in a particular SIM card. <br/><br/>
     */
    SimplifiedOTAUpdate: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /** @example ota_update */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description The identification UUID of the related SIM card resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_id?: string;
      /**
       * @description Represents the type of the operation requested. This will relate directly to the source of the request.
       * @example sim_card_network_preferences
       * @enum {string}
       */
      type?: 'sim_card_network_preferences';
      /**
       * @example in-progress
       * @enum {string}
       */
      status?: 'in-progress' | 'completed' | 'failed';
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
    };
    /**
     * Global Outbound Channels Details for a Managed Account
     * @example {
     *       "channel_limit": 30,
     *       "email": "allocate_demo@customer.com",
     *       "id": "096abcde-1122-3344-ab77-ff0123456789",
     *       "manager_account_id": "beeabcde-1122-3344-ab77-ff0123456789",
     *       "record_type": "managed_account_global_outbound_settings"
     *     }
     */
    SingleManagedAccountGlobalOutboundChannels: {
      /**
       * @description Integer value that indicates the number of allocatable global outbound channels that are allocated to the managed account. If the value is 0 then the account will have no usable channels and will not be able to perform outbound calling.
       * @example 30
       */
      channel_limit?: number;
      /**
       * @description The email of the managed account.
       * @example customer@example.org
       */
      email?: string;
      /**
       * @description The user ID of the managed account.
       * @example 096abcde-1122-3344-ab77-ff0123456789
       */
      id?: string;
      /**
       * @description The user ID of the manager of the account.
       * @example beeabcde-1122-3344-ab77-ff0123456789
       */
      manager_account_id?: string;
      /**
       * @description The name of the type of data in the response.
       * @example managed_account_global_outbound_settings
       */
      record_type?: string;
    };
    /**
     * SIP Header
     * @example {
     *       "name": "User-to-User",
     *       "value": "value"
     *     }
     */
    SipHeader: {
      /**
       * @description The name of the header to add.
       * @example User-to-User
       * @enum {string}
       */
      name: 'User-to-User';
      /**
       * @description The value of the header.
       * @example value
       */
      value: string;
    };
    /** @example {
     *       "id": "1293384261075731499",
     *       "record_type": "phone_number",
     *       "phone_number": "+19705555098",
     *       "status": "active",
     *       "external_pin": "1234",
     *       "connection_id": "1293384261075731499",
     *       "customer_reference": "customer-reference",
     *       "billing_group_id": "86f58db9-0fe3-4adc-9d1f-46e66e6e9323",
     *       "emergency_enabled": true,
     *       "emergency_address_id": "1315261609962112019",
     *       "call_forwarding_enabled": true,
     *       "cnam_listing_enabled": true,
     *       "caller_id_name_enabled": true,
     *       "call_recording_enabled": true,
     *       "t38_fax_gateway_enabled": true,
     *       "number_level_routing": "disabled",
     *       "phone_number_type": "local",
     *       "inbound_call_screening": "disabled",
     *       "purchased_at": "2019-10-23T18:10:00.000Z",
     *       "created_at": "2019-10-23T18:10:00.000Z",
     *       "updated_at": "2019-10-24T18:10:00.000Z",
     *       "hd_voice_enabled": true
     *     } */
    SlimPhoneNumberDetailed: {
      id?: components['schemas']['IntId'];
      /**
       * @description Identifies the type of the resource.
       * @example phone_number_slim
       */
      readonly record_type?: string;
      /** @description The +E.164-formatted phone number associated with this record. */
      readonly phone_number?: string;
      /**
       * @description The phone number's current status.
       * @enum {string}
       */
      readonly status?:
        | 'purchase-pending'
        | 'purchase-failed'
        | 'port-pending'
        | 'port-failed'
        | 'active'
        | 'deleted'
        | 'emergency-only'
        | 'ported-out'
        | 'port-out-pending'
        | 'requirement-info-pending'
        | 'requirement-info-under-review'
        | 'requirement-info-exception'
        | 'provision-pending';
      /** @description If someone attempts to port your phone number away from Telnyx and your phone number has an external PIN set, Telnyx will attempt to verify that you provided the correct external PIN to the winning carrier. Note that not all carriers cooperate with this security mechanism. */
      external_pin?: string;
      /** @description Identifies the connection associated with the phone number. */
      connection_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @description Identifies the billing group associated with the phone number. */
      billing_group_id?: string;
      /** @description Indicates whether emergency services are enabled for this number. */
      readonly emergency_enabled?: boolean;
      /**
       * Format: int64
       * @description Identifies the emergency address associated with the phone number.
       */
      readonly emergency_address_id?: string;
      /**
       * @description Indicates if call forwarding will be enabled for this number if forwards_to and forwarding_type are filled in. Defaults to true for backwards compatibility with APIV1 use of numbers endpoints.
       * @default true
       */
      readonly call_forwarding_enabled: boolean;
      /** @description Indicates whether a CNAM listing is enabled for this number. */
      readonly cnam_listing_enabled?: boolean;
      /** @description Indicates whether caller ID is enabled for this number. */
      readonly caller_id_name_enabled?: boolean;
      /** @description Indicates whether call recording is enabled for this number. */
      readonly call_recording_enabled?: boolean;
      /** @description Indicates whether T38 Fax Gateway for inbound calls to this number. */
      readonly t38_fax_gateway_enabled?: boolean;
      /** @description ISO 8601 formatted date indicating when the resource was purchased. */
      readonly purchased_at?: string;
      /** @description ISO 8601 formatted date indicating when the resource was created. */
      readonly created_at?: string;
      /**
       * @description Deprecated field, the only value for this is 'disabled'. All routing for numbers should be configured via connection settings.
       * @default disabled
       * @enum {string}
       */
      number_level_routing: 'disabled';
      /**
       * @description The phone number's type.
       *     Note: For numbers purchased prior to July 2023 or when fetching a number's details immediately after a purchase completes, the legacy values `tollfree`, `shortcode` or `longcode` may be returned instead.
       * @enum {string}
       */
      readonly phone_number_type?:
        | 'local'
        | 'toll_free'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'landline'
        | 'tollfree'
        | 'shortcode'
        | 'longcode';
      /**
       * @description The inbound_call_screening setting is a phone number configuration option variable that allows users to configure their settings to block or flag fraudulent calls. It can be set to disabled, reject_calls, or flag_calls. This feature has an additional per-number monthly cost associated with it.
       * @default disabled
       * @enum {string}
       */
      inbound_call_screening: 'disabled' | 'reject_calls' | 'flag_calls';
    };
    /**
     * Sound modifications
     * @description Use this field to modify sound effects, for example adjust the pitch.
     * @example {
     *       "pitch": "0.8",
     *       "semitone": -2,
     *       "octaves": 0.1,
     *       "track": "both"
     *     }
     */
    SoundModifications: {
      /**
       * Format: double
       * @description Set the pitch directly, value should be > 0, default 1 (lower = lower tone)
       * @example 0.8
       */
      pitch?: number;
      /**
       * Format: double
       * @description Adjust the pitch in semitones, values should be between -14 and 14, default 0
       * @example -10
       */
      semitone?: number;
      /**
       * Format: double
       * @description Adjust the pitch in octaves, values should be between -1 and 1, default 0
       * @example -0.5
       */
      octaves?: number;
      /**
       * @description The track to which the sound modifications will be applied. Accepted values are `inbound` or `outbound`
       * @default outbound
       * @example inbound
       */
      track: string;
    };
    SourceResponse: {
      /**
       * @description A JSON Pointer [RFC6901] to the associated entity in the request document
       * @example /title
       */
      pointer?: string;
      /**
       * @description a string indicating which URI query parameter caused the error
       * @example metrics
       */
      parameter?: string;
    };
    /**
     * Speak Request
     * @example {
     *       "payload": "Say this on the call",
     *       "payload_type": "text",
     *       "service_level": "basic",
     *       "stop": "current",
     *       "voice": "female",
     *       "language": "arb",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    SpeakRequest: {
      /**
       * @description The text or SSML to be converted into speech. There is a 3,000 character limit.
       * @example Say this on the call
       */
      payload: string;
      /**
       * @description The type of the provided payload. The payload can either be plain text, or Speech Synthesis Markup Language (SSML).
       * @default text
       * @example ssml
       * @enum {string}
       */
      payload_type: 'text' | 'ssml';
      /**
       * @description This parameter impacts speech quality, language options and payload types. When using `basic`, only the `en-US` language and payload type `text` are allowed.
       * @default premium
       * @example premium
       * @enum {string}
       */
      service_level: 'basic' | 'premium';
      /**
       * @description When specified, it stops the current audio being played. Specify `current` to stop the current audio being played, and to play the next file in the queue. Specify `all` to stop the current audio file being played and to also clear all audio files from the queue.
       * @example current
       */
      stop?: string;
      /**
       * @description The gender of the voice used to speak back the text or the specific Amazon Polly voice to be used in the form of `Polly.<voice>`, e.g. `Polly.Brian`. All standard Amazon Polly voices are supported.
       * @example female
       * @enum {string}
       */
      voice: 'male' | 'female';
      /**
       * @description The language you want spoken. This parameter is ignored when a `Polly.*` voice is specified.
       * @example en-US
       * @enum {string}
       */
      language?:
        | 'arb'
        | 'cmn-CN'
        | 'cy-GB'
        | 'da-DK'
        | 'de-DE'
        | 'en-AU'
        | 'en-GB'
        | 'en-GB-WLS'
        | 'en-IN'
        | 'en-US'
        | 'es-ES'
        | 'es-MX'
        | 'es-US'
        | 'fr-CA'
        | 'fr-FR'
        | 'hi-IN'
        | 'is-IS'
        | 'it-IT'
        | 'ja-JP'
        | 'ko-KR'
        | 'nb-NO'
        | 'nl-NL'
        | 'pl-PL'
        | 'pt-BR'
        | 'pt-PT'
        | 'ro-RO'
        | 'ru-RU'
        | 'sv-SE'
        | 'tr-TR';
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Start Conference Recording Request
     * @example {
     *       "format": "wav",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "play_beep": true
     *     }
     */
    StartConferenceRecordingRequest: {
      /**
       * @description The audio file format used when storing the conference recording. Can be either `mp3` or `wav`.
       * @example mp3
       * @enum {string}
       */
      format: 'wav' | 'mp3';
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `conference_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description If enabled, a beep sound will be played at the start of a recording.
       * @example true
       */
      play_beep?: boolean;
      /**
       * @description When set to `trim-silence`, silence will be removed from the beginning and end of the recording.
       * @example trim-silence
       * @enum {string}
       */
      trim?: 'trim-silence';
      /**
       * @description The custom recording file name to be used instead of the default `call_leg_id`. Telnyx will still add a Unix timestamp suffix.
       * @example my_recording_file_name
       */
      custom_file_name?: string;
    };
    /**
     * Start Forking Request
     * @example {
     *       "target": "udp:192.0.2.1:9000",
     *       "rx": "udp:192.0.2.1:9000",
     *       "tx": "udp:192.0.2.1:9001",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    StartForkingRequest: {
      /**
       * @description The network target, <udp:ip_address:port>, where the call's RTP media packets should be forwarded. Both incoming and outgoing media packets will be delivered to the specified target, and information about the stream will be included in the encapsulation protocol header, including the direction (0 = inbound; 1 = outbound), leg (0 = A-leg; 1 = B-leg), and call_leg_id.
       * @example udp:192.0.2.1:9000
       */
      target?: string;
      /**
       * @description The network target, <udp:ip_address:port>, where the call's incoming RTP media packets should be forwarded.
       * @example udp:192.0.2.1:9000
       */
      rx?: string;
      /**
       * @description Optionally specify a media type to stream. If `decrypted` selected, Telnyx will decrypt incoming SIP media before forking to the target. `rx` and `tx` are required fields if `decrypted` selected.
       * @default raw
       * @example decrypted
       * @enum {string}
       */
      stream_type: 'raw' | 'decrypted';
      /**
       * @description The network target, <udp:ip_address:port>, where the call's outgoing RTP media packets should be forwarded.
       * @example udp:192.0.2.1:9001
       */
      tx?: string;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Start Recording Request
     * @example {
     *       "format": "wav",
     *       "channels": "single",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "play_beep": true,
     *       "max_length": 0,
     *       "timeout_secs": 0
     *     }
     */
    StartRecordingRequest: {
      /**
       * @description The audio file format used when storing the call recording. Can be either `mp3` or `wav`.
       * @example mp3
       * @enum {string}
       */
      format: 'wav' | 'mp3';
      /**
       * @description When `dual`, final audio file will be stereo recorded with the first leg on channel A, and the rest on channel B.
       * @example single
       * @enum {string}
       */
      channels: 'single' | 'dual';
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description If enabled, a beep sound will be played at the start of a recording.
       * @example true
       */
      play_beep?: boolean;
      /**
       * Format: int32
       * @description Defines the maximum length for the recording in seconds. The minimum value is 0. The maximum value is 14400. The default value is 0 (infinite)
       * @default 0
       * @example 100
       */
      max_length: number;
      /**
       * Format: int32
       * @description The number of seconds that Telnyx will wait for the recording to be stopped if silence is detected. The timer only starts when the speech is detected. Please note that call transcription is used to detect silence and the related charge will be applied. The minimum value is 0. The default value is 0 (infinite)
       * @default 0
       * @example 100
       */
      timeout_secs: number;
      /**
       * @description The audio track to be recorded. Can be either `both`, `inbound` or `outbound`. If only single track is specified (`inbound`, `outbound`), `channels` configuration is ignored and it will be recorded as mono (single channel).
       * @default both
       * @example outbound
       * @enum {string}
       */
      recording_track: 'both' | 'inbound' | 'outbound';
      /**
       * @description When set to `trim-silence`, silence will be removed from the beginning and end of the recording.
       * @example trim-silence
       * @enum {string}
       */
      trim?: 'trim-silence';
      /**
       * @description The custom recording file name to be used instead of the default `call_leg_id`. Telnyx will still add a Unix timestamp suffix.
       * @example my_recording_file_name
       */
      custom_file_name?: string;
    };
    /**
     * Start Streaming Request
     * @example {
     *       "stream_url": "wss://www.example.com/websocket",
     *       "stream_track": "both_tracks",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "enable_dialogflow": false,
     *       "dialogflow_config": {
     *         "analyze_sentiment": false,
     *         "partial_automated_agent_reply": false
     *       }
     *     }
     */
    StartStreamingRequest: {
      /**
       * @description The destination WebSocket address where the stream is going to be delivered.
       * @example wss://www.example.com/websocket
       */
      stream_url?: string;
      /**
       * @description Specifies which track should be streamed.
       * @default inbound_track
       * @example both_tracks
       * @enum {string}
       */
      stream_track: 'inbound_track' | 'outbound_track' | 'both_tracks';
      stream_bidirectional_mode?: components['schemas']['StreamBidirectionalMode'];
      stream_bidirectional_codec?: components['schemas']['StreamBidirectionalCodec'];
      /**
       * @description Enables Dialogflow for the current call. The default value is false.
       * @default false
       * @example true
       */
      enable_dialogflow: boolean;
      dialogflow_config?: components['schemas']['DialogflowConfig'];
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Status
     * @description An enumeration.
     * @enum {unknown}
     */
    Status: 'ACTIVE' | 'EXPIRED';
    /**
     * StockExchange
     * @description (Required for public company) stock exchange.
     * @example NASDAQ
     * @enum {unknown}
     */
    StockExchange:
      | 'NONE'
      | 'NASDAQ'
      | 'NYSE'
      | 'AMEX'
      | 'AMX'
      | 'ASX'
      | 'B3'
      | 'BME'
      | 'BSE'
      | 'FRA'
      | 'ICEX'
      | 'JPX'
      | 'JSE'
      | 'KRX'
      | 'LON'
      | 'NSE'
      | 'OMX'
      | 'SEHK'
      | 'SSE'
      | 'STO'
      | 'SWX'
      | 'SZSE'
      | 'TSX'
      | 'TWSE'
      | 'VSE';
    /**
     * Stop Forking Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    StopForkingRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Optionally specify a `stream_type`. This should match the `stream_type` that was used in `fork_start` command to properly stop the fork.
       * @default raw
       * @example decrypted
       * @enum {string}
       */
      stream_type: 'raw' | 'decrypted';
    };
    /**
     * Stop Gather Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    StopGatherRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Stop Recording Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    StopRecordingRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Stop Streaming Request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "stream_id": "1edb94f9-7ef0-4150-b502-e0ebadfd9491"
     *     }
     */
    StopStreamingRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * Format: uuid
       * @description Identifies the stream. If the `stream_id` is not provided the command stops all streams associated with a given `call_control_id`.
       * @example 1edb94f9-7ef0-4150-b502-e0ebadfd9491
       */
      stream_id?: string;
    };
    /**
     * @description Should fax media be stored on temporary URL. It does not support media_name, they can't be submitted together.
     * @default false
     */
    StoreMedia: boolean;
    /**
     * @description Should fax preview be stored on temporary URL.
     * @default false
     */
    StorePreview: boolean;
    /**
     * @description Should fax media be stored on temporary URL. It does not support media_name, they can't be submitted together.
     * @default false
     */
    StoredMedia: boolean;
    /**
     * Stream Bidirectional Codec
     * @description Indicates codec for bidirectional streaming RTP payloads. Used only with stream_bidirectional_mode=rtp. Case sensitive.
     * @default PCMU
     * @example G722
     * @enum {string}
     */
    StreamBidirectionalCodec: 'PCMU' | 'PCMA' | 'G722';
    /**
     * Stream Bidirectional Mode
     * @description Configures method of bidirectional streaming (mp3, rtp).
     * @default mp3
     * @example rtp
     * @enum {string}
     */
    StreamBidirectionalMode: 'mp3' | 'rtp';
    /**
     * @description The user specified name of Stream.
     * @example My stream
     */
    StreamName: string;
    /**
     * @description The status of the Stream you wish to update.
     * @default stopped
     * @example stopped
     * @enum {string}
     */
    StreamStatus: 'stopped';
    /**
     * @description Tracks to be included in the stream
     * @default inbound_track
     * @example both_tracks
     * @enum {string}
     */
    StreamTrack: 'inbound_track' | 'outbound_track' | 'both_tracks';
    SubNumberOrder: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      readonly id?: string;
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c293
       */
      readonly order_request_id?: string;
      /** @example US */
      readonly country_code?: string;
      /**
       * @example local
       * @enum {string}
       */
      phone_number_type?:
        | 'local'
        | 'toll_free'
        | 'mobile'
        | 'national'
        | 'shared_cost'
        | 'landline';
      /**
       * Format: uuid
       * @example d70873cd-7c98-401a-81b6-b1ae08246995
       */
      user_id?: string;
      regulatory_requirements?: components['schemas']['SubNumberOrderRegulatoryRequirement'][];
      /** @example sub_number_order */
      readonly record_type?: string;
      /**
       * @description The count of phone numbers in the number order.
       * @example 1
       */
      readonly phone_numbers_count?: number;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order was created.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string for when the number order was updated.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly updated_at?: string;
      /**
       * @description True if all requirements are met for every phone number, false otherwise.
       * @example true
       */
      readonly requirements_met?: boolean;
      /**
       * @description The status of the order.
       * @enum {string}
       */
      readonly status?: 'pending' | 'success' | 'failure';
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /**
       * @description True if the sub number order is a block sub number order
       * @example false
       */
      readonly is_block_sub_number_order?: boolean;
    };
    SubNumberOrderRegulatoryRequirement: {
      /** @example phone_number_regulatory_requirement */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Unique id for a requirement.
       * @example 8ffb3622-7c6b-4ccc-b65f-7a3dc0099576
       */
      requirement_id?: string;
      /**
       * @example address
       * @enum {string}
       */
      readonly field_type?: 'textual' | 'datetime' | 'address' | 'document';
    };
    SubNumberOrderRegulatoryRequirementWithValue: {
      /** @example phone_number_regulatory_requirement */
      readonly record_type?: string;
      /**
       * Format: uuid
       * @description Unique id for a requirement.
       * @example 8ffb3622-7c6b-4ccc-b65f-7a3dc0099576
       */
      requirement_id?: string;
      /**
       * @example address
       * @enum {string}
       */
      readonly field_type?: 'textual' | 'datetime' | 'address' | 'document';
      /**
       * @description The value of the requirement, this could be an id to a resource or a string value.
       * @example 45f45a04-b4be-4592-95b1-9306b9db2b21
       */
      field_value?: string;
    };
    /** SummaryRequest */
    SummaryRequest: {
      bucket: string;
      filename: string;
    };
    /** SummaryResponse */
    SummaryResponse: {
      /** Summary */
      summary: string;
    };
    /** SummaryResponseData */
    SummaryResponseData: {
      data: components['schemas']['SummaryResponse'];
    };
    /**
     * SupportedEmbeddingLoaders
     * @description Supported types of custom document loaders for embeddings.
     * @enum {string}
     */
    SupportedEmbeddingLoaders: 'default' | 'intercom';
    /**
     * SupportedEmbeddingModels
     * @description Supported models to vectorize and embed documents.
     * @enum {string}
     */
    SupportedEmbeddingModels:
      | 'thenlper/gte-large'
      | 'intfloat/multilingual-e5-large'
      | 'sentence-transformers/all-mpnet-base-v2';
    /**
     * @description The flag to disable the T.38 protocol.
     * @default true
     */
    T38Enabled: boolean;
    /**
     * PhoneNumber
     * @description A phone number
     */
    TFPhoneNumber: {
      /** Phonenumber */
      phoneNumber: string;
    };
    /**
     * VerificationRequest
     * @description The body of a tollfree verification request
     */
    TFVerificationRequest: {
      /**
       * Businessname
       * @example Telnyx LLC
       */
      businessName: string;
      /**
       * Corporatewebsite
       * @example http://example.com
       */
      corporateWebsite: string;
      /**
       * Businessaddr1
       * @example 311 W Superior St
       */
      businessAddr1: string;
      /**
       * Businessaddr2
       * @example 121 W Superior St
       */
      businessAddr2?: string;
      /**
       * Businesscity
       * @example Chicago
       */
      businessCity: string;
      /**
       * Businessstate
       * @example Illinois
       */
      businessState: string;
      /**
       * Businesszip
       * @example 60654
       */
      businessZip: string;
      /**
       * Businesscontactfirstname
       * @example John
       */
      businessContactFirstName: string;
      /**
       * Businesscontactlastname
       * @example Doe
       */
      businessContactLastName: string;
      /**
       * Businesscontactemail
       * @example email@example.com
       */
      businessContactEmail: string;
      /**
       * Businesscontactphone
       * @example +18005550100
       */
      businessContactPhone: string;
      /**
       * @description One of the following exact values: 10; 100; 1,000; 10,000; 100,000; 250,000; 500,000; 750,000; 1,000,000; 5,000,000; 10,000,000+
       * @example 100,000
       */
      messageVolume: components['schemas']['Volume'];
      /**
       * Phonenumbers
       * @example [
       *       {
       *         "phoneNumber": "+18773554398"
       *       },
       *       {
       *         "phoneNumber": "+18773554399"
       *       }
       *     ]
       */
      phoneNumbers: components['schemas']['TFPhoneNumber'][];
      /** @example 2FA */
      useCase: components['schemas']['UseCaseCategories'];
      /**
       * Usecasesummary
       * @example This is a use case where Telnyx sends out 2FA codes to portal users to verify their identity in order to sign into the portal
       */
      useCaseSummary: string;
      /**
       * Productionmessagecontent
       * @example Your Telnyx OTP is XXXX
       */
      productionMessageContent: string;
      /**
       * Optinworkflow
       * @example User signs into the Telnyx portal, enters a number and is prompted to select whether they want to use 2FA verification for security purposes. If they've opted in a confirmation message is sent out to the handset
       */
      optInWorkflow: string;
      /**
       * Optinworkflowimageurls
       * @example [
       *       {
       *         "url": "https://telnyx.com/sign-up"
       *       },
       *       {
       *         "url": "https://telnyx.com/company/data-privacy"
       *       }
       *     ]
       */
      optInWorkflowImageURLs: components['schemas']['Url'][];
      /**
       * Additionalinformation
       * @example This is for security purposes, blah blah blah
       */
      additionalInformation: string;
      /**
       * Isvreseller
       * @example Yes
       */
      isvReseller: string;
      /**
       * Webhookurl
       * @example http://example-webhook.com
       */
      webhookUrl?: string;
    };
    /**
     * VerificationStatus
     * @description Tollfree verification status
     * @enum {string}
     */
    TFVerificationStatus:
      | 'Verified'
      | 'Rejected'
      | 'Waiting For Vendor'
      | 'Waiting For Customer'
      | 'In Progress';
    /**
     * TaskStatus
     * @description An enumeration.
     * @enum {string}
     */
    TaskStatus: 'pending' | 'processing' | 'completed' | 'failed';
    /** TaskStatusResponse */
    TaskStatusResponse: {
      data: {
        /**
         * Task ID
         * Format: uuid
         */
        task_id?: string;
        /** Task Name */
        task_name?: string;
        status?: components['schemas']['BackgroundTaskStatus'];
        /** Created At */
        created_at?: string;
        /** Finished At */
        finished_at?: string;
      };
    };
    /**
     * On-demand Credential
     * @example {
     *       "id": "c215ade3-0d39-418e-94be-c5f780760199",
     *       "record_type": "credential",
     *       "name": "2020-06-18 21:32:38.917732Z",
     *       "expired": "false",
     *       "user_id": "user-id",
     *       "resource_id": "connection:804252963366242252",
     *       "sip_password": "a92dbcfb60184a8cb330b0acb2f7617b",
     *       "sip_username": "gencrednCvHU5IYpSBPPsXI2iQsDX",
     *       "created_at": "2020-06-18T21:32:38",
     *       "expires_at": "2042-06-18T21:32:38",
     *       "updated_at": "2020-06-18T21:32:38.000Z"
     *     }
     */
    TelephonyCredential: {
      /**
       * Format: string
       * @description Identifies the resource.
       * @example c215ade3-0d39-418e-94be-c5f780760199
       */
      id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example credential
       */
      record_type?: string;
      name?: string;
      /**
       * @description Identifies the resource this credential is associated with.
       * @example connection:1234567890
       */
      resource_id?: string;
      /** @description Defaults to false */
      expired?: boolean;
      /**
       * @description The randomly generated SIP username for the credential.
       * @example gencrednCvHU5IYpSBPPsXI2iQsDX
       */
      sip_username?: string;
      /**
       * @description The randomly generated SIP password for the credential.
       * @example a92dbcfb60184a8cb330b0acb2f7617b
       */
      sip_password?: string;
      /**
       * @description ISO-8601 formatted date indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      created_at?: string;
      /**
       * @description ISO-8601 formatted date indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      updated_at?: string;
      /**
       * @description ISO-8601 formatted date indicating when the resource will expire.
       * @example 2018-02-02T22:25:27.521Z
       */
      expires_at?: string;
    };
    /**
     * TelephonyCredentialCreateRequest
     * @example {
     *       "name": "My-new-credential",
     *       "connection_id": "1234567890"
     *     }
     */
    TelephonyCredentialCreateRequest: {
      name?: string;
      /**
       * @description Tags a credential to filter for bulk operations. A single tag can hold at maximum 1000 credentials.
       * @example some_tag
       */
      tag?: string;
      /**
       * @description Identifies the Credential Connection this credential is associated with.
       * @example 1234567890
       */
      connection_id: string;
      /**
       * @description ISO-8601 formatted date indicating when the credential will expire.
       * @example 2018-02-02T22:25:27.521Z
       */
      expires_at?: string;
    };
    /**
     * TelephonyCredentialUpdateRequest
     * @example {
     *       "name": "My-new-updated-credential",
     *       "connection_id": "987654321"
     *     }
     */
    TelephonyCredentialUpdateRequest: {
      name?: string;
      /**
       * @description Tags a credential to filter for bulk operations. A single tag can hold at maximum 1000 credentials.
       * @example some_tag
       */
      tag?: string;
      /**
       * @description Identifies the Credential Connection this credential is associated with.
       * @example 987654321
       */
      connection_id?: string;
      /**
       * @description ISO-8601 formatted date indicating when the credential will expire.
       * @example 2018-02-02T22:25:27.521Z
       */
      expires_at?: string;
    };
    /**
     * TelnyxBrand
     * @description Telnyx-specific extensions to The Campaign Registry's `Brand` type
     */
    TelnyxBrand: {
      /** @description Entity type behind the brand. This is the form of business establishment. */
      entityType: components['schemas']['EntityType'];
      /**
       * Cspid
       * @description Unique identifier assigned to the csp by the registry.
       */
      cspId?: string;
      /**
       * Brandid
       * @description Unique identifier assigned to the brand.
       * @example 4b20017f-8da9-a992-a6c0-683072fb7729
       */
      brandId?: string;
      /**
       * TcrBrandid
       * @description Unique identifier assigned to the brand by the registry.
       * @example BBRAND1
       */
      tcrBrandId?: string;
      /**
       * Displayname
       * @description Display or marketing name of the brand.
       * @example ABC Mobile
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example ABC Inc.
       */
      companyName?: string;
      /**
       * Firstname
       * @description First name of business contact.
       * @example John
       */
      firstName?: string;
      /**
       * Lastname
       * @description Last name of business contact.
       * @example Smith
       */
      lastName?: string;
      /**
       * Ein
       * @description (Required for Non-profit) Government assigned corporate tax ID. EIN is 9-digits in U.S.
       * @example 111111111
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +12024567890
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example New York
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example NY
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 10001
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example ABC
       */
      stockSymbol?: string;
      /**
       * @description (Required for public company) stock exchange.
       * @example NASDAQ
       */
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example http://www.abcmobile.com
       */
      website?: string;
      /** @description Brand relationship to the CSP */
      brandRelationship: components['schemas']['BrandRelationship'];
      /**
       * Vertical
       * @description Vertical or industry segment of the brand.
       */
      vertical: string;
      /**
       * Altbusinessid
       * @description Alternate business identifier such as DUNS, LEI, or GIIN
       */
      altBusinessId?: string;
      altBusinessIdType?: components['schemas']['AltBusinessIdType'];
      /**
       * Universalein
       * @description Universal EIN of Brand, Read Only.
       */
      universalEin?: string;
      /**
       * Referenceid
       * @description Unique identifier Telnyx assigned to the brand - the brandId
       */
      referenceId?: string;
      identityStatus?: components['schemas']['BrandIdentityStatus'];
      optionalAttributes?: components['schemas']['BrandOptionalAttributes'];
      /**
       * Mock
       * @description Mock brand for testing purposes
       * @default false
       */
      mock: boolean;
      /**
       * Mobilephone
       * @description Valid mobile phone number in e.164 international format.
       * @example +12024567890
       */
      mobilePhone?: string;
      /**
       * Isreseller
       * @description Indicates whether this brand is known to be a reseller
       * @default false
       */
      isReseller: boolean;
      /**
       * WebhookURL
       * @description Webhook to which brand status updates are sent.
       * @example https://webhook.com/67ea78a8-9f32-4d04-b62d-f9502e8e5f93
       */
      webhookURL?: string;
      /**
       * BusinessContactEmail
       * @description Business contact email.
       *
       *     Required if `entityType` is `PUBLIC_PROFIT`.
       * @example name@example.com
       */
      businessContactEmail?: string;
      /**
       * WebhookFailoverURL
       * @description Failover webhook to which brand status updates are sent.
       */
      webhookFailoverURL?: string;
      /**
       * status
       * @description Status of the brand
       * @enum {unknown}
       */
      status?: 'OK' | 'REGISTRATION_PENDING' | 'REGISTRATION_FAILED';
      /**
       * failureReasons
       * @description Failure reasons for brand
       */
      failureReasons?: unknown;
    };
    TelnyxBrandWithCampaignsCount: components['schemas']['TelnyxBrand'] & {
      /**
       * AssignedCampaignsCount
       * @description Number of campaigns associated with the brand
       * @example 3
       */
      assignedCampaignsCount?: number;
    };
    TelnyxCampaignWithAssignedCount_CSP: components['schemas']['TelnyxCampaign_CSP'] & {
      /**
       * AssignedPhoneNumbersCount
       * @description Number of phone numbers associated with the campaign
       * @example 3
       */
      assignedPhoneNumbersCount?: number;
    };
    /**
     * TelnyxCampaign_CSP
     * @description Campaign is generated by the 10DLC registry once the corresponding campaign request is approved. Each campaign is assigned a unique identifier - **campaignId**. Once a campaign is activated, limited information is published to the NetNumber OSR service for consumption by members of the ecosystem. When a campaign is suspended(reversible) or expired(non-reversible), campaign data is deleted from the OSR service. Most attributes of campaignare immutable, including **usecase**, **vertical**, **brandId** and **cspId**.
     */
    TelnyxCampaign_CSP: {
      /**
       * Affiliatemarketing
       * @deprecated
       * @description Does message content controlled by affiliate marketing other than the brand?
       *
       *     This field is deprecated.
       */
      affiliateMarketing?: boolean;
      /**
       * Agegated
       * @description Age gated content in campaign.
       */
      ageGated?: boolean;
      /**
       * Autorenewal
       * @description Campaign subscription auto-renewal status.
       */
      autoRenewal?: boolean;
      /**
       * Billeddate
       * @description Campaign recent billed date.
       */
      billedDate?: string;
      /**
       * Brandid
       * @description Unique identifier assigned to the brand.
       * @example d2ca9d69-641b-4131-83fa-5d0744f4c8a9
       */
      brandId: string;
      /**
       * Campaignid
       * @description Unique identifier for a campaign.
       * @example 823d6b1a-6ed6-41a3-9c50-c8ff41b682ba
       */
      campaignId: string;
      /**
       * TcrBrandid
       * @description Unique identifier assigned to the brand by the registry.
       * @example BBRAND1
       */
      tcrBrandId?: string;
      /**
       * TcrCampaignid
       * @description Unique identifier assigned to the campaign by the registry.
       * @example CCAMP1
       */
      tcrCampaignId?: string;
      /**
       * Createdate
       * @description Unix timestamp when campaign was created.
       */
      createDate?: string;
      /**
       * Cspid
       * @description Alphanumeric identifier of the CSP associated with this campaign.
       */
      cspId: string;
      /**
       * Description
       * @description Summary description of this campaign.
       */
      description: string;
      /** Directlending */
      directLending?: boolean;
      /**
       * Embeddedlink
       * @description Does message generated by the campaign include URL link in SMS?
       */
      embeddedLink?: boolean;
      /**
       * Embeddedphone
       * @description Does message generated by the campaign include phone number in SMS?
       */
      embeddedPhone?: boolean;
      /**
       * Helpkeywords
       * @description Subscriber help keywords. Multiple keywords are comma separated without space.
       */
      helpKeywords?: string;
      /**
       * Helpmessage
       * @description Help message of the campaign.
       */
      helpMessage?: string;
      /**
       * Messageflow
       * @description Message flow description.
       */
      messageFlow?: string;
      /**
       * Mock
       * @description Campaign created from mock brand. Mocked campaign cannot be shared with an upstream CNP.
       */
      mock: boolean;
      /**
       * Nextrenewalorexpirationdate
       * @description When the campaign would be due for its next renew/bill date.
       */
      nextRenewalOrExpirationDate?: string;
      /**
       * Numberpool
       * @description Does campaign utilize pool of phone numbers?
       */
      numberPool?: boolean;
      /**
       * Optinkeywords
       * @description Subscriber opt-in keywords. Multiple keywords are comma separated without space.
       */
      optinKeywords?: string;
      /**
       * Optinmessage
       * @description Subscriber opt-in message.
       */
      optinMessage?: string;
      /**
       * Optoutkeywords
       * @description Subscriber opt-out keywords. Multiple keywords are comma separated without space.
       */
      optoutKeywords?: string;
      /**
       * Optoutmessage
       * @description Subscriber opt-out message.
       */
      optoutMessage?: string;
      /**
       * Referenceid
       * @description Caller supplied campaign reference ID. If supplied, the value must be unique across all submitted campaigns. Can be used to prevent duplicate campaign registrations.
       */
      referenceId?: string;
      /**
       * Resellerid
       * @description Alphanumeric identifier of the reseller that you want to associate with this campaign.
       */
      resellerId?: string;
      /**
       * Sample1
       * @description Message sample. Some campaign tiers require 1 or more message samples.
       */
      sample1?: string;
      /**
       * Sample2
       * @description Message sample. Some campaign tiers require 2 or more message samples.
       */
      sample2?: string;
      /**
       * Sample3
       * @description Message sample. Some campaign tiers require 3 or more message samples.
       */
      sample3?: string;
      /**
       * Sample4
       * @description Message sample. Some campaign tiers require 4 or more message samples.
       */
      sample4?: string;
      /**
       * Sample5
       * @description Message sample. Some campaign tiers require 5 or more message samples.
       */
      sample5?: string;
      /**
       * Status
       * @description Current campaign status. Possible values: ACTIVE, EXPIRED. A newly created campaign defaults to ACTIVE status.
       */
      status?: string;
      /**
       * Subusecases
       * @description Campaign sub-usecases. Must be of defined valid sub-usecase types. Use `/registry/enum/usecase` operation to retrieve list of valid sub-usecases
       */
      subUsecases: string[];
      /**
       * Subscriberhelp
       * @description Does campaign responds to help keyword(s)?
       */
      subscriberHelp?: boolean;
      /**
       * Subscriberoptin
       * @description Does campaign require subscriber to opt-in before SMS is sent to subscriber?
       */
      subscriberOptin?: boolean;
      /**
       * Subscriberoptout
       * @description Does campaign support subscriber opt-out keyword(s)?
       */
      subscriberOptout?: boolean;
      /**
       * Termsandconditions
       * @description Is terms & conditions accepted?
       */
      termsAndConditions: boolean;
      /**
       * Usecase
       * @description Campaign usecase. Must be of defined valid types. Use `/registry/enum/usecase` operation to retrieve usecases available for given brand.
       */
      usecase: string;
      /**
       * Vertical
       * @deprecated
       * @description Business/industry segment of this campaign (Deprecated). Must be of defined valid types. Use `/registry/enum/vertical` operation to retrieve verticals available for given brand, vertical combination.
       *
       *     This field is deprecated.
       */
      vertical?: string;
      /**
       * WebhookURL
       * @description Webhook to which campaign status updates are sent.
       * @example https://example.com/webhook
       */
      webhookURL?: string;
      /**
       * WebhookFailoverURL
       * @description Failover webhook to which campaign status updates are sent.
       * @example https://example.com/failover-webhook
       */
      webhookFailoverURL?: string;
      /**
       * IsTMobileRegistered
       * @description Indicates whether the campaign is registered with T-Mobile.
       */
      isTMobileRegistered?: boolean;
      /**
       * isTMobileSuspended
       * @description Indicates whether the campaign is suspended with T-Mobile.
       */
      isTMobileSuspended?: boolean;
      /**
       * isTMobileNumberPoolingEnabled
       * @description Indicates whether the campaign has a T-Mobile number pool ID associated with it.
       */
      isTMobileNumberPoolingEnabled?: boolean;
      /**
       * failureReasons
       * @description Failure reasons if campaign submission failed
       */
      failureReasons?: unknown;
      /**
       * submissionStatus
       * @description Campaign submission status
       * @enum {unknown}
       */
      submissionStatus?: 'CREATED' | 'FAILED' | 'PENDING';
    };
    /**
     * Telnyx transcription engine list of languages
     * @description Language to use for speech recognition
     * @default en
     * @example en
     * @enum {string}
     */
    TelnyxTranscriptionLanguage:
      | 'en'
      | 'zh'
      | 'de'
      | 'es'
      | 'ru'
      | 'ko'
      | 'fr'
      | 'ja'
      | 'pt'
      | 'tr'
      | 'pl'
      | 'ca'
      | 'nl'
      | 'ar'
      | 'sv'
      | 'it'
      | 'id'
      | 'hi'
      | 'fi'
      | 'vi'
      | 'he'
      | 'uk'
      | 'el'
      | 'ms'
      | 'cs'
      | 'ro'
      | 'da'
      | 'hu'
      | 'ta'
      | 'no'
      | 'th'
      | 'ur'
      | 'hr'
      | 'bg'
      | 'lt'
      | 'la'
      | 'mi'
      | 'ml'
      | 'cy'
      | 'sk'
      | 'te'
      | 'fa'
      | 'lv'
      | 'bn'
      | 'sr'
      | 'az'
      | 'sl'
      | 'kn'
      | 'et'
      | 'mk'
      | 'br'
      | 'eu'
      | 'is'
      | 'hy'
      | 'ne'
      | 'mn'
      | 'bs'
      | 'kk'
      | 'sq'
      | 'sw'
      | 'gl'
      | 'mr'
      | 'pa'
      | 'si'
      | 'km'
      | 'sn'
      | 'yo'
      | 'so'
      | 'af'
      | 'oc'
      | 'ka'
      | 'be'
      | 'tg'
      | 'sd'
      | 'gu'
      | 'am'
      | 'yi'
      | 'lo'
      | 'uz'
      | 'fo'
      | 'ht'
      | 'ps'
      | 'tk'
      | 'nn'
      | 'mt'
      | 'sa'
      | 'lb'
      | 'my'
      | 'bo'
      | 'tl'
      | 'mg'
      | 'as'
      | 'tt'
      | 'haw'
      | 'ln'
      | 'ha'
      | 'ba'
      | 'jw'
      | 'su'
      | 'auto_detect';
    /** Telnyx Voice Settings */
    TelnyxVoiceSettings: {
      /**
       * Format: float
       * @description The voice speed to be used for the voice. The voice speed must be between 0.1 and 2.0. Default value is 1.0.
       * @default 1
       * @example 1
       */
      voice_speed: number;
    };
    /**
     * Texml Application
     * @example {
     *       "id": "1293384261075731499",
     *       "record_type": "texml_application",
     *       "active": false,
     *       "friendly_name": "call-router",
     *       "anchorsite_override": "Amsterdam, Netherlands",
     *       "dtmf_type": "Inband",
     *       "first_command_timeout": true,
     *       "first_command_timeout_secs": 10,
     *       "voice_url": "https://example.com",
     *       "voice_fallback_url": "https://fallback.example.com",
     *       "voice_method": "get",
     *       "status_callback": "https://example.com",
     *       "status_callback_method": "get",
     *       "inbound": {
     *         "channel_limit": 10,
     *         "shaken_stir_enabled": true,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       },
     *       "created_at": "2020-02-02T22:25:27.521Z",
     *       "updated_at": "2020-02-03T22:25:27.521Z"
     *     }
     */
    TexmlApplication: {
      id?: components['schemas']['IntId'];
      /**
       * @description Identifies the type of the resource.
       * @example texml_application
       */
      record_type?: string;
      friendly_name?: components['schemas']['ApplicationName'];
      active?: components['schemas']['ConnectionActive'];
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      dtmf_type?: components['schemas']['DtmfType'];
      first_command_timeout?: components['schemas']['FirstCommandTimeout'];
      first_command_timeout_secs?: components['schemas']['FirstCommandTimeoutSecs'];
      /**
       * Format: url
       * @description URL to which Telnyx will deliver your XML Translator webhooks.
       * @example https://example.com
       */
      voice_url?: string;
      /**
       * Format: url
       * @description URL to which Telnyx will deliver your XML Translator webhooks if we get an error response from your voice_url.
       * @default null
       * @example https://fallback.example.com
       */
      voice_fallback_url: string;
      /**
       * @description HTTP request method Telnyx will use to interact with your XML Translator webhooks. Either 'get' or 'post'.
       * @default post
       * @example get
       * @enum {string}
       */
      voice_method: 'get' | 'post';
      /**
       * Format: url
       * @description URL for Telnyx to send requests to containing information about call progress events.
       * @default null
       * @example https://example.com
       */
      status_callback: string;
      /**
       * @description HTTP request method Telnyx should use when requesting the status_callback URL.
       * @default post
       * @example get
       * @enum {string}
       */
      status_callback_method: 'get' | 'post';
      inbound?: {
        /**
         * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        /**
         * @description When enabled Telnyx will include Shaken/Stir data in the Webhook for new inbound calls.
         * @default false
         * @example false
         */
        shaken_stir_enabled: boolean;
        /**
         * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
         * @default null
         * @example example
         */
        sip_subdomain: string;
        /**
         * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
         * @default from_anyone
         * @example only_my_connections
         * @enum {string}
         */
        sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      };
      outbound?: {
        /**
         * @description When set, this will limit the total number of outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
      created_at?: components['schemas']['CreatedAt'];
      updated_at?: components['schemas']['UpdatedAt'];
    };
    /** Texml Create Call Recording Request Body */
    TexmlCreateCallRecordingRequestBody: {
      PlayBeep?: components['schemas']['PlayBeep'];
      RecordingStatusCallbackEvent?: components['schemas']['RecordingStatusCallbackEvent'];
      RecordingStatusCallback?: components['schemas']['TexmlStatusCallback'];
      RecordingStatusCallbackMethod?: components['schemas']['TexmlStatusCallbackMethod'];
      RecordingChannels?: components['schemas']['TexmlRecordingChannels'];
      RecordingTrack?: components['schemas']['RecordingTrack'];
    };
    /** Texml Create Call Recording Response Body */
    TexmlCreateCallRecordingResponseBody: {
      account_sid?: components['schemas']['AccountSid'];
      call_sid?: components['schemas']['CallControlId'];
      conference_sid?: components['schemas']['ConferenceSid'];
      channels?: components['schemas']['TwimlRecordingChannels'];
      date_created?: components['schemas']['DateTimeRFC2822'];
      date_updated?: components['schemas']['DateTimeRFC2822'];
      start_time?: components['schemas']['DateTimeRFC2822'];
      price?: components['schemas']['TexmlRecordingPrice'];
      price_unit?: components['schemas']['TexmlPriceUnit'];
      duration?: components['schemas']['TexmlRecordingDuration'];
      sid?: components['schemas']['TexmlSid'];
      source?: components['schemas']['RecordingSource'];
      error_code?: components['schemas']['TexmlErrorCode'];
      track?: components['schemas']['RecordingTrack'];
      /**
       * @description The relative URI for this recording resource.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls/v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA/Recordings/b08f0fa1-a32c-4218-b3b5-9cf78941ccac.json
       */
      uri?: string;
    };
    /** Texml Create Call Streaming Request Body */
    TexmlCreateCallStreamingRequestBody: {
      StatusCallback?: components['schemas']['TexmlStatusCallback'];
      StatusCallbackMethod?: components['schemas']['TexmlStatusCallbackMethod'];
      Track?: components['schemas']['StreamTrack'];
      Name?: components['schemas']['StreamName'];
    };
    /** Texml Create Call Streaming Response Body */
    TexmlCreateCallStreamingResponseBody: {
      account_sid?: components['schemas']['AccountSid'];
      call_sid?: components['schemas']['CallControlId'];
      sid?: components['schemas']['TexmlSid'];
      /**
       * @description The user specified name of Stream.
       * @example My stream
       */
      name?: string;
      /**
       * @description The status of the streaming.
       * @example in-progress
       * @enum {string}
       */
      status?: 'in-progress';
      date_updated?: components['schemas']['DateTimeRFC2822'];
      /**
       * @description The relative URI for this streaming resource.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls/v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA/Streams/b08f0fa1-a32c-4218-b3b5-9cf78941ccac.json
       */
      uri?: string;
    };
    /** @example null */
    TexmlErrorCode: string | null;
    /** Texml Get Call Recording Response Body */
    TexmlGetCallRecordingResponseBody: {
      account_sid?: components['schemas']['AccountSid'];
      call_sid?: components['schemas']['CallControlId'];
      conference_sid?: components['schemas']['ConferenceSid'];
      channels?: components['schemas']['TwimlRecordingChannels'];
      date_created?: components['schemas']['DateTimeRFC2822'];
      date_updated?: components['schemas']['DateTimeRFC2822'];
      start_time?: components['schemas']['DateTimeRFC2822'];
      duration?: components['schemas']['TexmlRecordingDuration'];
      sid?: components['schemas']['TexmlSid'];
      source?: components['schemas']['RecordingSource'];
      status?: components['schemas']['TexmlRecordingStatus'];
      error_code?: components['schemas']['TexmlErrorCode'];
      subresources_uris?: components['schemas']['TexmlRecordingSubresourcesUris'];
      /**
       * @description The relative URI for this recording resource.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings/b08f0fa1-a32c-4218-b3b5-9cf78941ccac.json
       */
      uri?: string;
      media_url?: components['schemas']['TexmlRecordingMediaUrl'];
    };
    /** Multiple recording resources */
    TexmlGetCallRecordingsResponseBody: {
      recordings?: components['schemas']['TexmlGetCallRecordingResponseBody'][];
      /**
       * @description The number of the last element on the page, zero-indexed.
       * @example 19
       */
      end?: number;
      /**
       * Format: uri
       * @description Relative uri to the first page of the query results
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings.json?Page=0&PageSize=1
       */
      first_page_uri?: string;
      /**
       * Format: uri
       * @description Relative uri to the previous page of the query results
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings.json?Page=0&PageSize=1
       */
      previous_page_uri?: string;
      /**
       * @description Relative uri to the next page of the query results
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls.json?Page=1&PageSize=1
       */
      next_page_uri?: string;
      /**
       * @description Current page number, zero-indexed.
       * @example 0
       */
      page?: number;
      /**
       * @description The number of items on the page
       * @example 20
       */
      page_size?: number;
      /**
       * @description The number of the first element on the page, zero-indexed.
       * @example 0
       */
      start?: number;
      /**
       * @description The URI of the current page.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings.json?Page=0&PageSize=1
       */
      uri?: string;
    };
    /**
     * @description The unit in which the price is given.
     * @example USD
     */
    TexmlPriceUnit: string | null;
    /**
     * @description When `dual`, final audio file has the first leg on channel A, and the rest on channel B. `single` mixes both tracks into a single channel.
     * @default dual
     * @example single
     * @enum {string}
     */
    TexmlRecordingChannels: 'single' | 'dual';
    /**
     * @description The duration of this recording, given in seconds.
     * @example 12
     */
    TexmlRecordingDuration: string | null;
    /**
     * Format: uri
     * @example http://recordings.com/mp3/filename.mp3
     */
    TexmlRecordingMediaUrl: string;
    /**
     * @description The price of this recording, the currency is specified in the price_unit field.
     * @example 0.10
     */
    TexmlRecordingPrice: string | null;
    /**
     * @example paused
     * @enum {string}
     */
    TexmlRecordingStatus: 'in-progress' | 'completed' | 'paused' | 'stopped';
    /**
     * Texml recording subresources uris
     * @description Subresources details for a recording if available.
     */
    TexmlRecordingSubresourcesUris: {
      /**
       * Format: uri
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Recordings/b08f0fa1-a32c-4218-b3b5-9cf78941ccac/Transcriptions.json
       */
      transcriptions?: string | null;
    };
    /** Texml Get Call Recording Transcription Response Body */
    TexmlRecordingTranscription: {
      account_sid?: components['schemas']['AccountSid'];
      call_sid?: components['schemas']['CallControlId'];
      /**
       * @description The version of the API that was used to make the request.
       * @example 2010-04-01
       */
      api_version?: string;
      date_created?: components['schemas']['DateTimeRFC2822'];
      date_updated?: components['schemas']['DateTimeRFC2822'];
      duration?: components['schemas']['TexmlRecordingDuration'];
      sid?: components['schemas']['TexmlSid'];
      recording_sid?: components['schemas']['TexmlSid'];
      /**
       * @description The status of the recording transcriptions. The transcription text will be available only when the status is completed.
       * @example completed
       * @enum {string}
       */
      status?: 'in-progress' | 'completed';
      /**
       * @description The recording's transcribed text
       * @example Good morning, how may I help you?
       */
      transcription_text?: string;
      /**
       * @description The relative URI for the recording transcription resource.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Transcriptions/b08f0fa1-a32c-4218-b3b5-9cf78941ccac.json
       */
      uri?: string;
    };
    /**
     * @description Identifier of a resource.
     * @example e9cea0be-7dbd-4b98-98b1-c0089d9d43b0
     */
    TexmlSid: string;
    /**
     * Format: uri
     * @description Url where status callbacks will be sent.
     * @example http://webhook.com/callback
     */
    TexmlStatusCallback: string;
    /**
     * @description HTTP method used to send status callbacks.
     * @default POST
     * @example GET
     * @enum {string}
     */
    TexmlStatusCallbackMethod: 'GET' | 'POST';
    /** Texml Create Call Recording Request Body */
    TexmlUpdateCallRecordingRequestBody: {
      /**
       * @example paused
       * @enum {string}
       */
      Status?: 'in-progress' | 'paused' | 'stopped';
    };
    /** Texml Update Call Streaming Request Body */
    TexmlUpdateCallStreamingRequestBody: {
      Status?: components['schemas']['StreamStatus'];
    };
    /** Texml Update Call Streaming Response Body */
    TexmlUpdateCallStreamingResponseBody: {
      account_sid?: components['schemas']['AccountSid'];
      call_sid?: components['schemas']['CallControlId'];
      sid?: components['schemas']['TexmlSid'];
      /**
       * @description The status of the streaming.
       * @example stopped
       * @enum {string}
       */
      status?: 'stopped';
      date_updated?: components['schemas']['DateTimeRFC2822'];
      /**
       * @description The relative URI for this streaming resource.
       * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Calls/v3:KBnLO0ZK3DhKM5s7bE9VluaSmKsOchKht_fUYvxcp8ysbmzCCtpkmA/Streams/b08f0fa1-a32c-4218-b3b5-9cf78941ccac.json
       */
      uri?: string;
    };
    /** TnReleaseEntry */
    TnReleaseEntry: {
      /** @description Phone number in E164 format. */
      phone_number?: string;
      /** @description Phone number ID from the Telnyx API. */
      number_id?: string;
    };
    /** TnUploadEntry */
    TnUploadEntry: {
      number_id?: components['schemas']['UUID'];
      /** @description Phone number in E164 format. */
      phone_number?: string;
      /**
       * @description Represents the status of the phone number entry upload on Microsoft Teams.
       * @default pending_upload
       * @example error
       * @enum {string}
       */
      status:
        | 'pending_upload'
        | 'pending'
        | 'in_progress'
        | 'success'
        | 'error';
      /**
       * @description A code returned by Microsoft Teams if there is an error with the phone number entry upload.
       * @example internal_error
       * @enum {string}
       */
      error_code?:
        | 'internal_error'
        | 'unable_to_retrieve_default_location'
        | 'unknown_country_code'
        | 'unable_to_retrieve_location'
        | 'unable_to_retrieve_partner_info'
        | 'unable_to_match_geography_entry';
      /** @description A message returned by Microsoft Teams if there is an error with the upload process. */
      error_message?: string;
      /**
       * Format: uuid
       * @description Identifies the civic address assigned to the phone number entry.
       */
      civic_address_id?: string;
      /**
       * Format: uuid
       * @description Identifies the location assigned to the phone number entry.
       */
      location_id?: string;
      /**
       * @description Represents the status of the phone number entry upload on Telnyx.
       * @default pending_assignment
       * @example error
       * @enum {string}
       */
      internal_status:
        | 'pending_assignment'
        | 'in_progress'
        | 'all_internal_jobs_completed'
        | 'release_requested'
        | 'release_completed'
        | 'error';
    };
    /**
     * @description The phone number, in E.164 format, the fax will be sent to or SIP URI
     * @example +13127367276
     */
    To: string;
    /**
     * Format: address
     * @description Receiving address (+E.164 formatted phone number or short code).
     * @example +E.164
     */
    ToNumber: string;
    /** Tool */
    Tool: {
      /** Tool Id */
      tool_id: string;
      /**
       * Type
       * @enum {string}
       */
      type: 'retrieval' | 'function';
      /** Name */
      name?: string;
      /** Description */
      description?: string;
      function?: components['schemas']['FunctionDetail-Output'];
      retrieval?: components['schemas']['RetrievalDetail'];
    };
    /**
     * @description Specifies the type of traffic allowed in this profile.
     * @default conversational
     * @example conversational
     * @enum {string}
     */
    TrafficType: 'conversational';
    /**
     * Transcription
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.transcription",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "call_control_id": "v2:7subYr8fLrXmaAXm8egeAMpoSJ72J3SGPUuome81-hQuaKRf9b7hKA",
     *         "call_leg_id": "5ca81340-5beb-11eb-ae45-02420a0f8b69",
     *         "call_session_id": "5ca81eee-5beb-11eb-ba6c-02420a0f8b69",
     *         "client_state": null,
     *         "connection_id": "1240401930086254526",
     *         "transcription_data": {
     *           "confidence": 0.977219,
     *           "is_final": true,
     *           "transcript": "hello this is a test speech"
     *         }
     *       }
     *     }
     */
    Transcription: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.transcription
       * @enum {string}
       */
      event_type?: 'call.transcription';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Unique identifier and token for controlling the call.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        transcription_data?: {
          /**
           * Format: double
           * @description Speech recognition confidence level.
           * @example 0.977219
           */
          confidence?: number;
          /**
           * @description When false, it means that this is an interim result.
           * @example true
           */
          is_final?: boolean;
          /**
           * @description Recognized text.
           * @example hello this is a test speech
           */
          transcript?: string;
        };
      };
    };
    /** Transcription Event */
    TranscriptionEvent: {
      data?: components['schemas']['Transcription'];
    };
    /**
     * Transcription start request
     * @example {
     *       "language": "en",
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    TranscriptionStartRequest: {
      /**
       * @description Engine to use for speech recognition. `A` - `google`, `B` - `telnyx`.
       * @default A
       * @example A
       * @enum {string}
       */
      transcription_engine: 'A' | 'B';
      language?:
        | components['schemas']['GoogleTranscriptionLanguage']
        | components['schemas']['TelnyxTranscriptionLanguage'];
      /**
       * @description Whether to send also interim results. If set to false, only final results will be sent. Applies to `google` engine only.
       * @default false
       * @example true
       */
      interim_results: boolean;
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Indicates which leg of the call will be transcribed. Use `inbound` for the leg that requested the transcription, `outbound` for the other leg, and `both` for both legs of the call. Will default to `inbound`.
       * @default inbound
       * @example both
       */
      transcription_tracks: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Transcription stop request
     * @example {
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901"
     *     }
     */
    TranscriptionStopRequest: {
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
    };
    /**
     * Transfer Call Request
     * @example {
     *       "to": "+18005550100 or sip:username@sip.telnyx.com",
     *       "from": "+18005550101",
     *       "from_display_name": "Company Name",
     *       "audio_url": "http://www.example.com/sounds/greeting.wav",
     *       "timeout_secs": 60,
     *       "timeout_limit_secs": 60,
     *       "webhook_url": "https://www.example.com/server-b/",
     *       "webhook_url_method": "POST",
     *       "answering_machine_detection": "detect",
     *       "answering_machine_detection_config": {
     *         "total_analysis_time_millis": 5000,
     *         "after_greeting_silence_millis": 1000,
     *         "between_words_silence_millis": 1000,
     *         "greeting_duration_millis": 1000,
     *         "initial_silence_millis": 1000,
     *         "maximum_number_of_words": 1000,
     *         "maximum_word_length_millis": 2000,
     *         "silence_threshold": 512,
     *         "greeting_total_analysis_time_millis": 50000,
     *         "greeting_silence_duration_millis": 2000
     *       },
     *       "custom_headers": [
     *         {
     *           "name": "head_1",
     *           "value": "val_1"
     *         },
     *         {
     *           "name": "head_2",
     *           "value": "val_2"
     *         }
     *       ],
     *       "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *       "command_id": "891510ac-f3e4-11e8-af5b-de00688a4901",
     *       "media_encryption": "SRTP",
     *       "sip_auth_username": "username",
     *       "sip_auth_password": "password",
     *       "sip_headers": [
     *         {
     *           "name": "User-to-User",
     *           "value": "value"
     *         }
     *       ],
     *       "sip_transport_protocol": "TLS",
     *       "stream_url": "wss://www.example.com/websocket",
     *       "stream_track": "both_tracks"
     *     }
     */
    TransferCallRequest: {
      /**
       * @description The DID or SIP URI to dial out to.
       * @example +18005550100 or sip:username@sip.telnyx.com
       */
      to: string;
      /**
       * @description The `from` number to be used as the caller id presented to the destination (`to` number). The number should be in +E164 format. This attribute will default to the `to` number of the original call if omitted.
       * @example +18005550101
       */
      from?: string;
      /**
       * @description The `from_display_name` string to be used as the caller id name (SIP From Display Name) presented to the destination (`to` number). The string should have a maximum of 128 characters, containing only letters, numbers, spaces, and -_~!.+ special characters. If ommited, the display name will be the same as the number in the `from` field.
       * @example Company Name
       */
      from_display_name?: string;
      /**
       * @description The URL of a file to be played back when the transfer destination answers before bridging the call. The URL can point to either a WAV or MP3 file. media_name and audio_url cannot be used together in one request.
       * @example http://example.com/message.wav
       */
      audio_url?: string;
      /**
       * @description The media_name of a file to be played back when the transfer destination answers before bridging the call. The media_name must point to a file previously uploaded to api.telnyx.com/v2/media by the same user/organization. The file must either be a WAV or MP3 file.
       * @example my_media_uploaded_to_media_storage_api
       */
      media_name?: string;
      /**
       * Format: int32
       * @description The number of seconds that Telnyx will wait for the call to be answered by the destination to which it is being transferred. If the timeout is reached before an answer is received, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `timeout` will be sent. Minimum value is 5 seconds. Maximum value is 120 seconds.
       * @default 30
       * @example 60
       */
      timeout_secs: number;
      /**
       * Format: int32
       * @description Sets the maximum duration of a Call Control Leg in seconds. If the time limit is reached, the call will hangup and a `call.hangup` webhook with a `hangup_cause` of `time_limit` will be sent. For example, by setting a time limit of 120 seconds, a Call Leg will be automatically terminated two minutes after being answered. The default time limit is 14400 seconds or 4 hours and this is also the maximum allowed call length.
       * @default 14400
       * @example 600
       */
      time_limit_secs: number;
      /**
       * @description Enables Answering Machine Detection. When a call is answered, Telnyx runs real-time detection to determine if it was picked up by a human or a machine and sends an `call.machine.detection.ended` webhook with the analysis result. If 'greeting_end' or 'detect_words' is used and a 'machine' is detected, you will receive another 'call.machine.greeting.ended' webhook when the answering machine greeting ends with a beep or silence. If `detect_beep` is used, you will only receive 'call.machine.greeting.ended' if a beep is detected.
       * @default disabled
       * @enum {string}
       */
      answering_machine_detection:
        | 'premium'
        | 'detect'
        | 'detect_beep'
        | 'detect_words'
        | 'greeting_end'
        | 'disabled';
      /** @description Optional configuration parameters to modify 'answering_machine_detection' performance. */
      answering_machine_detection_config?: {
        /**
         * Format: int32
         * @description Maximum timeout threshold for overall detection.
         * @default 3500
         * @example 5000
         */
        total_analysis_time_millis: number;
        /**
         * Format: int32
         * @description Silence duration threshold after a greeting message or voice for it be considered human.
         * @default 800
         * @example 1000
         */
        after_greeting_silence_millis: number;
        /**
         * Format: int32
         * @description Maximum threshold for silence between words.
         * @default 50
         * @example 100
         */
        between_words_silence_millis: number;
        /**
         * Format: int32
         * @description Maximum threshold of a human greeting. If greeting longer than this value, considered machine.
         * @default 3500
         * @example 1500
         */
        greeting_duration_millis: number;
        /**
         * Format: int32
         * @description If initial silence duration is greater than this value, consider it a machine.
         * @default 3500
         * @example 1800
         */
        initial_silence_millis: number;
        /**
         * Format: int32
         * @description If number of detected words is greater than this value, consder it a machine.
         * @default 5
         * @example 3
         */
        maximum_number_of_words: number;
        /**
         * Format: int32
         * @description If a single word lasts longer than this threshold, consider it a machine.
         * @default 3500
         * @example 2000
         */
        maximum_word_length_millis: number;
        /**
         * Format: int32
         * @description Minimum noise threshold for any analysis.
         * @default 256
         * @example 512
         */
        silence_threshold: number;
        /**
         * Format: int32
         * @description If machine already detected, maximum timeout threshold to determine the end of the machine greeting.
         * @default 5000
         * @example 7500
         */
        greeting_total_analysis_time_millis: number;
        /**
         * Format: int32
         * @description If machine already detected, maximum threshold for silence between words. If exceeded, the greeting is considered ended.
         * @default 1500
         * @example 2000
         */
        greeting_silence_duration_millis: number;
      };
      /**
       * @description Custom headers to be added to the SIP INVITE.
       * @example [
       *       {
       *         "name": "head_1",
       *         "value": "val_1"
       *       },
       *       {
       *         "name": "head_2",
       *         "value": "val_2"
       *       }
       *     ]
       */
      custom_headers?: components['schemas']['CustomSipHeader'][];
      /**
       * @description Use this field to add state to every subsequent webhook. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      client_state?: string;
      /**
       * @description Use this field to add state to every subsequent webhook for the new leg. It must be a valid Base-64 encoded string.
       * @example aGF2ZSBhIG5pY2UgZGF5ID1d
       */
      target_leg_client_state?: string;
      /**
       * @description Use this field to avoid duplicate commands. Telnyx will ignore any command with the same `command_id` for the same `call_control_id`.
       * @example 891510ac-f3e4-11e8-af5b-de00688a4901
       */
      command_id?: string;
      /**
       * @description Defines whether media should be encrypted on the new call leg.
       * @default disabled
       * @enum {string}
       */
      media_encryption: 'disabled' | 'SRTP';
      /**
       * @description SIP Authentication username used for SIP challenges.
       * @example username
       */
      sip_auth_username?: string;
      /**
       * @description SIP Authentication password used for SIP challenges.
       * @example password
       */
      sip_auth_password?: string;
      /**
       * @description SIP headers to be added to the SIP INVITE. Currently only User-to-User header is supported.
       * @example [
       *       {
       *         "name": "User-to-User",
       *         "value": "value"
       *       }
       *     ]
       */
      sip_headers?: components['schemas']['SipHeader'][];
      /**
       * @description Defines SIP transport protocol to be used on the call.
       * @default UDP
       * @enum {string}
       */
      sip_transport_protocol: 'UDP' | 'TCP' | 'TLS';
      sound_modifications?: components['schemas']['SoundModifications'];
      /**
       * @description Use this field to override the URL for which Telnyx will send subsequent webhooks to for this call.
       * @example https://www.example.com/server-b/
       */
      webhook_url?: string;
      /**
       * @description HTTP request type used for `webhook_url`.
       * @default POST
       * @example GET
       * @enum {string}
       */
      webhook_url_method: 'POST' | 'GET';
    };
    /**
     * @default 2
     * @example 1
     * @enum {integer}
     */
    TwimlRecordingChannels: 1 | 2;
    /**
     * UUID
     * Format: uuid
     * @description Uniquely identifies the resource.
     * @example 542c3bca-d247-42bc-8fe7-e01d16ecd761
     */
    UUID: string;
    UnauthorizedError: components['schemas']['GenericError'] & {
      /** @example 10009 */
      code?: unknown;
      /** @example Authentication failed */
      title?: unknown;
      /** @example The required authentication headers were either invalid or not included in the request. */
      detail?: unknown;
      meta?: {
        /** @example https://developers.telnyx.com/docs/overview/errors/10009 */
        url?: string;
      };
    };
    UnexpectedError: components['schemas']['GenericError'] & {
      /** @example 10007 */
      code?: unknown;
      /** @example Unexpected error */
      title?: unknown;
      /** @example An unexpected error occurred. */
      detail?: unknown;
      meta?: {
        /** @example https://developers.telnyx.com/docs/overview/errors/10007 */
        url?: string;
      };
    };
    UnprocessableEntityError: components['schemas']['GenericError'] & {
      /** @example 10002 */
      code?: unknown;
      /** @example Invalid phone number */
      title?: unknown;
      /** @example The phone number is invalid. */
      detail?: unknown;
      source?: {
        /** @example /phone_numbers */
        pointer?: string;
      };
      meta?: {
        /** @example https://developers.telnyx.com/docs/overview/errors/10002 */
        url?: string;
      };
    };
    /** UpdateAssistantRequest */
    UpdateAssistantRequest: {
      /** Name */
      name?: string;
      /** Model */
      model?: string;
      /** Description */
      description?: string;
      /** Instructions */
      instructions?: string;
      /** @description The `function` tool type follows the same schema as the [OpenAI Assistants API](https://platform.openai.com/docs/api-reference/assistants/modifyAssistant). The `retrieval` tool type is unique to Telnyx. You may pass a list of [embedded storage buckets](https://developers.telnyx.com/api/inference/inference-embedding/post-embedding) for retrieval-augmented generation. */
      tools?: (
        | components['schemas']['ChatCompletionToolParam']
        | components['schemas']['Retrieval']
      )[];
    };
    /**
     * Update Authentication Provider Request
     * @example {
     *       "name": "Okta",
     *       "short_name": "myorg",
     *       "active": true,
     *       "settings": {
     *         "idp_entity_id": "https://myorg.myidp.com/saml/metadata",
     *         "idp_sso_target_url": "https://myorg.myidp.com/trust/saml2/http-post/sso",
     *         "idp_cert_fingerprint": "13:38:C7:BB:C9:FF:4A:70:38:3A:E3:D9:5C:CD:DB:2E:50:1E:80:A7",
     *         "idp_cert_fingerprint_algorithm": "sha1"
     *       }
     *     }
     */
    UpdateAuthenticationProviderRequest: {
      name?: components['schemas']['name'];
      short_name?: components['schemas']['short_name'];
      active?: components['schemas']['active'];
      settings?: components['schemas']['settings'];
      settings_url?: components['schemas']['settings_url'];
    };
    /** @example {
     *       "name": "string"
     *     } */
    UpdateBillingGroup: {
      /** @description A name for the billing group */
      name?: string;
    };
    /** UpdateBrand */
    UpdateBrand: {
      /** @description Entity type behind the brand. This is the form of business establishment. */
      entityType: components['schemas']['EntityType'];
      /**
       * Displayname
       * @description Display or marketing name of the brand.
       * @example ABC Mobile
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example ABC Inc.
       */
      companyName?: string;
      /**
       * Firstname
       * @description First name of business contact.
       * @example John
       */
      firstName?: string;
      /**
       * Lastname
       * @description Last name of business contact.
       * @example Smith
       */
      lastName?: string;
      /**
       * Ein
       * @description (Required for Non-profit) Government assigned corporate tax ID. EIN is 9-digits in U.S.
       * @example 111111111
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +12024567890
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example New York
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example NY
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 10001
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example ABC
       */
      stockSymbol?: string;
      /**
       * @description (Required for public company) stock exchange.
       * @example NASDAQ
       */
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example http://www.abcmobile.com
       */
      website?: string;
      /** @description Vertical or industry segment of the brand. */
      vertical: components['schemas']['Vertical'];
      /**
       * Altbusiness Id
       * @description Alternate business identifier such as DUNS, LEI, or GIIN
       */
      altBusiness_id?: string;
      altBusinessIdType?: components['schemas']['AltBusinessIdType'];
      /** Isreseller */
      isReseller?: boolean;
      identityStatus?: components['schemas']['BrandIdentityStatus'];
      /**
       * BusinessContactEmail
       * @description Business contact email.
       *
       *     Required if `entityType` will be changed to `PUBLIC_PROFIT`.
       * @example name@example.com
       */
      businessContactEmail?: string;
      /**
       * WebhookURL
       * @description Webhook URL for brand status updates.
       * @example https://webhook.com/67ea78a8-9f32-4d04-b62d-f9502e8e5f93
       */
      webhookURL?: string;
      /**
       * WebhookFailoverURL
       * @description Webhook failover URL for brand status updates.
       * @example https://webhook.com/9010a453-4df8-4be6-a551-1070892888d6
       */
      webhookFailoverURL?: string;
    };
    /** UpdateBrand */
    UpdateBrandRequest: {
      entityType: components['schemas']['EntityType'];
      /**
       * Displayname
       * @description Display or marketing name of the brand.
       * @example Example Company Updated
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example Example Company Inc.
       */
      companyName?: string;
      /**
       * Ein
       * @description (Required for Non-profit/private/public) Government assigned corporate tax ID. EIN is 9-digits in U.S. The only entity type which does not require an EIN is a Sole Proprietor.
       * @example 142536893
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +13259390512
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123 Example St.
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example San Francisco
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example CA
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 94016
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       * @example examplename@examplecompanyupdated.com
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example EXCOUP
       */
      stockSymbol?: string;
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example www.examplecompanyupdated.com
       */
      website?: string;
      vertical: components['schemas']['Vertical'];
      /**
       * Altbusinessid
       * @description Alternate business identifier such as DUNS, LEI, or GIIN
       */
      altBusinessId?: string;
      altBusinessIdType?: components['schemas']['AltBusinessIdType'];
    };
    /** UpdateBrand */
    UpdateBrandResponse: {
      entityType: components['schemas']['EntityType'];
      /**
       * Displayname
       * @description Display or marketing name of the brand.
       * @example Example Company Updated
       */
      displayName: string;
      /**
       * Companyname
       * @description (Required for Non-profit/private/public) Legal company name.
       * @example Example Company Inc.
       */
      companyName?: string;
      /**
       * Ein
       * @description (Required for Non-profit/private/public) Government assigned corporate tax ID. EIN is 9-digits in U.S. The only entity type which does not require an EIN is a Sole Proprietor.
       * @example 142536893
       */
      ein?: string;
      /**
       * Phone
       * @description Valid phone number in e.164 international format.
       * @example +13259390512
       */
      phone?: string;
      /**
       * Street
       * @description Street number and name.
       * @example 123 Example St.
       */
      street?: string;
      /**
       * City
       * @description City name
       * @example San Francisco
       */
      city?: string;
      /**
       * State
       * @description State. Must be 2 letters code for United States.
       * @example CA
       */
      state?: string;
      /**
       * Postalcode
       * @description Postal codes. Use 5 digit zipcode for United States
       * @example 94016
       */
      postalCode?: string;
      /**
       * Country
       * @description ISO2 2 characters country code. Example: US - United States
       * @example US
       */
      country: string;
      /**
       * Email
       * @description Valid email address of brand support contact.
       * @example examplename@examplecompanyupdated.com
       */
      email: string;
      /**
       * Stocksymbol
       * @description (Required for public company) stock symbol.
       * @example EXCOUP
       */
      stockSymbol?: string;
      stockExchange?: components['schemas']['StockExchange'];
      /**
       * Ipaddress
       * @description IP address of the browser requesting to create brand identity.
       */
      ipAddress?: string;
      /**
       * Website
       * @description Brand website URL.
       * @example www.examplecompanyupdated.com
       */
      website?: string;
      brandRelationship: components['schemas']['BrandRelationship'];
      vertical: components['schemas']['Vertical'];
      /**
       * Altbusinessid
       * @description Alternate business identifier such as DUNS, LEI, or GIIN
       */
      altBusinessId?: string;
      altBusinessIdType?: components['schemas']['AltBusinessIdType'];
      identityStatus?: components['schemas']['BrandIdentityStatus'];
    };
    /**
     * Update Call Control Application Request
     * @example {
     *       "application_name": "call-router",
     *       "webhook_event_url": "https://example.com",
     *       "active": false,
     *       "anchorsite_override": "\"Latency\"",
     *       "dtmf_type": "Inband",
     *       "first_command_timeout": true,
     *       "first_command_timeout_secs": 10,
     *       "inbound": {
     *         "channel_limit": 10,
     *         "shaken_stir_enabled": true,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       },
     *       "webhook_api_version": "1",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_timeout_secs": 25
     *     }
     */
    UpdateCallControlApplicationRequest: {
      /**
       * @description A user-assigned name to help manage the application.
       * @example call-router
       */
      application_name: string;
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url: string;
      /**
       * @description Specifies whether the connection can be used.
       * @default true
       */
      active: boolean;
      /**
       * @description <code>Latency</code> directs Telnyx to route media through the site with the lowest round-trip time to the user's connection. Telnyx calculates this time using ICMP ping messages. This can be disabled by specifying a site to handle all media.
       *
       * @default "Latency"
       * @example "Amsterdam, Netherlands"
       * @enum {string}
       */
      anchorsite_override:
        | '"Latency"'
        | '"Chicago, IL"'
        | '"Ashburn, VA"'
        | '"San Jose, CA"';
      /**
       * @description Sets the type of DTMF digits sent from Telnyx to this Connection. Note that DTMF digits sent to Telnyx will be accepted in all formats.
       * @default RFC 2833
       * @example Inband
       * @enum {string}
       */
      dtmf_type: 'RFC 2833' | 'Inband' | 'SIP INFO';
      /**
       * @description Specifies whether calls to phone numbers associated with this connection should hangup after timing out.
       * @default false
       * @example true
       */
      first_command_timeout: boolean;
      /**
       * @description Specifies how many seconds to wait before timing out a dial command.
       * @default 30
       * @example 10
       */
      first_command_timeout_secs: number;
      inbound?: components['schemas']['CallControlApplicationInbound'];
      outbound?: components['schemas']['CallControlApplicationOutbound'];
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
    };
    /**
     * Update Call Request
     * @example {
     *       "Status": "completed"
     *     }
     */
    UpdateCallRequest: {
      /**
       * @description The value to set the call status to. Setting the status to completed ends the call.
       * @example completed
       */
      Status?: string;
      /**
       * @description The URL where TeXML will make a request to retrieve a new set of TeXML instructions to continue the call flow.
       * @example https://www.example.com/intruction-b.xml
       */
      Url?: string;
      /**
       * @description HTTP request type used for `Url`.
       * @example GET
       * @enum {string}
       */
      Method?: 'GET' | 'POST';
      /**
       * @description A failover URL for which Telnyx will retrieve the TeXML call instructions if the Url is not responding.
       * @example https://www.example.com/intruction-c.xml
       */
      FallbackUrl?: string;
      /**
       * @description HTTP request type used for `FallbackUrl`.
       * @example GET
       * @enum {string}
       */
      FallbackMethod?: 'GET' | 'POST';
      /**
       * @description URL destination for Telnyx to send status callback events to for the call.
       * @example https://www.example.com/callback
       */
      StatusCallback?: string;
      /**
       * @description HTTP request type used for `StatusCallback`.
       * @example GET
       * @enum {string}
       */
      StatusCallbackMethod?: 'GET' | 'POST';
      /**
       * @description TeXML to replace the current one with.
       * @example <?xml version="1.0" encoding="UTF-8"?><Response><Say>Hello</Say></Response>
       */
      Texml?: string;
    };
    /** UpdateCampaignRequest */
    UpdateCampaignRequest: {
      /**
       * Resellerid
       * @description Alphanumeric identifier of the reseller that you want to associate with this campaign.
       */
      resellerId?: string;
      /**
       * Sample1
       * @description Message sample. Some campaign tiers require 1 or more message samples.
       */
      sample1?: string;
      /**
       * Sample2
       * @description Message sample. Some campaign tiers require 2 or more message samples.
       */
      sample2?: string;
      /**
       * Sample3
       * @description Message sample. Some campaign tiers require 3 or more message samples.
       */
      sample3?: string;
      /**
       * Sample4
       * @description Message sample. Some campaign tiers require 4 or more message samples.
       */
      sample4?: string;
      /**
       * Sample5
       * @description Message sample. Some campaign tiers require 5 or more message samples.
       */
      sample5?: string;
      /**
       * Messageflow
       * @description Message flow description.
       */
      messageFlow?: string;
      /**
       * Helpmessage
       * @description Help message of the campaign.
       */
      helpMessage?: string;
      /**
       * Autorenewal
       * @description Help message of the campaign.
       * @default true
       */
      autoRenewal: boolean;
      /**
       * WebhookURL
       * @description Webhook to which campaign status updates are sent.
       */
      webhookURL?: string;
      /**
       * WebhookURL
       * @description Webhook failover to which campaign status updates are sent.
       */
      webhookFailoverURL?: string;
    };
    /** UpdateCampaignResponse */
    UpdateCampaignResponse: {
      /**
       * Campaignid
       * @description Alphanumeric identifier assigned by the registry for a campaign. This identifier is required by the NetNumber OSR SMS enabling process of 10DLC.
       * @example 4b30017a-15eb-6a25-2e3f-59b6422cud79
       */
      campaignId?: string;
      /**
       * Cspid
       * @description Alphanumeric identifier of the CSP associated with this campaign.
       */
      cspId?: string;
      /**
       * Resellerid
       * @description Alphanumeric identifier of the reseller that you want to associate with this campaign.
       * @example RPQFAOY
       */
      resellerId?: string;
      /** @description Current campaign status. Possible values: ACTIVE, EXPIRED. A newly created campaign defaults to ACTIVE status. */
      status?: components['schemas']['Status'];
      /**
       * Createdate
       * Format: date-time
       * @description Unix timestamp when campaign was created.
       */
      createDate?: string;
      /**
       * Autorenewal
       * @description Campaign subscription auto-renewal status.
       */
      autoRenewal?: boolean;
      /**
       * Billeddate
       * Format: date-time
       * @description Campaign recent billed date.
       */
      billedDate?: string;
      /**
       * Brandid
       * @description Alphanumeric identifier of the brand associated with this campaign.
       * @example 4b206179-f731-8ab7-f19c-34e19d22ide9
       */
      brandId: string;
      vertical: components['schemas']['Vertical'];
      usecase: components['schemas']['Usecase'];
      subUsecases?: components['schemas']['Usecase'];
      /**
       * Description
       * @description Summary description of this campaign.
       * @example Campaign description goes here.
       */
      description: string;
      /**
       * Embeddedlink
       * @description Does message generated by the campaign include URL link in SMS?
       * @default false
       */
      embeddedLink: boolean;
      /**
       * Embeddedphone
       * @description Does message generated by the campaign include phone number in SMS?
       * @default false
       */
      embeddedPhone: boolean;
      /**
       * Affiliatemarketing
       * @description Does message content controlled by affiliate marketing other than the brand?
       */
      affiliateMarketing?: boolean;
      /**
       * Numberpool
       * @description Does campaign utilize pool of phone nubers?
       * @default false
       */
      numberPool: boolean;
      /**
       * Agegated
       * @description Age gated content in campaign.
       */
      ageGated?: boolean;
      /** Directlending */
      directLending?: boolean;
      /**
       * Subscriberoptin
       * @description Does campaign require subscriber to opt-in before SMS is sent to subscriber?
       * @default false
       */
      subscriberOptin: boolean;
      /**
       * Subscriberoptout
       * @description Does campaign support subscriber opt-out keyword(s)?
       * @default false
       */
      subscriberOptout: boolean;
      /**
       * Subscriberhelp
       * @description Does campaign responds to help keyword(s)?
       * @default false
       */
      subscriberHelp: boolean;
      /**
       * Sample1
       * @description Message sample. Some campaign tiers require 1 or more message samples.
       * @example This is a an updated message!
       */
      sample1?: string;
      /**
       * Sample2
       * @description Message sample. Some campaign tiers require 2 or more message samples.
       * @example This is a newly created message!
       */
      sample2?: string;
      /**
       * Sample3
       * @description Message sample. Some campaign tiers require 3 or more message samples.
       * @example This is a newly created message!
       */
      sample3?: string;
      /**
       * Sample4
       * @description Message sample. Some campaign tiers require 4 or more message samples.
       */
      sample4?: string;
      /**
       * Sample5
       * @description Message sample. Some campaign tiers require 5 or more message samples.
       */
      sample5?: string;
      /**
       * Messageflow
       * @description Message flow description.
       */
      messageFlow?: string;
      /**
       * Helpmessage
       * @description Help message of the campaign.
       */
      helpMessage?: string;
    };
    /**
     * Update Call Result
     * @example {
     *       "sid": "c46e06d7-b78f-4b13-96b6-c576af9640ff",
     *       "status": "accepted"
     *     }
     */
    UpdateCommandResult: {
      /** @example c46e06d7-b78f-4b13-96b6-c576af9640ff */
      sid?: string;
      /** @example accepted */
      status?: string;
    };
    /**
     * Update Conference Participant Request
     * @example {
     *       "BeepOnExit": false
     *     }
     */
    UpdateConferenceParticipantRequest: {
      /**
       * @description Whether the participant should be muted.
       * @example true
       */
      Muted?: boolean;
      /**
       * @description Whether the participant should be on hold.
       * @example true
       */
      Hold?: boolean;
      /**
       * @description The URL to be called using the `HoldMethod` for music that plays when the participant is on hold. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
       * @example true
       */
      HoldUrl?: string;
      /**
       * @description The HTTP method to use when calling the `HoldUrl`.
       * @example POST
       * @enum {string}
       */
      HoldMethod?: 'GET' | 'POST';
      /**
       * @description The URL to call to announce something to the participant. The URL may return an MP3 fileo a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
       * @example https://www.example.com/announce.xml
       */
      AnnounceUrl?: string;
      /**
       * @description The HTTP method used to call the `AnnounceUrl`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      AnnounceMethod?: 'GET' | 'POST';
      /**
       * @description The URL to call for an audio file to play while the participant is waiting for the conference to start.
       * @example https://www.example.com/wait_music.mp3
       */
      WaitUrl?: string;
      /**
       * @description Whether to play a notification beep to the conference when the participant exits.
       * @example false
       */
      BeepOnExit?: boolean;
      /**
       * @description Whether to end the conference when the participant leaves.
       * @example false
       */
      EndConferenceOnExit?: boolean;
      /**
       * @description Whether the participant is coaching another call. When `true`, `CallSidToCoach` has to be given.
       * @example false
       */
      Coaching?: boolean;
      /**
       * @description The SID of the participant who is being coached. The participant being coached is the only participant who can hear the participant who is coaching.
       * @example v3:9X2vxPDFY2RHSJ1EdMS0RHRksMTg7ldNxdjWbVr9zBjbGjGsSe-aiQ
       */
      CallSidToCoach?: string;
    };
    /**
     * Update Conference Request
     * @example {
     *       "Status": "completed"
     *     }
     */
    UpdateConferenceRequest: {
      /**
       * @description The new status of the resource. Specifying `completed` will end the conference and hang up all participants.
       * @example completed
       */
      Status?: string;
      /**
       * @description The URL we should call to announce something into the conference. The URL may return an MP3 file, a WAV file, or a TwiML document that contains `<Play>`, `<Say>`, `<Pause>`, or `<Redirect>` verbs.
       * @example https://www.example.com/announce.xml
       */
      AnnounceUrl?: string;
      /**
       * @description The HTTP method used to call the `AnnounceUrl`. Defaults to `POST`.
       * @example GET
       * @enum {string}
       */
      AnnounceMethod?: 'GET' | 'POST';
    };
    /**
     * Update Credential Connection Request
     * @example {
     *       "active": true,
     *       "password": "my123secure456password789",
     *       "user_name": "myusername123",
     *       "anchorsite_override": "Latency",
     *       "connection_name": "my name",
     *       "sip_uri_calling_preference": " disabled",
     *       "default_on_hold_comfort_noise_enabled": false,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_seconds": 10
     *       },
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": "G722",
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 20,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "call_parking_enabled": true,
     *         "ani_override": "always",
     *         "channel_limit": 10,
     *         "instant_ringback_enabled": true,
     *         "generate_ringback_tone": true,
     *         "localization": "US",
     *         "t38_reinvite_source": "customer",
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    UpdateCredentialConnectionRequest: {
      /** @description Defaults to true */
      active?: boolean;
      /**
       * @description The user name to be used as part of the credentials. Must be 4-32 characters long and alphanumeric values only (no spaces or special characters).
       * @example myusername123
       */
      user_name?: string;
      /**
       * @description The password to be used as part of the credentials. Must be 8 to 128 characters long.
       * @example my123secure456password789
       */
      password?: string;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name?: components['schemas']['ConnectionName'];
      /**
       * @description This feature enables inbound SIP URI calls to your Credential Auth Connection. If enabled for all (unrestricted) then anyone who calls the SIP URI <your-username>@telnyx.com will be connected to your Connection. You can also choose to allow only calls that are originated on any Connections under your account (internal).
       * @enum {string}
       */
      sip_uri_calling_preference?: 'disabled' | 'unrestricted' | 'internal';
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default false
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      ios_push_credential_id?: components['schemas']['ConnectionIosPushCredentialId'];
      android_push_credential_id?: components['schemas']['ConnectionAndroidPushCredentialId'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['CredentialInbound'];
      outbound?: components['schemas']['CredentialOutbound'];
    };
    /** Update External Connection Phone Number Request */
    UpdateExternalConnectionPhoneNumberRequest: {
      /**
       * Format: uuid
       * @description Identifies the location to assign the phone number to.
       */
      location_id?: string;
    };
    /**
     * Update External Connection Request
     * @example {
     *       "active": false,
     *       "outbound": {
     *         "outbound_voice_profile_id": "1911630617284445511"
     *       }
     *     }
     */
    UpdateExternalConnectionRequest: {
      active?: components['schemas']['ConnectionActive'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      inbound?: {
        /**
         * @description When set, this will limit the number of concurrent inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
      };
      outbound?: {
        /**
         * @description When set, this will limit the number of concurrent outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
    };
    /**
     * Update Fax Application Request
     * @example {
     *       "application_name": "fax-router",
     *       "active": false,
     *       "anchorsite_override": "Amsterdam, Netherlands",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_timeout_secs": 25,
     *       "inbound": {
     *         "channel_limit": 10,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    UpdateFaxApplicationRequest: {
      application_name: components['schemas']['ApplicationName'];
      active?: components['schemas']['ConnectionActive'];
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      webhook_event_url: components['schemas']['WebhookEventUrl'];
      webhook_event_failover_url?: components['schemas']['WebhookEventFailoverUrl'];
      webhook_timeout_secs?: components['schemas']['WebhookTimeoutSecs'];
      fax_email_recipient?: components['schemas']['FaxEmailRecipient'];
      inbound?: {
        /**
         * @description When set, this will limit the number of concurrent inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        /**
         * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
         * @default null
         * @example example
         */
        sip_subdomain: string;
        /**
         * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
         * @default from_anyone
         * @example only_my_connections
         * @enum {string}
         */
        sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      };
      outbound?: {
        /**
         * @description When set, this will limit the number of concurrent outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
    };
    /**
     * Update FQDN Connection Request
     * @example {
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "transport_protocol": "UDP",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": true,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_secs": 10
     *       },
     *       "inbound": {
     *         "ani_number_format": "+E.164",
     *         "dnis_number_format": "+e164",
     *         "codecs": [
     *           "G722"
     *         ],
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "sip_region": "US",
     *         "sip_subdomain": "string",
     *         "sip_subdomain_receive_settings": "only_my_connections",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 10,
     *         "shaken_stir_enabled": true
     *       }
     *     }
     */
    UpdateFqdnConnectionRequest: {
      /** @description Defaults to true */
      active?: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name?: components['schemas']['ConnectionName'];
      transport_protocol?: components['schemas']['FqdnConnectionTransportProtocol'];
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer that the sender and receiver negotiate T38 directly when both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call according to each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      ios_push_credential_id?: components['schemas']['ConnectionIosPushCredentialId'];
      android_push_credential_id?: components['schemas']['ConnectionAndroidPushCredentialId'];
      webhook_event_url?: components['schemas']['WebhookEventUrl'];
      webhook_event_failover_url?: components['schemas']['WebhookEventFailoverUrl'];
      webhook_api_version?: components['schemas']['WebhookApiVersion'];
      webhook_timeout_secs?: components['schemas']['WebhookTimeoutSecs'];
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['InboundFqdn'];
      outbound?: components['schemas']['OutboundFqdn'];
    };
    /**
     * Update FQDN Request
     * @example {
     *       "connection_id": "1516447646313612565",
     *       "fqdn": "example.com",
     *       "port": 8080,
     *       "dns_record_type": "a"
     *     }
     */
    UpdateFqdnRequest: {
      /** @description ID of the FQDN connection to which this IP should be attached. */
      connection_id?: string;
      /**
       * @description FQDN represented by this resource.
       * @example example.com
       */
      fqdn?: string;
      /**
       * @description Port to use when connecting to this FQDN.
       * @default 5060
       * @example 5060
       */
      port: number;
      /**
       * @description The DNS record type for the FQDN. For cases where a port is not set, the DNS record type must be 'srv'. For cases where a port is set, the DNS record type must be 'a'. If the DNS record type is 'a' and a port is not specified, 5060 will be used.
       * @example a
       */
      dns_record_type?: string;
    };
    /**
     * Update Ip Connection Request
     * @example {
     *       "active": true,
     *       "anchorsite_override": "Latency",
     *       "connection_name": "string",
     *       "transport_protocol": "UDP",
     *       "default_on_hold_comfort_noise_enabled": true,
     *       "dtmf_type": "RFC 2833",
     *       "encode_contact_header_enabled": true,
     *       "encrypted_media": "SRTP",
     *       "onnet_t38_passthrough_enabled": false,
     *       "ios_push_credential_id": "ec0c8e5d-439e-4620-a0c1-9d9c8d02a836",
     *       "android_push_credential_id": "06b09dfd-7154-4980-8b75-cebf7a9d4f8e",
     *       "webhook_event_url": "https://example.com",
     *       "webhook_event_failover_url": "https://failover.example.com",
     *       "webhook_api_version": "1",
     *       "webhook_timeout_secs": 25,
     *       "rtcp_settings": {
     *         "port": "rtcp-mux",
     *         "capture_enabled": true,
     *         "report_frequency_secs": 10
     *       },
     *       "inbound:": {
     *         "ani_number_format": "+E.164",
     *         "dns_number_format": "+e164",
     *         "codecs": "G722",
     *         "default_primary_ip_id": "192.168.0.0",
     *         "default_tertiary_ip_id": "192.168.0.0",
     *         "default_secondary_ip_id": "192.168.0.0",
     *         "default_routing_method": "sequential",
     *         "channel_limit": 10,
     *         "generate_ringback_tone": true,
     *         "isup_headers_enabled": true,
     *         "prack_enabled": true,
     *         "privacy_zone_enabled": true,
     *         "sip_compact_headers_enabled": true,
     *         "sip_region": "US",
     *         "sip_subdomain": "test",
     *         "sip_subdomain_receive_settings": "only_my_connections",
     *         "timeout_1xx_secs": 10,
     *         "timeout_2xx_secs": 20,
     *         "shaken_stir_enabled": true
     *       },
     *       "outbound": {
     *         "call_parking_enabled": true,
     *         "ani_override": "string",
     *         "ani_override_type": "always",
     *         "channel_limit": 10,
     *         "instant_ringback_enabled": true,
     *         "generate_ringback_tone": true,
     *         "localization": "string",
     *         "t38_reinvite_source": "customer",
     *         "tech_prefix": "string",
     *         "ip_authentication_method": "token",
     *         "ip_authentication_token": "string",
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    UpdateIpConnectionRequest: {
      /** @description Defaults to true */
      active?: boolean;
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      connection_name?: string;
      /**
       * @description One of UDP, TLS, or TCP. Applies only to connections with IP authentication or FQDN authentication.
       * @default UDP
       * @enum {string}
       */
      transport_protocol: 'UDP' | 'TCP' | 'TLS';
      /**
       * @description When enabled, Telnyx will generate comfort noise when you place the call on hold. If disabled, you will need to generate comfort noise or on hold music to avoid RTP timeout.
       * @default true
       */
      default_on_hold_comfort_noise_enabled: boolean;
      dtmf_type?: components['schemas']['DtmfType'];
      /**
       * @description Encode the SIP contact header sent by Telnyx to avoid issues for NAT or ALG scenarios.
       * @default false
       */
      encode_contact_header_enabled: boolean;
      encrypted_media?: components['schemas']['EncryptedMedia'];
      /**
       * @description Enable on-net T38 if you prefer the sender and receiver negotiating T38 directly if both are on the Telnyx network. If this is disabled, Telnyx will be able to use T38 on just one leg of the call depending on each leg's settings.
       * @default false
       */
      onnet_t38_passthrough_enabled: boolean;
      ios_push_credential_id?: components['schemas']['ConnectionIosPushCredentialId'];
      android_push_credential_id?: components['schemas']['ConnectionAndroidPushCredentialId'];
      /**
       * Format: url
       * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
       * @example https://example.com
       */
      webhook_event_url?: string;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
       * @default
       * @example https://failover.example.com
       */
      webhook_event_failover_url: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1 or v2.
       * @default 1
       * @example 1
       * @enum {string}
       */
      webhook_api_version: '1' | '2';
      /**
       * @description Specifies how many seconds to wait before timing out a webhook.
       * @default null
       * @example 25
       */
      webhook_timeout_secs: number | null;
      rtcp_settings?: components['schemas']['ConnectionRtcpSettings'];
      inbound?: components['schemas']['InboundIp'];
      outbound?: components['schemas']['OutboundIp'];
    };
    /**
     * Update Ip Request
     * @example {
     *       "connection_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58",
     *       "ip_address": "192.168.0.0",
     *       "port": 5060
     *     }
     */
    UpdateIpRequest: {
      /** @description ID of the IP Connection to which this IP should be attached. */
      connection_id?: string;
      /**
       * @description IP adddress represented by this resource.
       * @example 192.168.0.0
       */
      ip_address: string;
      /**
       * @description Port to use when connecting to this IP.
       * @default 5060
       * @example 5060
       */
      port: number;
    };
    /**
     * Update Managed Account Global Outbound Channels Request
     * @example {
     *       "channel_limit": 30
     *     }
     */
    UpdateManagedAccountGlobalChannelLimitRequest: {
      /**
       * @description Integer value that indicates the number of allocatable global outbound channels that should be allocated to the managed account. Must be 0 or more. If the value is 0 then the account will have no usable channels and will not be able to perform outbound calling.
       * @example 30
       */
      channel_limit?: number;
    };
    /**
     * Update Managed Account Request
     * @example {
     *       "managed_account_allow_custom_pricing": true
     *     }
     */
    UpdateManagedAccountRequest: {
      /**
       * @description Boolean value that indicates if the managed account is able to have custom pricing set for it or not. If false, uses the pricing of the manager account. Defaults to false. This value may be changed, but there may be time lag between when the value is changed and pricing changes take effect.
       * @example false
       */
      managed_account_allow_custom_pricing?: boolean;
    };
    /**
     * Upload media multipart request
     * @example {
     *       "media": "string($binary)",
     *       "ttl_secs": 86400
     *     }
     */
    UpdateMediaMultipartRequest: {
      /**
       * Format: binary
       * @description The file you want to upload. The maximum allowed size is 20 MB.
       */
      media?: string;
      /**
       * @description The number of seconds after which the media resource will be deleted, defaults to 2 days. The maximum allowed vale is 630720000, which translates to 20 years.
       * @example 86400
       */
      ttl_secs?: number;
    };
    /**
     * Upload media request
     * @example {
     *       "media_url": "http://www.example.com/audio.mp3",
     *       "ttl_secs": 86400
     *     }
     */
    UpdateMediaRequest: {
      /**
       * @description The URL where the media to be stored in Telnyx network is currently hosted. The maximum allowed size is 20 MB.
       * @example http://www.example.com/audio.mp3
       */
      media_url?: string;
      /**
       * @description The number of seconds after which the media resource will be deleted, defaults to 2 days. The maximum allowed vale is 630720000, which translates to 20 years.
       * @example 86400
       */
      ttl_secs?: number;
    };
    /** @example {
     *       "name": "Updated Profile for Messages",
     *       "webhook_url": "https://www.example.com/hooks",
     *       "webhook_failover_url": "https://backup.example.com/hooks",
     *       "enabled": true,
     *       "webhook_api_version": "2",
     *       "whitelisted_destinations": [
     *         "US"
     *       ],
     *       "number_pool_settings": {
     *         "toll_free_weight": 10,
     *         "long_code_weight": 2,
     *         "skip_unhealthy": false,
     *         "sticky_sender": true,
     *         "geomatch": false
     *       },
     *       "url_shortener_settings": {
     *         "domain": "example.ex",
     *         "prefix": "cmpny",
     *         "replace_blacklist_only": true,
     *         "send_webhooks": false
     *       },
     *       "v1_secret": "rP1VamejkU2v0qIUxntqLW2c"
     *     } */
    UpdateMessagingProfileRequest: {
      /**
       * @description Identifies the type of the resource.
       * @enum {string}
       */
      readonly record_type?: 'messaging_profile';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       */
      readonly id?: string;
      /** @description A user friendly name for the messaging profile. */
      name?: string;
      /** @description Specifies whether the messaging profile is enabled or not. */
      enabled?: boolean;
      /**
       * Format: url
       * @description The URL where webhooks related to this messaging profile will be sent.
       */
      webhook_url?: string | null;
      /**
       * Format: url
       * @description The failover URL where webhooks related to this messaging profile will be sent if sending to the primary URL fails.
       */
      webhook_failover_url?: string | null;
      /**
       * @description Determines which webhook format will be used, Telnyx API v1, v2, or a legacy 2010-04-01 format.
       * @enum {string}
       */
      webhook_api_version?: '1' | '2' | '2010-04-01';
      /** @description Destinations to which the messaging profile is allowed to send. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       *
       *     This field is required if the messaging profile doesn't have it defined yet. */
      whitelisted_destinations?: string[];
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was created.
       */
      readonly created_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the resource was updated.
       */
      readonly updated_at?: string;
      /** @description Secret used to authenticate with v1 endpoints. */
      v1_secret?: string;
      number_pool_settings?: components['schemas']['NumberPoolSettings'];
      url_shortener_settings?: components['schemas']['UrlShortenerSettings'];
      /** @description The alphanumeric sender ID to use when sending to destinations that require an alphanumeric sender ID. */
      alpha_sender?: string | null;
    };
    /** @example {
     *       "id": "387d1e31-a218-4375-8151-103f2d5e2d2c",
     *       "record_type": "number_order_document",
     *       "file_id": "1e3c5822-0362-4702-8e46-5a129f0d3976",
     *       "requirements_id": "36aaf27d-986b-493c-bd1b-de16af2e4292",
     *       "customer_reference": "MY REF 001",
     *       "requirement_type": "address_proof",
     *       "created_at": "2018-01-01T00:00:00.000000Z"
     *     } */
    UpdateNumberOrderDocumentRequest: {
      /**
       * Format: uuid
       * @example 387d1e31-a218-4375-8151-103f2d5e2d2c
       */
      readonly id?: string;
      /** @example number_order_document */
      readonly record_type?: string;
      /**
       * @description The id of the file to associate as a number order document.
       * @example 1e3c5822-0362-4702-8e46-5a129f0d3976
       */
      file_id?: string;
      /**
       * @description Unique id for a requirement.
       * @example 36aaf27d-986b-493c-bd1b-de16af2e4292
       */
      requirements_id?: string;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @enum {string} */
      readonly requirement_type?:
        | 'address_proof'
        | 'identification'
        | 'reg_form';
      /**
       * Format: datetime
       * @description An ISO 8901 datetime string denoting when the number order document was uploaded.
       * @example 2018-01-01T00:00:00.000000Z
       */
      readonly created_at?: string;
    };
    UpdateNumberOrderPhoneNumberRequest: {
      regulatory_requirements?: components['schemas']['UpdateRegulatoryRequirement'][];
    };
    UpdateNumberOrderRequest: {
      regulatory_requirements?: components['schemas']['UpdateRegulatoryRequirement'][];
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
    };
    /**
     * Outbound Voice Profile
     * @example {
     *       "name": "office",
     *       "traffic_type": "conversational",
     *       "service_plan": "global",
     *       "concurrent_call_limit": 10,
     *       "enabled": true,
     *       "tags": [
     *         "office-profile"
     *       ],
     *       "usage_payment_method": "rate-deck",
     *       "whitelisted_destinations": [
     *         "US",
     *         "BR",
     *         "AU"
     *       ],
     *       "max_destination_rate": 10,
     *       "daily_spend_limit": "100.00",
     *       "daily_spend_limit_enabled": true,
     *       "billing_group_id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58"
     *     }
     */
    UpdateOutboundVoiceProfileRequest: {
      /**
       * @description A user-supplied name to help with organization.
       * @example office
       */
      name: string;
      traffic_type?: components['schemas']['TrafficType'];
      service_plan?: components['schemas']['ServicePlan'];
      /**
       * @description Must be no more than your global concurrent call limit. Null means no limit.
       * @example 10
       */
      concurrent_call_limit?: number | null;
      /**
       * @description Specifies whether the outbound voice profile can be used. Disabled profiles will result in outbound calls being blocked for the associated Connections.
       * @default true
       * @example true
       */
      enabled: boolean;
      /** @example [
       *       "office-profile"
       *     ] */
      tags?: string[];
      usage_payment_method?: components['schemas']['UsagePaymentMethod'];
      /**
       * @description The list of destinations you want to be able to call using this outbound voice profile formatted in alpha2.
       * @default [
       *       "US",
       *       "CA"
       *     ]
       * @example [
       *       "US",
       *       "BR",
       *       "AU"
       *     ]
       */
      whitelisted_destinations: string[];
      /** @description Maximum rate (price per minute) for a Destination to be allowed when making outbound calls. */
      max_destination_rate?: number;
      /**
       * @description The maximum amount of usage charges, in USD, you want Telnyx to allow on this outbound voice profile in a day before disallowing new calls.
       * @example 100.00
       */
      daily_spend_limit?: string;
      /**
       * @description Specifies whether to enforce the daily_spend_limit on this outbound voice profile.
       * @default false
       * @example true
       */
      daily_spend_limit_enabled: boolean;
      call_recording?: components['schemas']['OutboundCallRecording'];
      /**
       * Format: uuid
       * @description The ID of the billing group associated with the outbound proflile. Defaults to null (for no group assigned).
       * @default null
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      billing_group_id: string | null;
    };
    /** @example {
     *       "messaging_profile_id": "dd50eba1-a0c0-4563-9925-b25e842a7cb6",
     *       "messaging_product": "P2P"
     *     } */
    UpdatePhoneNumberMessagingSettingsRequest: {
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id?: string;
      /**
       * @description The requested messaging product the number should be on
       * @example P2P
       */
      messaging_product?: string;
    };
    /** @example {
     *       "id": "dc8e4d67-33a0-4cbb-af74-7b58f05bd494",
     *       "tags": [
     *         "tag"
     *       ],
     *       "address_id": "dc8f39ac-953d-4520-b93b-786ae87db0da",
     *       "external_pin": "1234",
     *       "customer_reference": "customer-reference",
     *       "connection_id": "dc8e4d67-33a0-4cbb-af74-7b58f05bd494",
     *       "billing_group_id": "dc8e4d67-33a0-4cbb-af74-7b58f05bd494",
     *       "number_level_routing": "disabled",
     *       "hd_voice_enabled": true
     *     } */
    UpdatePhoneNumberRequest: {
      /** @description Identifies the type of resource. */
      readonly id?: string;
      /** @description A list of user-assigned tags to help organize phone numbers. */
      tags?: string[];
      /** @description If someone attempts to port your phone number away from Telnyx and your phone number has an external PIN set, we will attempt to verify that you provided the correct external PIN to the winning carrier. Note that not all carriers cooperate with this security mechanism. */
      external_pin?: string;
      /**
       * @description Indicates whether HD voice is enabled for this number.
       * @example true
       */
      hd_voice_enabled?: boolean;
      /**
       * @description A customer reference string for customer look ups.
       * @example MY REF 001
       */
      customer_reference?: string;
      /** @description Identifies the connection associated with the phone number. */
      connection_id?: string;
      /** @description Identifies the billing group associated with the phone number. */
      billing_group_id?: string;
      /**
       * @description Deprecated field, the only value for this is 'disabled'. All routing for numbers should be configured via connection settings.
       * @default enabled
       * @enum {string}
       */
      number_level_routing: 'disabled';
    };
    /** @example {
     *       "tech_prefix_enabled": true,
     *       "translated_number": "+13035559999",
     *       "caller_id_name_enabled": true,
     *       "call_forwarding": {
     *         "call_forwarding_enabled": true,
     *         "forwards_to": "+13035559123",
     *         "forwarding_type": "always"
     *       },
     *       "cnam_listing": {
     *         "cnam_listing_enabled": true,
     *         "cnam_listing_details": "example"
     *       },
     *       "usage_payment_method": "pay-per-minute",
     *       "media_features": {
     *         "rtp_auto_adjust_enabled": true,
     *         "accept_any_rtp_packets_enabled": true,
     *         "t38_fax_gateway_enabled": true
     *       },
     *       "call_recording": {
     *         "inbound_call_recording_enabled": true,
     *         "inbound_call_recording_format": "wav",
     *         "inbound_call_recording_channels": "single"
     *       },
     *       "inbound_call_screening": "disabled"
     *     } */
    UpdatePhoneNumberVoiceSettingsRequest: {
      /**
       * @description Controls whether a tech prefix is enabled for this phone number.
       * @default false
       */
      tech_prefix_enabled: boolean;
      /** @description This field allows you to rewrite the destination number of an inbound call before the call is routed to you. The value of this field may be any alphanumeric value, and the value will replace the number originally dialed. */
      translated_number?: string;
      /**
       * @description Controls whether the caller ID name is enabled for this phone number.
       * @default false
       */
      caller_id_name_enabled: boolean;
      call_forwarding?: components['schemas']['CallForwarding'];
      cnam_listing?: components['schemas']['CnamListing'];
      /**
       * @description Controls whether a number is billed per minute or uses your concurrent channels.
       * @default pay-per-minute
       * @enum {string}
       */
      usage_payment_method: 'pay-per-minute' | 'channel';
      media_features?: components['schemas']['MediaFeatures'];
      call_recording?: components['schemas']['CallRecording'];
      /**
       * @description The inbound_call_screening setting is a phone number configuration option variable that allows users to configure their settings to block or flag fraudulent calls. It can be set to disabled, reject_calls, or flag_calls. This feature has an additional per-number monthly cost associated with it.
       * @default disabled
       * @enum {string}
       */
      inbound_call_screening: 'disabled' | 'reject_calls' | 'flag_calls';
    };
    /** UpdatePortingOrder */
    UpdatePortingOrder: {
      misc?: components['schemas']['PortingOrderMisc'];
      end_user?: components['schemas']['PortingOrderEndUser'];
      documents?: components['schemas']['PortingOrderDocuments'];
      activation_settings?: {
        /**
         * Format: date-time
         * @description ISO 8601 formatted Date/Time requested for the FOC date
         * @example 2021-03-19T10:07:15.527Z
         */
        foc_datetime_requested?: string;
      };
      phone_number_configuration?: components['schemas']['PortingOrderPhoneNumberConfiguration'];
      /**
       * Format: uuid
       * @description If present, we will read the current values from the specified Requirement Group into the Documents and Requirements for this Porting Order. Note that any future changes in the Requirement Group would have no impact on this Porting Order. We will return an error if a specified Requirement Group conflicts with documents or requirements in the same request.
       * @example DE748D99-06FA-4D90-9F9A-F4B62696BADA
       */
      requirement_group_id?: string;
      /** @description List of requirements for porting numbers.  */
      requirements?: components['schemas']['UpdatePortingOrderRequirement'][];
      user_feedback?: components['schemas']['PortingOrderUserFeedback'];
      /** Format: uri */
      webhook_url?: string;
      customer_reference?: string;
      messaging?: {
        /**
         * @description Indicates whether Telnyx will port messaging capabilities from the losing carrier. If false, any messaging capabilities will stay with their current provider.
         * @example true
         */
        enable_messaging?: boolean;
      };
    };
    /** @description Specifies a value for a requirement on the Porting Order. */
    UpdatePortingOrderRequirement: {
      /**
       * @description identifies the document or provides the text value that satisfies this requirement
       * @example 9787fb5f-cbe5-4de4-b765-3303774ee9fe
       */
      field_value: string;
      /**
       * @description Identifies the requirement type that the `field_value` fulfills
       * @example 59b0762a-b274-4f76-ac32-4d5cf0272e66
       */
      requirement_type_id: string;
    };
    UpdateRegulatoryRequirement: {
      /**
       * Format: uuid
       * @description Unique id for a requirement.
       * @example 8ffb3622-7c6b-4ccc-b65f-7a3dc0099576
       */
      requirement_id?: string;
      /**
       * @description The value of the requirement. For address and document requirements, this should be the ID of the resource. For textual, this should be the value of the requirement.
       * @example 45f45a04-b4be-4592-95b1-9306b9db2b21
       */
      field_value?: string;
    };
    /** @example {
     *       "messaging_profile_id": "abc85f64-5717-4562-b3fc-2c9600000000"
     *     } */
    UpdateShortCodeRequest: {
      /** @description Unique identifier for a messaging profile. */
      messaging_profile_id: string;
    };
    UpdateSubNumberOrderRequest: {
      regulatory_requirements?: components['schemas']['UpdateRegulatoryRequirement'][];
    };
    /**
     * Update Texml Application Request
     * @example {
     *       "friendly_name": "call-router",
     *       "active": false,
     *       "anchorsite_override": "Amsterdam, Netherlands",
     *       "dtmf_type": "Inband",
     *       "first_command_timeout": true,
     *       "first_command_timeout_secs": 10,
     *       "voice_url": "https://example.com",
     *       "voice_fallback_url": "https://fallback.example.com",
     *       "voice_method": "get",
     *       "status_callback": "https://example.com",
     *       "status_callback_method": "get",
     *       "inbound": {
     *         "channel_limit": 10,
     *         "shaken_stir_enabled": true,
     *         "sip_subdomain": "example",
     *         "sip_subdomain_receive_settings": "only_my_connections"
     *       },
     *       "outbound": {
     *         "channel_limit": 10,
     *         "outbound_voice_profile_id": "1293384261075731499"
     *       }
     *     }
     */
    UpdateTexmlApplicationRequest: {
      friendly_name: components['schemas']['ApplicationName'];
      active?: components['schemas']['ConnectionActive'];
      anchorsite_override?: components['schemas']['AnchorsiteOverride'];
      dtmf_type?: components['schemas']['DtmfType'];
      first_command_timeout?: components['schemas']['FirstCommandTimeout'];
      first_command_timeout_secs?: components['schemas']['FirstCommandTimeoutSecs'];
      /**
       * Format: url
       * @description URL to which Telnyx will deliver your XML Translator webhooks.
       * @example https://example.com
       */
      voice_url: string;
      /**
       * Format: url
       * @description URL to which Telnyx will deliver your XML Translator webhooks if we get an error response from your voice_url.
       * @default null
       * @example https://fallback.example.com
       */
      voice_fallback_url: string;
      /**
       * @description HTTP request method Telnyx will use to interact with your XML Translator webhooks. Either 'get' or 'post'.
       * @default post
       * @example get
       * @enum {string}
       */
      voice_method: 'get' | 'post';
      /**
       * Format: url
       * @description URL for Telnyx to send requests to containing information about call progress events.
       * @default null
       * @example https://example.com
       */
      status_callback: string;
      /**
       * @description HTTP request method Telnyx should use when requesting the status_callback URL.
       * @default post
       * @example get
       * @enum {string}
       */
      status_callback_method: 'get' | 'post';
      inbound?: {
        /**
         * @description When set, this will limit the total number of inbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        /**
         * @description When enabled Telnyx will include Shaken/Stir data in the Webhook for new inbound calls.
         * @default false
         * @example false
         */
        shaken_stir_enabled: boolean;
        /**
         * @description Specifies a subdomain that can be used to receive Inbound calls to a Connection, in the same way a phone number is used, from a SIP endpoint. Example: the subdomain "example.sip.telnyx.com" can be called from any SIP endpoint by using the SIP URI "sip:@example.sip.telnyx.com" where the user part can be any alphanumeric value. Please note TLS encrypted calls are not allowed for subdomain calls.
         * @default null
         * @example example
         */
        sip_subdomain: string;
        /**
         * @description This option can be enabled to receive calls from: "Anyone" (any SIP endpoint in the public Internet) or "Only my connections" (any connection assigned to the same Telnyx user).
         * @default from_anyone
         * @example only_my_connections
         * @enum {string}
         */
        sip_subdomain_receive_settings: 'only_my_connections' | 'from_anyone';
      };
      outbound?: {
        /**
         * @description When set, this will limit the total number of outbound calls to phone numbers associated with this connection.
         * @default null
         * @example 10
         */
        channel_limit: number;
        outbound_voice_profile_id?: components['schemas']['OutboundVoiceProfileId'];
      };
    };
    /** UpdateVerifyProfileCallRequest */
    UpdateVerifyProfileCallRequest: {
      /**
       * Format: uuid
       * @description The message template identifier selected from /verify_profiles/templates
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      messaging_template_id?: string;
      /**
       * @description The name that identifies the application requesting 2fa in the verification message.
       * @example Example Secure App
       */
      app_name?: string;
      /**
       * @description The length of the verify code to generate.
       * @default 5
       * @example 6
       */
      code_length: number;
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** UpdateVerifyProfileFlashcallRequest */
    UpdateVerifyProfileFlashcallRequest: {
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** UpdateVerifyProfileSMSRequest */
    UpdateVerifyProfileSMSRequest: {
      /**
       * Format: uuid
       * @description The message template identifier selected from /verify_profiles/templates
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      messaging_template_id?: string;
      /**
       * @description The name that identifies the application requesting 2fa in the verification message.
       * @example Example Secure App
       */
      app_name?: string;
      /**
       * @description The alphanumeric sender ID to use when sending to destinations that require an alphanumeric sender ID.
       * @default Telnyx
       */
      alpha_sender: string;
      /**
       * @description The length of the verify code to generate.
       * @default 5
       * @example 6
       */
      code_length: number;
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /**
     * @description ISO 8601 formatted date-time indicating when the resource was updated.
     * @example 2018-02-02T22:25:27.521Z
     */
    UpdatedAt: string;
    UplinkData: {
      /**
       * @description Uplink data
       * @example 1
       */
      amount?: number;
      /**
       * @description Transmission unit
       * @default MB
       * @enum {string}
       */
      unit: 'B' | 'KB' | 'MB';
    };
    /** Upload */
    Upload: {
      ticket_id?: components['schemas']['UUID'];
      /**
       * Format: uuid
       * @example ea175aba-f47c-4702-9400-efaa42688048
       */
      tenant_id?: string;
      /**
       * Format: uuid
       * @example c37e5036-1e87-42e6-86a2-b3e8dd39a2ad
       */
      location_id?: string;
      /**
       * @description Represents the status of the upload on Microsoft Teams.
       * @default pending_upload
       * @example error
       * @enum {string}
       */
      status:
        | 'pending_upload'
        | 'pending'
        | 'in_progress'
        | 'partial_success'
        | 'success'
        | 'error';
      available_usages?: (
        | 'calling_user_assignment'
        | 'first_party_app_assignment'
      )[];
      /** @description A code returned by Microsoft Teams if there is an error with the upload process. */
      error_code?: string;
      /** @description A message set if there is an error with the upload process. */
      error_message?: string;
      tn_upload_entries?: components['schemas']['TnUploadEntry'][];
    };
    /** @example {
     *       "loa": "example loa",
     *       "bill": "bill example"
     *     } */
    UploadFileMessagingHostedNumberOrderRequest: {
      /**
       * Format: binary
       * @description Must be a signed LOA for the numbers in the order in PDF format.
       */
      loa?: string;
      /**
       * Format: binary
       * @description Must be the last month's bill with proof of ownership of all of the numbers in the order in PDF format.
       */
      bill?: string;
    };
    /**
     * Upload media multipart request
     * @example {
     *       "media": "string($binary)",
     *       "ttl_secs": 86400,
     *       "media_name": "my-file"
     *     }
     */
    UploadMediaMultipartRequest: {
      /**
       * Format: binary
       * @description The file you want to upload. The maximum allowed size is 20 MB.
       */
      media: string;
      /**
       * @description The number of seconds after which the media resource will be deleted, defaults to 2 days. The maximum allowed vale is 630720000, which translates to 20 years.
       * @example 86400
       */
      ttl_secs?: number;
      /**
       * @description The unique identifier of a file.
       * @example my_file
       */
      media_name?: string;
    };
    /**
     * Upload media request
     * @example {
     *       "media_url": "http://www.example.com/audio.mp3",
     *       "ttl_secs": 86400,
     *       "media_name": "my-file"
     *     }
     */
    UploadMediaRequest: {
      /**
       * @description The URL where the media to be stored in Telnyx network is currently hosted. The maximum allowed size is 20 MB.
       * @example http://www.example.com/audio.mp3
       */
      media_url: string;
      /**
       * @description The number of seconds after which the media resource will be deleted, defaults to 2 days. The maximum allowed vale is 630720000, which translates to 20 years.
       * @example 86400
       */
      ttl_secs?: number;
      /**
       * @description The unique identifier of a file.
       * @example my_file
       */
      media_name?: string;
    };
    /** Url */
    Url: {
      /**
       * Url
       * Format: uri
       */
      url: string;
    };
    /**
     * @description The URL shortener feature allows automatic replacement of URLs that were generated using
     *     a public URL shortener service. Some examples include bit.do, bit.ly, goo.gl, ht.ly,
     *     is.gd, ow.ly, rebrand.ly, t.co, tiny.cc, and tinyurl.com. Such URLs are replaced with
     *     with links generated by Telnyx. The use of custom links can improve branding and message
     *     deliverability.
     *
     *     To disable this feature, set the object field to `null`.
     *
     * @example {
     *       "domain": "example.ex",
     *       "prefix": "",
     *       "replace_blacklist_only": true,
     *       "send_webhooks": false
     *     }
     */
    UrlShortenerSettings: {
      /**
       * @description One of the domains provided by the Telnyx URL shortener service.
       *
       * @example acct.fyi
       */
      domain: string;
      /**
       * @description Optional prefix that can be used to identify your brand, and will appear in the Telnyx generated URLs after the domain name.
       *
       * @example
       */
      prefix?: string;
      /**
       * @description Use the link replacement tool only for links that are specifically blacklisted by Telnyx.
       *
       * @example true
       */
      replace_blacklist_only?: boolean;
      /**
       * @description Receive webhooks for when your replaced links are clicked. Webhooks are sent to the webhooks on the messaging profile.
       *
       * @example false
       */
      send_webhooks?: boolean;
    } | null;
    /**
     * @description Setting for how costs for outbound profile are calculated.
     * @default rate-deck
     * @example rate-deck
     * @enum {string}
     */
    UsagePaymentMethod: 'rate-deck';
    /** @description An object following one of the schemas published in https://developers.telnyx.com/docs/api/v2/detail-records */
    UsageReportsOptionsRecord: {
      /**
       * @description Telnyx Product
       * @example wireless
       */
      product?: string;
      /**
       * @description Telnyx Product Dimensions
       * @example ['mnc', 'mcc', 'sim_card_id', 'sim_group_name']
       */
      product_dimensions?: string[];
      /**
       * @description Telnyx Product Metrics
       * @example ['uplink_data_bytes','downlink_data','downlink_data_bytes','uplink_data','data_cost']
       */
      product_metrics?: string[];
      /**
       * @description Subproducts if applicable
       * @example null
       */
      record_types?: components['schemas']['RecordType'][];
    };
    /** @description An object following one of the schemas published in https://developers.telnyx.com/docs/api/v2/detail-records */
    UsageReportsOptionsResponse: {
      /** @description Collection of product description */
      data?: components['schemas']['UsageReportsOptionsRecord'][];
    };
    UsageReportsResponse: {
      meta?: components['schemas']['PaginationData'];
      /** @example [
       *       {
       *         "product": "messaging",
       *         "cost": 0.012,
       *         "parts": 12,
       *         "count": 8,
       *         "customer_carrier_fee": 0,
       *         "product_name": "long_code",
       *         "country_iso": "LC",
       *         "direction": "outbound"
       *       },
       *       {
       *         "product": "messaging",
       *         "cost": 0.021,
       *         "parts": 21,
       *         "count": 12,
       *         "customer_carrier_fee": 0,
       *         "product_name": "long_code",
       *         "country_iso": "MP",
       *         "direction": "outbound"
       *       }
       *     ] */
      data?: Record<string, never>[];
    };
    /**
     * UseCaseCategories
     * @description Tollfree usecase categories
     * @enum {string}
     */
    UseCaseCategories:
      | '2FA'
      | 'App Notifications'
      | 'Appointments'
      | 'Auctions'
      | 'Auto Repair Services'
      | 'Bank Transfers'
      | 'Billing'
      | 'Booking Confirmations'
      | 'Business Updates'
      | 'COVID-19 Alerts'
      | 'Career Training'
      | 'Chatbot'
      | 'Conversational / Alerts'
      | 'Courier Services & Deliveries'
      | 'Emergency Alerts'
      | 'Events & Planning'
      | 'Financial Services'
      | 'Fraud Alerts'
      | 'Fundraising'
      | 'General Marketing'
      | 'General School Updates'
      | 'HR / Staffing'
      | 'Healthcare Alerts'
      | 'Housing Community Updates'
      | 'Insurance Services'
      | 'Job Dispatch'
      | 'Legal Services'
      | 'Mixed'
      | 'Motivational Reminders'
      | 'Notary Notifications'
      | 'Order Notifications'
      | 'Political'
      | 'Public Works'
      | 'Real Estate Services'
      | 'Religious Services'
      | 'Repair and Diagnostics Alerts'
      | 'Rewards Program'
      | 'Surveys'
      | 'System Alerts'
      | 'Voting Reminders'
      | 'Waitlist Alerts'
      | 'Webinar Reminders'
      | 'Workshop Alerts';
    /**
     * Usecase
     * @description Campaign usecase. Must be of defined valid types. For more details, send a GET request to https://api.telnyx.com/10dlc/enum/usecase
     * @example MARKETING
     * @enum {unknown}
     */
    Usecase:
      | '2FA'
      | 'ACCOUNT_NOTIFICATION'
      | 'AGENTS_FRANCHISES'
      | 'CARRIER_EXEMPT'
      | 'CHARITY'
      | 'CONVERSATIONAL'
      | 'CUSTOMER_CARE'
      | 'DELIVERY_NOTIFICATION'
      | 'EMERGENCY'
      | 'FRAUD_ALERT'
      | 'HIGHER_EDUCATION'
      | 'LOW_VOLUME'
      | 'MARKETING'
      | 'MANUFACTURING'
      | 'MIXED'
      | 'POLITICAL'
      | 'POLLING_VOTING'
      | 'PUBLIC_SERVICE_ANNOUNCEMENT'
      | 'SECURITY_ALERT'
      | 'SOCIAL'
      | 'SWEEPSTAKE'
      | 'SOLE_PROPRIETOR'
      | 'TRIAL';
    /** UsecaseMetadata */
    UsecaseMetadata: {
      /**
       * Annualfee
       * @description Campaign annual subscription fee
       */
      annualFee?: number;
      /**
       * Maxsubusecases
       * @description Maximum number of sub-usecases declaration required.
       */
      maxSubUsecases?: number;
      /**
       * Minsubusecases
       * @description Minimum number of sub-usecases declaration required.
       */
      minSubUsecases?: number;
      /**
       * Mnometadata
       * @description Map of usecase metadata for each MNO. Key is the network ID of the MNO (e.g. 10017), Value is the mno metadata for the usecase.
       */
      mnoMetadata?: Record<string, never>;
      /**
       * Monthlyfee
       * @description Campaign monthly subscription fee
       */
      monthlyFee?: number;
      /**
       * Quarterlyfee
       * @description Campaign quarterly subscription fee
       */
      quarterlyFee?: number;
      /**
       * Usecase
       * @description Campaign usecase
       */
      usecase?: string;
    };
    /** @example {
     *       "record_type": "balance",
     *       "pending": "10.00",
     *       "balance": "300.00",
     *       "credit_limit": "100.00",
     *       "available_credit": "400.00",
     *       "currency": "USD"
     *     } */
    UserBalance: {
      /**
       * Format: decimal
       * @description The account’s pending amount.
       * @example 10.00
       */
      pending?: string;
      /**
       * @description Identifies the type of the resource.
       * @example balance
       * @enum {string}
       */
      record_type?: 'balance';
      /**
       * Format: decimal
       * @description The account's current balance.
       * @example 300.00
       */
      balance?: string;
      /**
       * Format: decimal
       * @description The account's credit limit.
       * @example 100.00
       */
      credit_limit?: string;
      /**
       * Format: decimal
       * @description Available amount to spend (balance + credit limit)
       * @example 400.00
       */
      available_credit?: string;
      /**
       * Format: iso4217
       * @description The ISO 4217 currency identifier.
       * @example USD
       */
      currency?: string;
    };
    /** UserEmbeddedBuckets */
    UserEmbeddedBuckets: {
      /** Buckets */
      buckets: string[];
    };
    /** UserEmbeddedBucketsData */
    UserEmbeddedBucketsData: {
      data: components['schemas']['UserEmbeddedBuckets'];
    };
    /**
     * Format: uuid
     * @description Identifier of the user to whom the fax belongs
     * @example yfff7c54-4df3-4bca-a65a-3da1ecc777f0
     */
    UserId: string;
    UserRequirement: {
      requirement_id?: string;
      field_value?: string;
      field_type?: string;
      /** @enum {string} */
      status?: 'approved' | 'unapproved' | 'pending-approval' | 'declined';
      /** Format: date-time */
      created_at?: string;
      /** Format: date-time */
      updated_at?: string;
    };
    ValidateAddress: {
      street_address?: components['schemas']['street_address'];
      extended_address?: components['schemas']['extended_address'];
      locality?: components['schemas']['locality'];
      administrative_area?: components['schemas']['administrative_area'];
      postal_code?: components['schemas']['postal_code'];
      country_code?: components['schemas']['country_code'];
    };
    ValidateAddressRequest: {
      street_address: components['schemas']['street_address'];
      extended_address?: components['schemas']['extended_address'];
      locality?: components['schemas']['locality'];
      administrative_area?: components['schemas']['administrative_area'];
      postal_code: components['schemas']['postal_code'];
      country_code: components['schemas']['country_code'];
    };
    /** Validate address action result */
    ValidateAddressResult: {
      /**
       * @description Indicates whether an address is valid or invalid.
       * @example valid
       * @enum {string}
       */
      result: 'valid' | 'invalid';
      /** @description Provides normalized address when available. */
      suggested: components['schemas']['ValidateAddress'];
      /**
       * @description Identifies the type of the resource.
       * @example address_validation
       */
      record_type?: string;
      errors?: components['schemas']['Error'][];
    };
    /** ValidationError */
    ValidationError: {
      /** Location */
      loc: (string | number)[];
      /** Message */
      msg: string;
      /** Error Type */
      type: string;
    };
    /** Verification */
    Verification: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      id?: string;
      type?: components['schemas']['VerificationType'];
      record_type?: components['schemas']['VerificationRecordType'];
      /**
       * @description +E164 formatted phone number.
       * @example +13035551234
       */
      phone_number?: string;
      /**
       * Format: uuid
       * @description The identifier of the associated Verify profile.
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      verify_profile_id?: string;
      /**
       * @description Send a self-generated numeric code to the end-user
       * @default null
       * @example 43612
       */
      custom_code: string | null;
      /**
       * @description This is the number of seconds before the code of the request is expired. Once this request has expired, the code will no longer verify the user. Note: this will override the `default_verification_timeout_secs` on the Verify profile.
       * @example 300
       */
      timeout_secs?: number;
      status?: components['schemas']['VerificationStatus'];
      /** @example 2020-09-14T17:03:32.965812 */
      created_at?: string;
      /** @example 2020-09-14T17:03:32.965812 */
      updated_at?: string;
    };
    /**
     * VerificationProfileRecordType
     * @description The possible verification profile record types.
     * @example verification_profile
     * @enum {string}
     */
    VerificationProfileRecordType: 'verification_profile';
    /**
     * VerificationRecordType
     * @description The possible verification record types.
     * @example verification
     * @enum {string}
     */
    VerificationRecordType: 'verification';
    /**
     * VerificationRequestEgress
     * @description A verification request as it comes out of the database
     */
    VerificationRequestEgress: {
      /**
       * Businessname
       * @example Telnyx LLC
       */
      businessName: string;
      /**
       * Corporatewebsite
       * @example http://example.com
       */
      corporateWebsite: string;
      /**
       * Businessaddr1
       * @example 311 W Superior St
       */
      businessAddr1: string;
      /**
       * Businessaddr2
       * @example 121 W Superior St
       */
      businessAddr2?: string;
      /**
       * Businesscity
       * @example Chicago
       */
      businessCity: string;
      /**
       * Businessstate
       * @example Illinois
       */
      businessState: string;
      /**
       * Businesszip
       * @example 60654
       */
      businessZip: string;
      /**
       * Businesscontactfirstname
       * @example John
       */
      businessContactFirstName: string;
      /**
       * Businesscontactlastname
       * @example Doe
       */
      businessContactLastName: string;
      /**
       * Businesscontactemail
       * @example email@example.com
       */
      businessContactEmail: string;
      /**
       * Businesscontactphone
       * @example +18005550100
       */
      businessContactPhone: string;
      /**
       * @description One of the following exact values: 10; 100; 1,000; 10,000; 100,000; 250,000; 500,000; 750,000; 1,000,000; 5,000,000; 10,000,000+
       * @example 100,000
       */
      messageVolume: components['schemas']['Volume'];
      /**
       * Phonenumbers
       * @example [
       *       {
       *         "phoneNumber": "+18773554398"
       *       },
       *       {
       *         "phoneNumber": "+18773554399"
       *       }
       *     ]
       */
      phoneNumbers: components['schemas']['TFPhoneNumber'][];
      /** @example 2FA */
      useCase: components['schemas']['UseCaseCategories'];
      /**
       * Usecasesummary
       * @example This is a use case where Telnyx sends out 2FA codes to portal users to verify their identity in order to sign into the portal
       */
      useCaseSummary: string;
      /**
       * Productionmessagecontent
       * @example Your Telnyx OTP is XXXX
       */
      productionMessageContent: string;
      /**
       * Optinworkflow
       * @example User signs into the Telnyx portal, enters number and is prompted to select whether they want to use 2FA verification for security purposes. If they've opted in a confirmation message is sent out to the handset
       */
      optInWorkflow: string;
      /**
       * Optinworkflowimageurls
       * @example [
       *       {
       *         "url": "https://telnyx.com/sign-up"
       *       },
       *       {
       *         "url": "https://telnyx.com/company/data-privacy"
       *       }
       *     ]
       */
      optInWorkflowImageURLs: components['schemas']['Url'][];
      /**
       * Additionalinformation
       * @example This is for security purposes, blah blah blah
       */
      additionalInformation: string;
      /**
       * Isvreseller
       * @example Yes
       */
      isvReseller: string;
      /**
       * Webhookurl
       * @example http://example-webhook.com
       */
      webhookUrl?: string;
      /**
       * Id
       * Format: uuid
       */
      id: string;
      /** Verificationrequestid */
      verificationRequestId: string;
      /** @default In Progress */
      verificationStatus: components['schemas']['TFVerificationStatus'];
    };
    /**
     * VerificationRequestStatus
     * @description A verification request and its status, suitable for returning to users
     */
    VerificationRequestStatus: {
      /**
       * Businessname
       * @example Telnyx LLC
       */
      businessName: string;
      /**
       * Corporatewebsite
       * @example http://example.com
       */
      corporateWebsite: string;
      /**
       * Businessaddr1
       * @example 311 W Superior St
       */
      businessAddr1: string;
      /**
       * Businessaddr2
       * @example 121 W Superior St
       */
      businessAddr2?: string;
      /**
       * Businesscity
       * @example Chicago
       */
      businessCity: string;
      /**
       * Businessstate
       * @example Illinois
       */
      businessState: string;
      /**
       * Businesszip
       * @example 60654
       */
      businessZip: string;
      /**
       * Businesscontactfirstname
       * @example John
       */
      businessContactFirstName: string;
      /**
       * Businesscontactlastname
       * @example Doe
       */
      businessContactLastName: string;
      /**
       * Businesscontactemail
       * @example email@example.com
       */
      businessContactEmail: string;
      /**
       * Businesscontactphone
       * @example +18889809750
       */
      businessContactPhone: string;
      /**
       * @description One of the following exact values: 10; 100; 1,000; 10,000; 100,000; 250,000; 500,000; 750,000; 1,000,000; 5,000,000; 10,000,000+
       * @example 100,000
       */
      messageVolume: components['schemas']['Volume'];
      /**
       * Phonenumbers
       * @example [
       *       {
       *         "phoneNumber": "+18773554398"
       *       },
       *       {
       *         "phoneNumber": "+18773554399"
       *       }
       *     ]
       */
      phoneNumbers: components['schemas']['TFPhoneNumber'][];
      /** @example 2FA */
      useCase: components['schemas']['UseCaseCategories'];
      /**
       * Usecasesummary
       * @example This is a use case where Telnyx sends out 2FA codes to portal users to verify their identity in order to sign into the portal
       */
      useCaseSummary: string;
      /**
       * Productionmessagecontent
       * @example Your Telnyx OTP is XXXX
       */
      productionMessageContent: string;
      /**
       * Optinworkflow
       * @example User signs into the Telnyx portal, enters number and is prompted to select whether they want to use 2FA verification for security purposes. If they've opted in a confirmation message is sent out to the handset
       */
      optInWorkflow: string;
      /**
       * Optinworkflowimageurls
       * @example [
       *       {
       *         "url": "https://telnyx.com/sign-up"
       *       },
       *       {
       *         "url": "https://telnyx.com/company/data-privacy"
       *       }
       *     ]
       */
      optInWorkflowImageURLs: components['schemas']['Url'][];
      /**
       * Additionalinformation
       * @example This is for security purposes, blah blah blah
       */
      additionalInformation: string;
      /**
       * Isvreseller
       * @example Yes
       */
      isvReseller: string;
      /**
       * Webhookurl
       * @example http://example-webhook.com
       */
      webhookUrl?: string;
      /**
       * Id
       * Format: uuid
       * @example eaba9f52-164e-58e0-b002-4f668e18b7ed
       */
      id: string;
      /** @example Pending Customer Feedback */
      verificationStatus: components['schemas']['TFVerificationStatus'];
      /**
       * Reason
       * @example Unfortunately, we have to cancel this request as we do not support non tollfree US numbers.
       */
      reason?: string;
      /**
       * Createdat
       * Format: date-time
       * @example 2024-01-23T18:10:02.574Z
       */
      createdAt?: string;
      /**
       * Updatedat
       * Format: date-time
       * @example 2024-01-23T18:10:02.574Z
       */
      updatedAt?: string;
    };
    /**
     * VerificationStatus
     * @description The possible statuses of the verification request.
     * @example accepted
     * @enum {string}
     */
    VerificationStatus:
      | 'pending'
      | 'accepted'
      | 'invalid'
      | 'expired'
      | 'error';
    /**
     * VerificationType
     * @description The possible types of verification.
     * @example sms
     * @enum {string}
     */
    VerificationType: 'sms' | 'call' | 'flashcall';
    /**
     * VerifiedNumberRecordType
     * @description The possible verified numbers record types.
     * @example verified_number
     * @enum {string}
     */
    VerifiedNumberRecordType: 'verified_number';
    /** VerifiedNumberResponse */
    VerifiedNumberResponse: {
      /** @example +15551234567 */
      phone_number?: string;
      record_type?: components['schemas']['VerifiedNumberRecordType'];
      /** @example 2020-09-14T17:03:32.965812 */
      verified_at?: string;
    };
    /** VerifiedNumberResponseDataWrapper */
    VerifiedNumberResponseDataWrapper: {
      data?: components['schemas']['VerifiedNumberResponse'];
    };
    VerifyDetailRecord: {
      /**
       * Format: uuid
       * @description Unique ID of the verification
       * @example 0add777f-1549-46f7-84e9-ad7350f6aa97
       */
      id?: string;
      /**
       * Format: uuid
       * @example 49000176-1ab2-8bc1-352e-4009f6c37f82
       */
      verify_profile_id?: string;
      /** @example pending */
      delivery_status?: string;
      /** @example pending */
      verification_status?: string;
      /**
       * @description E.164 formatted phone number
       * @example +13124515883
       */
      destination_phone_number?: string;
      /**
       * @description Depending on the type of verification, the `verify_channel_id`
       *     points to one of the following channel ids;
       *     ---
       *     verify_channel_type | verify_channel_id
       *     ------------------- | -----------------
       *     sms, psd2           | messaging_id
       *     call, flashcall     | call_control_id
       *     whatsapp            | messaging_whatsapp_id
       *     ---
       *
       * @enum {string}
       */
      verify_channel_type?: 'sms' | 'psd2' | 'call' | 'flashcall' | 'whatsapp';
      /**
       * Format: uuid
       * @example 5b7a8365-91f3-420a-befc-498d1efd6c20
       */
      verify_channel_id?: string;
      /**
       * Format: datetime
       * @example 2021-07-08T00:00:41.000000+00:00
       */
      created_at?: string;
      /**
       * Format: datetime
       * @example 2021-07-08T00:00:41.000000+00:00
       */
      updated_at?: string;
      /**
       * @description Currency amount per billing unit used to calculate the Telnyx billing costs
       * @example 0.002
       */
      rate?: string;
      /**
       * @description Billing unit used to calculate the Telnyx billing costs
       * @example number of occurrences
       */
      rate_measured_in?: string;
      /**
       * @description Currency amount for Verify Usage Fee
       * @example 0.002
       */
      verify_usage_fee?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing costs
       * @example USD
       */
      currency?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'VerifyDetailRecord';
    };
    /** VerifyProfileCallResponse */
    VerifyProfileCallResponse: {
      /**
       * Format: uuid
       * @description The message template identifier selected from /verify_profiles/templates
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      messaging_template_id?: string;
      /**
       * @description The name that identifies the application requesting 2fa in the verification message.
       * @example Example Secure App
       */
      app_name?: string;
      /**
       * @description The length of the verify code to generate.
       * @default 5
       * @example 6
       */
      code_length: number;
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** VerifyProfileFlashcallResponse */
    VerifyProfileFlashcallResponse: {
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** VerifyProfileResponse */
    VerifyProfileMessageTemplateResponse: {
      /**
       * Format: uuid
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      id?: string;
      /** @example Your {{app_name}} verification code is: {{code}}. */
      text?: string;
    };
    /** VerifyProfileResponse */
    VerifyProfileResponse: {
      /**
       * Format: uuid
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      id?: string;
      /** @example Test Profile */
      name?: string;
      /** @example http://example.com/webhook */
      webhook_url?: string;
      /** @example http://example.com/webhook/failover */
      webhook_failover_url?: string;
      record_type?: components['schemas']['VerificationProfileRecordType'];
      /** @example 2020-09-14T17:03:32.965812 */
      created_at?: string;
      /** @example 2020-09-14T17:03:32.965812 */
      updated_at?: string;
      sms?: components['schemas']['VerifyProfileSMSResponse'];
      call?: components['schemas']['VerifyProfileCallResponse'];
      flashcall?: components['schemas']['VerifyProfileFlashcallResponse'];
      /** @example en-US */
      language?: string;
    };
    /** VerifyProfileResponseDataWrapper */
    VerifyProfileResponseDataWrapper: {
      data?: components['schemas']['VerifyProfileResponse'];
    };
    /** VerifyProfileSMSResponse */
    VerifyProfileSMSResponse: {
      /**
       * Format: uuid
       * @description The message template identifier selected from /verify_profiles/templates
       * @example 0abb5b4f-459f-445a-bfcd-488998b7572d
       */
      messaging_template_id?: string;
      /**
       * @description The name that identifies the application requesting 2fa in the verification message.
       * @example Example Secure App
       */
      app_name?: string;
      /**
       * @description The alphanumeric sender ID to use when sending to destinations that require an alphanumeric sender ID.
       * @default Telnyx
       */
      alpha_sender: string;
      /**
       * @description The length of the verify code to generate.
       * @default 5
       * @example 6
       */
      code_length: number;
      /**
       * @description Enabled country destinations to send verification codes. The elements in the list must be valid ISO 3166-1 alpha-2 country codes. If set to `["*"]`, all destinations will be allowed.
       * @example [
       *       "US",
       *       "CA"
       *     ]
       */
      whitelisted_destinations?: string[];
      /**
       * @description For every request that is initiated via this Verify profile, this sets the number of seconds before a verification request code expires. Once the verification request expires, the user cannot use the code to verify their identity.
       * @default 300
       * @example 300
       */
      default_verification_timeout_secs: number;
    };
    /** VerifyVerificationCodeRequestById */
    VerifyVerificationCodeRequestById: {
      /**
       * @description This is the code the user submits for verification.
       * @example 17686
       */
      code: string;
    };
    /** VerifyVerificationCodeRequestByPhoneNumber */
    VerifyVerificationCodeRequestByPhoneNumber: {
      /**
       * @description This is the code the user submits for verification.
       * @example 17686
       */
      code: string;
      /**
       * Format: uuid
       * @description The identifier of the associated Verify profile.
       * @example 12ade33a-21c0-473b-b055-b3c836e1c292
       */
      verify_profile_id: string;
    };
    /** VerifyVerificationCodeResponse */
    VerifyVerificationCodeResponse: {
      data: {
        /**
         * @description +E164 formatted phone number.
         * @example +13035551234
         */
        phone_number: string;
        /**
         * @description Identifies if the verification code has been accepted or rejected.
         * @example accepted
         * @enum {string}
         */
        response_code: 'accepted' | 'rejected';
      };
    };
    /**
     * Vertical
     * @description Vertical or industry segment of the brand or campaign.
     * @example TECHNOLOGY
     * @enum {unknown}
     */
    Vertical:
      | 'REAL_ESTATE'
      | 'HEALTHCARE'
      | 'ENERGY'
      | 'ENTERTAINMENT'
      | 'RETAIL'
      | 'AGRICULTURE'
      | 'INSURANCE'
      | 'EDUCATION'
      | 'HOSPITALITY'
      | 'FINANCIAL'
      | 'GAMBLING'
      | 'CONSTRUCTION'
      | 'NGO'
      | 'MANUFACTURING'
      | 'GOVERNMENT'
      | 'TECHNOLOGY'
      | 'COMMUNICATION';
    /** VettingClass */
    VettingClass: {
      /** Id */
      id?: string;
      /** Enabled */
      enabled?: boolean;
      /** Displayname */
      displayName?: string;
      /** Description */
      description?: string;
      /** Validitymonths */
      validityMonths?: number;
    };
    /**
     * VettingStatus
     * @description An enumeration.
     * @enum {string}
     */
    VettingStatus:
      | 'PENDING'
      | 'ACTIVE'
      | 'EXPIRED'
      | 'ERROR'
      | 'CONTACT_VENDOR'
      | 'SIMULATION';
    VideoRegion: {
      /**
       * @description X axis value (in pixels) of the region's upper left corner relative to the upper left corner of the whole room composition viewport.
       * @default 0
       * @example 100
       */
      x_pos: number | null;
      /**
       * @description Y axis value (in pixels) of the region's upper left corner relative to the upper left corner of the whole room composition viewport.
       * @default 0
       * @example 100
       */
      y_pos: number | null;
      /**
       * @description Regions with higher z_pos values are stacked on top of regions with lower z_pos values
       * @default 0
       * @example 1
       */
      z_pos: number | null;
      /**
       * @description Height of the video region
       * @example 360
       */
      height?: number | null;
      /**
       * @description Width of the video region
       * @example 480
       */
      width?: number | null;
      /**
       * @description Maximum number of columns of the region's placement grid. By default, the region has as many columns as needed to layout all the specified video sources.
       * @example 3
       */
      max_columns?: number | null;
      /**
       * @description Maximum number of rows of the region's placement grid. By default, the region has as many rows as needed to layout all the specified video sources.
       * @example 3
       */
      max_rows?: number | null;
      /** @description Array of video recording ids to be composed in the region. Can be "*" to specify all video recordings in the session */
      video_sources?: string[];
    };
    VirtualCrossConnect: components['schemas']['Record'] &
      components['schemas']['Interface'] & {
        /**
         * @description Identifies the type of the resource.
         * @example virtual_cross_connect
         */
        readonly record_type?: string;
        /**
         * @description The Virtual Private Cloud with which you would like to establish a cross connect.
         * @example aws
         * @enum {string}
         */
        cloud_provider?: 'aws' | 'azure' | 'gce';
        /**
         * @description The region where your Virtual Private Cloud hosts are located.<br /><br />The available regions can be found using the /virtual_cross_connect_regions endpoint.
         * @example us-east-1
         */
        cloud_provider_region?: string;
        /**
         * @description The Border Gateway Protocol (BGP) Autonomous System Number (ASN). If null, value will be assigned by Telnyx.
         * @example 1234
         */
        bgp_asn?: number;
        /**
         * @description The desired throughput in Megabits per Second (Mbps) for your Virtual Cross Connect.<br /><br />The available bandwidths can be found using the /virtual_cross_connect_regions endpoint.
         * @example 50
         */
        bandwidth_mbps?: number;
        /**
         * @description Indicates whether the primary circuit is enabled. Setting this to `false` will disable the circuit.
         * @example true
         */
        readonly primary_enabled?: boolean;
        /**
         * @description The identifier for your Virtual Private Cloud. The number will be different based upon your Cloud provider.
         * @example 123456789012
         */
        primary_cloud_account_id?: string;
        /**
         * Format: ipv4
         * @description The IP address assigned to the Telnyx side of the Virtual Cross Connect.<br /><br />If none is provided, one will be generated for you.<br /><br />This value should be null for GCE as Google will only inform you of your assigned IP once the connection has been accepted.
         * @example 169.254.0.1
         */
        primary_telnyx_ip?: string;
        /**
         * Format: ipv4
         * @description The IP address assigned for your side of the Virtual Cross Connect.<br /><br />If none is provided, one will be generated for you.<br /><br />This value should be null for GCE as Google will only inform you of your assigned IP once the connection has been accepted.
         * @example 169.254.0.2
         */
        primary_cloud_ip?: string;
        /**
         * @description The authentication key for BGP peer configuration.
         * @example yFV4wEPtPVPfDUGLWiyQzwga
         */
        primary_bgp_key?: string;
        /**
         * @description Indicates whether the secondary circuit is enabled. Setting this to `false` will disable the circuit.
         * @example true
         */
        readonly secondary_enabled?: boolean;
        /**
         * @description The identifier for your Virtual Private Cloud. The number will be different based upon your Cloud provider.<br /><br />This attribute is only necessary for GCE.
         * @example
         */
        secondary_cloud_account_id?: string;
        /**
         * Format: ipv4
         * @description The IP address assigned to the Telnyx side of the Virtual Cross Connect.<br /><br />If none is provided, one will be generated for you.<br /><br />This value should be null for GCE as Google will only inform you of your assigned IP once the connection has been accepted.
         * @example 169.254.0.3
         */
        secondary_telnyx_ip?: string;
        /**
         * Format: ipv4
         * @description The IP address assigned for your side of the Virtual Cross Connect.<br /><br />If none is provided, one will be generated for you.<br /><br />This value should be null for GCE as Google will only inform you of your assigned IP once the connection has been accepted.
         * @example 169.254.0.4
         */
        secondary_cloud_ip?: string;
        /**
         * @description The authentication key for BGP peer configuration.
         * @example ge1lONeK9RcA83uuWaw9DvZy
         */
        secondary_bgp_key?: string;
      };
    VirtualCrossConnectCombined: components['schemas']['VirtualCrossConnectCreate'] &
      components['schemas']['VirtualCrossConnectPatch'] &
      components['schemas']['RegionOut'];
    VirtualCrossConnectCoverage: {
      /**
       * @description Identifies the type of the resource.
       * @example virtual_cross_connects_coverage
       */
      readonly record_type?: string;
      location?: components['schemas']['Location'];
      /**
       * @description The Virtual Private Cloud with which you would like to establish a cross connect.
       * @example aws
       * @enum {string}
       */
      cloud_provider?: 'aws' | 'azure' | 'gce';
      /**
       * @description The region where your Virtual Private Cloud hosts are located. Should be identical to how the cloud provider names region, i.e. us-east-1 for AWS but Frankfurt for Azure
       * @example us-east-1
       */
      cloud_provider_region?: string;
      /**
       * @description The available throughput in Megabits per Second (Mbps) for your Virtual Cross Connect.
       * @example [
       *       50,
       *       100,
       *       200,
       *       500
       *     ]
       */
      available_bandwidth?: number[];
    };
    VirtualCrossConnectCreate: components['schemas']['VirtualCrossConnect'] &
      components['schemas']['RegionIn'] &
      Record<string, never>;
    VirtualCrossConnectPatch: {
      /**
       * @description Indicates whether the primary circuit is enabled. Setting this to `false` will disable the circuit.
       * @example true
       */
      primary_enabled?: boolean;
      /**
       * @description Whether the primary BGP route is being announced.
       * @example false
       */
      primary_routing_announcement?: boolean;
      /**
       * Format: ipv4
       * @description The IP address assigned for your side of the Virtual Cross Connect.<br /><br />If none is provided, one will be generated for you.<br /><br />This value can not be patched once the VXC has bene provisioned.
       * @example 169.254.0.2
       */
      primary_cloud_ip?: string;
      /**
       * @description Indicates whether the secondary circuit is enabled. Setting this to `false` will disable the circuit.
       * @example true
       */
      secondary_enabled?: boolean;
      /**
       * @description Whether the secondary BGP route is being announced.
       * @example false
       */
      secondary_routing_announcement?: boolean;
      /**
       * Format: ipv4
       * @description The IP address assigned for your side of the Virtual Cross Connect.<br /><br />If none is provided, one will be generated for you.<br /><br />This value can not be patched once the VXC has bene provisioned.
       * @example 169.254.0.4
       */
      secondary_cloud_ip?: string;
    };
    /** @example {
     *       "enabled": "true",
     *       "pin": "1234"
     *     } */
    VoicemailPrefResponse: {
      /**
       * @description Whether voicemail is enabled.
       * @example true
       */
      enabled?: boolean;
      /**
       * @description The pin used for the voicemail.
       * @example 1234
       */
      pin?: string;
    };
    VoicemailRequest: {
      /**
       * @description The pin used for voicemail
       * @example 1234
       */
      pin?: string;
      /**
       * @description Whether voicemail is enabled.
       * @example true
       */
      enabled?: boolean;
    };
    /**
     * Volume
     * @description Message Volume Enums
     * @enum {string}
     */
    Volume:
      | '10'
      | '100'
      | '1,000'
      | '10,000'
      | '100,000'
      | '250,000'
      | '500,000'
      | '750,000'
      | '1,000,000'
      | '5,000,000'
      | '10,000,000+';
    WdrReport: {
      /**
       * Format: uuid
       * @description Identifies the resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      readonly id?: string;
      /** @example detail_records_report */
      readonly record_type?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the resource was updated.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly updated_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating the start time.
       * @example 2018-02-02T22:25:27.521Z
       */
      start_time?: string;
      /**
       * @description ISO 8601 formatted date-time indicating the end time.
       * @example 2018-02-02T22:25:27.521Z
       */
      end_time?: string;
      /**
       * @description Indicates the status of the report, which is updated asynchronously.
       * @example pending
       * @enum {string}
       */
      status?: 'pending' | 'complete' | 'failed' | 'deleted';
      /**
       * @description The URL where the report content, when generated, will be published to.
       * @example http://example.com
       */
      report_url?: string;
    };
    /** @example {
     *       "start_time": "2018-02-02T22:25:27.521Z",
     *       "end_time": "2018-02-02T22:25:27.521Z"
     *     } */
    WdrReportRequest: {
      /**
       * @description ISO 8601 formatted date-time indicating the start time.
       * @example 2018-02-02T22:25:27.521Z
       */
      start_time?: string;
      /**
       * @description ISO 8601 formatted date-time indicating the end time.
       * @example 2018-02-02T22:25:27.521Z
       */
      end_time?: string;
    };
    /**
     * Webhook API Version
     * @description Determines which webhook format will be used, Telnyx API v1 or v2.
     * @default 1
     * @example 1
     * @enum {string}
     */
    WebhookApiVersion: '1' | '2';
    /**
     * Webhook Event Failover URL
     * Format: url
     * @description The failover URL where webhooks related to this connection will be sent if sending to the primary URL fails. Must include a scheme, such as 'https'.
     * @default
     * @example https://failover.example.com
     */
    WebhookEventFailoverUrl: string | null;
    /**
     * Webhook Event URL
     * Format: url
     * @description The URL where webhooks related to this connection will be sent. Must include a scheme, such as 'https'.
     * @example https://example.com
     */
    WebhookEventUrl: string;
    /** @description The webhook payload for the porting_order.deleted event */
    WebhookPortingOrderDeletedPayload: {
      /**
       * Format: uuid
       * @description Identifies the porting order that was deleted.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      id?: string;
      /**
       * @description Identifies the customer reference associated with the porting order.
       * @example my-ref-001
       */
      customer_reference?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the porting order was deleted.
       * @example 2021-03-19T10:07:15.527Z
       */
      deleted_at?: string;
    };
    /** @description The webhook payload for the porting_order.messaging_changed event */
    WebhookPortingOrderMessagingChangedPayload: {
      /**
       * Format: uuid
       * @description Identifies the porting order that was moved.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      id?: string;
      /**
       * @description Identifies the customer reference associated with the porting order.
       * @example my-ref-001
       */
      customer_reference?: string;
      /**
       * @description Identifies the support key associated with the porting order.
       * @example sr_b1a2c3
       */
      support_key?: string;
      /** @description The messaging portability status of the porting order. */
      messaging?: {
        /**
         * @description Indicates whether the porting order is messaging capable.
         * @example true
         */
        messaging_capable?: boolean;
        /**
         * @description Indicates whether Telnyx will port messaging capabilities from the losing carrier. If false, any messaging capabilities will stay with their current provider.
         * @example true
         */
        enable_messaging?: boolean;
        /**
         * @description Indicates the messaging port status of the porting order.
         * @example ported
         * @enum {string}
         */
        messaging_port_status?:
          | 'not_applicable'
          | 'pending'
          | 'activating'
          | 'exception'
          | 'canceled'
          | 'partial_port_complete'
          | 'ported';
        /**
         * @description Indicates whether the messaging port is completed.
         * @example true
         */
        messaging_port_completed?: boolean;
      };
    };
    /** @description The webhook payload for the porting_order.new_comment event */
    WebhookPortingOrderNewCommentPayload: {
      /**
       * Format: uuid
       * @description Identifies the porting order that the comment was added to.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      porting_order_id?: string;
      /**
       * @description Identifies the support key associated with the porting order.
       * @example sr_b1a2c3
       */
      support_key?: string;
      /** @description The comment that was added to the porting order. */
      comment?: {
        /**
         * Format: uuid
         * @description Identifies the comment.
         * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
         */
        id?: string;
        /**
         * @description The body of the comment.
         * @example This is a comment.
         */
        body?: string;
        /**
         * Format: uuid
         * @description Identifies the user that create the comment.
         * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
         */
        user_id?: string;
        /**
         * @description Identifies the type of the user that created the comment.
         * @example user
         * @enum {string}
         */
        user_type?: 'user' | 'admin' | 'system';
        /**
         * Format: date-time
         * @description ISO 8601 formatted date indicating when the comment was created.
         * @example 2021-03-19T10:07:15.527Z
         */
        inserted_at?: string;
      };
    };
    /** @description The webhook payload for the porting_order.split event */
    WebhookPortingOrderSplitPayload: {
      /** @description The porting order that was split. */
      from?: {
        /**
         * Format: uuid
         * @description Identifies the porting order that was split.
         * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
         */
        id?: string;
      };
      /** @description The new porting order that the phone numbers was moved to. */
      to?: {
        /**
         * Format: uuid
         * @description Identifies the porting order that was split.
         * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
         */
        id?: string;
      };
      /** @description The list of porting phone numbers that were moved to the new porting order. */
      porting_phone_numbers?: {
        /**
         * Format: uuid
         * @description Identifies the porting phone number that was moved.
         * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
         */
        id?: string;
      }[];
    };
    /** @description The webhook payload for the porting_order.status_changed event */
    WebhookPortingOrderStatusChangedPayload: {
      /**
       * Format: uuid
       * @description Identifies the porting order that was moved.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      id?: string;
      /**
       * @description Identifies the customer reference associated with the porting order.
       * @example my-ref-001
       */
      customer_reference?: string;
      status?: components['schemas']['PortingOrderStatus'];
      /**
       * @description Identifies the support key associated with the porting order.
       * @example sr_b1a2c3
       */
      support_key?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating when the porting order was moved.
       * @example 2021-03-19T10:07:15.527Z
       */
      updated_at?: string;
      /**
       * @description The URL to send the webhook to.
       * @example https://example.com/webhook
       */
      webhook_url?: string;
    };
    /** @description The webhook payload for the portout.foc_date_changed event */
    WebhookPortoutFocDateChangedPayload: {
      /**
       * Format: uuid
       * @description Identifies the port-out order that have the FOC date changed.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      id?: string;
      /**
       * @description Identifies the organization that port-out order belongs to.
       * @example 0e19c89e-f0ce-458a-a36c-3c60bc2014b1
       */
      user_id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 formatted date indicating the new FOC date.
       * @example 2021-03-19T10:07:15.527Z
       */
      foc_date?: string;
    };
    /** @description The webhook payload for the portout.new_comment event */
    WebhookPortoutNewCommentPayload: {
      /**
       * Format: uuid
       * @description Identifies the comment that was added to the port-out order.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      id?: string;
      /**
       * Format: uuid
       * @description Identifies the port-out order that the comment was added to.
       * @example d26109e5-0605-4671-a235-d3c649cc8406
       */
      portout_id?: string;
      /**
       * Format: uuid
       * @description Identifies the user that added the comment.
       * @example 1c45c968-c2e0-4559-b1dd-db073962fc61
       */
      user_id?: string;
      /**
       * @description The body of the comment.
       * @example This is a comment.
       */
      comment?: string;
    };
    /** @description The webhook payload for the portout.status_changed event */
    WebhookPortoutStatusChangedPayload: {
      /**
       * Format: uuid
       * @description Identifies the port out that was moved.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      id?: string;
      /**
       * @description The new status of the port out.
       * @example authorized
       * @enum {string}
       */
      status?:
        | 'pending'
        | 'authorized'
        | 'ported'
        | 'rejected'
        | 'rejected-pending'
        | 'canceled';
      /**
       * @description Phone numbers associated with this port-out order
       * @example [
       *       "+35312345678"
       *     ]
       */
      phone_numbers?: string[];
      /**
       * @description Carrier the number will be ported out to
       * @example Testing Carrier
       */
      carrier_name?: string;
      /**
       * @description The new carrier SPID.
       * @example 987H
       */
      spid?: string;
      /**
       * Format: uuid
       * @description Identifies the user that the port-out order belongs to.
       * @example 96dfa9e4-c753-4fd3-97cd-42d66f26cf0c
       */
      user_id?: string;
      /**
       * @description The name of the port-out's end user.
       * @example John Doe
       */
      subscriber_name?: string;
      /**
       * @description The reason why the order is being rejected by the user. If the order is authorized, this field can be left null
       * @example null
       */
      rejection_reason?: string;
      /**
       * @description The PIN that was attempted to be used to authorize the port out.
       * @example 1234
       */
      attempted_pin?: string;
    };
    /**
     * Webhook Timeout Secs
     * @description Specifies how many seconds to wait before timing out a webhook.
     * @default null
     * @example 25
     */
    WebhookTimeoutSecs: number | null;
    WhatsAppConversationDetailRecord: {
      /**
       * @description CLDR two-letter region-code of recipient
       * @example US
       */
      recipient_region_code?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * Format: date-time
       * @description UTC time when the message was created
       * @example 2021-08-06T03:32:01.125Z
       */
      created_at?: string;
      /**
       * @description Currency amount for WhatsApp cost
       * @example 0.003
       */
      whatsapp_fee?: string;
      /**
       * @description Whatsapp Conversation ID
       * @example f44ae083-c800-4433-baac-b439e5270aa4
       */
      conversation_id?: string;
      /**
       * @description Whatsapp Conversation Origin
       * @enum {string}
       */
      conversation_origin?:
        | 'business_initiated'
        | 'user_initiated'
        | 'referral_conversion';
      /**
       * @description Whatsapp Business Account ID
       * @example 421452453
       */
      whatsapp_business_account_id?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'WhatsAppConversationDetailRecord';
    };
    WhatsAppDetailRecord: {
      /**
       * @description WhatsApp Message Id
       * @example gBOGyfgaqtrewgpRTGqKuHKaTRhP
       */
      id?: string;
      /**
       * @description WhatsApp API Version
       * @example v0.1.0
       */
      version?: string;
      /**
       * @description WhatsApp Sender Id
       * @example 18336512500
       */
      sender_id?: string;
      /**
       * @description WhatsApp Recipient Id
       * @example 18336512500
       */
      recipient_id?: string;
      /**
       * @description WhatsApp Message Type. Consult WhatsApp API documentation to see all available types
       * @example session
       * @enum {string}
       */
      message_type?: 'session' | 'template';
      /**
       * @description WhatsApp Message Status. Consult WhatsApp API documentation to see all available status
       * @example delivered
       * @enum {string}
       */
      message_status?: 'sent' | 'delivered' | 'read' | 'failed' | 'deleted';
      /**
       * @description Logical direction of the message from the Telnyx customer's perspective. It's inbound when the Telnyx customer receives the message, or outbound otherwise
       * @example inbound
       * @enum {string}
       */
      direction?: 'inbound' | 'outbound';
      /**
       * @description CLDR two-letter region-code of recipient
       * @example US
       */
      recipient_region_code?: string;
      /**
       * @description Telnyx account currency used to describe monetary values, including billing cost
       * @example USD
       */
      currency?: string;
      /**
       * @description A string representing Whatsapp error code. Consult WhatsApp API documentation to see all available error codes
       * @example 490
       */
      whatsapp_error_code?: string;
      /**
       * Format: date-time
       * @description UTC time when the message was created
       * @example 2021-08-06T03:32:01.125Z
       */
      created_at?: string;
      /**
       * Format: date-time
       * @description UTC time when the webhook was received
       * @example 2021-08-06T03:32:01.125Z
       */
      webhook_received_at?: string;
      /**
       * @description UUID representation of the webhook unique identifier
       * @example 3ca7bd3d-7d82-4e07-9df4-009123068320
       */
      webhook_id?: string;
      /**
       * @description Currency amount for Telnyx billing cost
       * @example 0.003
       */
      telnyx_fee?: string;
      /**
       * @description Currency amount for WhatsApp cost
       * @example 0.003
       */
      whatsapp_fee?: string;
      /**
       * @description Whatsapp Conversation ID
       * @example f44ae083-c800-4433-baac-b439e5270aa4
       */
      conversation_id?: string;
      /**
       * @description Whatsapp Conversation Origin
       * @enum {string}
       */
      conversation_origin?:
        | 'business_initiated'
        | 'user_initiated'
        | 'referral_conversion';
      /**
       * @description Whatsapp Business Account ID
       * @example 421452453
       */
      whatsapp_business_account_id?: string;
      /**
       * @description discriminator enum property added by openapi-typescript
       * @enum {string}
       */
      record_type: 'WhatsAppDetailRecord';
    };
    WireguardInterface: components['schemas']['Record'] &
      components['schemas']['Interface'] & {
        /**
         * @description Identifies the type of the resource.
         * @example wireguard_interface
         */
        readonly record_type?: string;
        /**
         * @description The Telnyx WireGuard peers `Peer.endpoint` value.
         * @example 203.0.113.0:51871
         */
        readonly endpoint?: string;
        /**
         * @description The Telnyx WireGuard peers `Peer.PublicKey`.
         * @example qF4EqlZq+5JL2IKYY8ij49daYyfKVhevJrcDxdqC8GU=
         */
        readonly public_key?: string;
        /**
         * @description Enable SIP traffic forwarding over VPN interface.
         * @example false
         */
        enable_sip_trunking?: boolean;
      };
    WireguardInterfaceCreate: components['schemas']['WireguardInterface'] &
      components['schemas']['RegionIn'] &
      Record<string, never>;
    WireguardInterfaceRead: components['schemas']['WireguardInterface'] &
      components['schemas']['RegionOut'];
    WireguardPeer: components['schemas']['Record'] &
      components['schemas']['WireguardPeerPatch'] & {
        /**
         * @description Identifies the type of the resource.
         * @example wireguard_peer
         */
        readonly record_type?: string;
        /**
         * @description ISO 8601 formatted date-time indicating when peer sent traffic last time.
         * @example 2018-02-02T22:25:27.521Z
         */
        readonly last_seen?: string;
        /**
         * Format: uuid
         * @description The id of the wireguard interface associated with the peer.
         * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
         */
        wireguard_interface_id?: string;
        /**
         * @description Your WireGuard `Interface.PrivateKey`.<br /><br />This attribute is only ever utlised if, on POST, you do NOT provide your own `public_key`. In which case, a new Public and Private key pair will be generated for you. When your `private_key` is returned, you must save this immediately as we do not save it within Telnyx. If you lose your Private Key, it can not be recovered.
         * @example qF4EqlZq+5JL2IKYY8ij49daYyfKVhevJrcDxdqC8GU=
         */
        readonly private_key?: string;
      };
    WireguardPeerAllowedIP: components['schemas']['Record'] & {
      /**
       * @description Identifies the type of the resource.
       * @example wireguard_allowed_ip
       */
      readonly record_type?: string;
      /**
       * @description The IP address to add to the Wireguard Interface's AllowedIP list.
       * @example 198.51.100.1
       */
      ip_address?: string;
    };
    WireguardPeerAllowedIPCreate: components['schemas']['WireguardPeerAllowedIP'] &
      Record<string, never>;
    WireguardPeerCreate: components['schemas']['WireguardPeer'] &
      Record<string, never>;
    /** WireguardPeerPatch */
    WireguardPeerPatch: {
      /**
       * @description The WireGuard `PublicKey`.<br /><br />If you do not provide a Public Key, a new Public and Private key pair will be generated for you.
       * @example qF4EqlZq+5JL2IKYY8ij49daYyfKVhevJrcDxdqC8GU=
       */
      public_key?: string;
    };
    /**
     * WirelessConnectivityLog
     * @description This object represents a wireless connectivity session log that happened through a SIM card. It aids in finding out potential problems when the SIM is not able to attach properly.
     */
    WirelessConnectivityLog: {
      /** @example wireless_connectivity_log */
      readonly record_type?: string;
      /**
       * @description Uniquely identifies the session.
       * @example 137509451
       */
      readonly id?: number;
      /**
       * Format: uuid
       * @description The identification UUID of the related SIM card resource.
       * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
       */
      sim_card_id?: string;
      /**
       * @description The type of the session, 'registration' being the initial authentication session and 'data' the actual data transfer sessions.
       * @example registration
       * @enum {string}
       */
      readonly log_type?: 'registration' | 'data';
      /**
       * @description SIM cards are identified on their individual network operators by a unique International Mobile Subscriber Identity (IMSI). <br/>
       *     Mobile network operators connect mobile phone calls and communicate with their market SIM cards using their IMSIs. The IMSI is stored in the Subscriber  Identity Module (SIM) inside the device and is sent by the device to the appropriate network. It is used to acquire the details of the device in the Home  Location Register (HLR) or the Visitor Location Register (VLR).
       *
       * @example 081932214823362973
       */
      readonly imsi?: string;
      /**
       * @description The International Mobile Equipment Identity (or IMEI) is a number, usually unique, that identifies the device currently being used connect to the network.
       * @example 490154203237518
       */
      readonly imei?: string;
      /**
       * @description It's a three decimal digit that identifies a country.<br/><br/>
       *     This code is commonly seen joined with a Mobile Network Code (MNC) in a tuple that allows identifying a carrier known as PLMN (Public Land Mobile Network) code.
       * @example 310
       */
      readonly mobile_country_code?: string;
      /**
       * @description It's a two to three decimal digits that identify a network.<br/><br/>
       *      This code is commonly seen joined with a Mobile Country Code (MCC) in a tuple that allows identifying a carrier known as PLMN (Public Land Mobile Network) code.
       * @example 410
       */
      readonly mobile_network_code?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the session started.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly start_time?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the session ended.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly stop_time?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the record was created.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly created_at?: string;
      /**
       * @description ISO 8601 formatted date-time indicating when the last heartbeat to the device was successfully recorded.
       * @example 2018-02-02T22:25:27.521Z
       */
      readonly last_seen?: string;
      /**
       * @description The Access Point Name (APN) identifies the packet data network that a mobile data user wants to communicate with.
       * @example data00.telnyx
       */
      readonly apn?: string;
      /**
       * @description The SIM's address in the currently connected network. This IPv4 address is usually obtained dynamically, so it may vary according to the location or new connections.
       *
       * @example 192.168.0.0
       */
      readonly ipv4?: string;
      /**
       * @description The SIM's address in the currently connected network. This IPv6 address is usually obtained dynamically, so it may vary according to the location or new connections.
       *
       * @example 2001:cdba:0000:0000:0000:0000:3257:9652
       */
      readonly ipv6?: string;
      /**
       * @description The radio technology the SIM card used during the session.
       * @example LTE
       */
      readonly radio_access_technology?: string;
      /**
       * @description The state of the SIM card after when the session happened.
       * @example provisioned
       */
      readonly state?: string;
      /**
       * @description The cell ID to which the SIM connected.
       * @example 311210-6813
       */
      readonly cell_id?: string;
    };
    WirelessCost: {
      /**
       * @description Final cost. Cost is calculated as rate * unit
       * @example 0.1
       */
      amount?: string;
      /**
       * @description Currency of the rate and cost
       * @example USD
       * @enum {string}
       */
      currency?: 'AUD' | 'CAD' | 'EUR' | 'GBP' | 'USD';
    };
    WirelessRate: {
      /**
       * @description Rate from which cost is calculated
       * @example 0.1
       */
      amount?: string;
      /**
       * @description Currency of the rate and cost
       * @example USD
       * @enum {string}
       */
      currency?: 'AUD' | 'CAD' | 'EUR' | 'GBP' | 'USD';
    };
    /**
     * @description The active status of the authentication provider
     * @default true
     * @example true
     */
    active: boolean;
    /**
     * @description Indicates whether or not the address should be considered part of your list of addresses that appear for regular use.
     * @default true
     * @example false
     */
    address_book: boolean;
    /**
     * @description The locality of the address. For US addresses, this corresponds to the state of the address.
     * @example IL
     */
    administrative_area: string;
    /**
     * @description Webhook delivery attempt details.
     * @example [
     *       {
     *         "status": "delivered",
     *         "started_at": "2020-08-10T14:00:05.364Z",
     *         "finished_at": "2020-08-10T14:00:05.595Z",
     *         "http": {
     *           "request": {
     *             "url": "https://fallback.example.com/webhooks",
     *             "headers": [
     *               "Accept: *\/*"
     *             ]
     *           },
     *           "response": {
     *             "status": 200,
     *             "headers": [
     *               "Content-Type: text/html"
     *             ],
     *             "body": "All good."
     *           }
     *         }
     *       },
     *       {
     *         "status": "failed",
     *         "started_at": "2020-08-10T14:00:05.004Z",
     *         "finished_at": "2020-08-10T14:00:05.360Z",
     *         "http": {
     *           "request": {
     *             "url": "https://typo.example.com/webhooks",
     *             "headers": [
     *               "Accept: *\/*"
     *             ]
     *           },
     *           "response": {
     *             "status": 404,
     *             "headers": [
     *               "Content-Type: text/html",
     *               "Pragma: no-cache"
     *             ],
     *             "body": "Oops. Not found."
     *           }
     *         },
     *         "errors": [
     *           {
     *             "code": "75499",
     *             "title": "Webhook host returned HTTP 4XX",
     *             "detail": "The server returned another HTTP 4XX error"
     *           }
     *         ]
     *       },
     *       {
     *         "status": "failed",
     *         "started_at": "2020-08-10T14:00:00.000Z",
     *         "finished_at": "2020-08-10T14:00:05.000Z",
     *         "http": {
     *           "request": {
     *             "url": "https://slow.example.com/webhooks",
     *             "headers": [
     *               "Accept: *\/*"
     *             ]
     *           },
     *           "reponse": null
     *         },
     *         "errors": [
     *           {
     *             "code": "75001",
     *             "title": "Could not resolve name",
     *             "detail": "Unable to resolve the webhook URL domain name"
     *           }
     *         ]
     *       }
     *     ]
     */
    attempt: {
      /** @enum {string} */
      status?: 'delivered' | 'failed';
      /**
       * Format: date-time
       * @description ISO 8601 timestamp indicating when the attempt was initiated.
       */
      started_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 timestamp indicating when the attempt has finished.
       */
      finished_at?: string;
      http?: components['schemas']['http'];
      /** @description Webhook delivery error codes. */
      errors?: number[];
    };
    /**
     * @description The borough of the address. This field is not used for addresses in the US but is used for some international addresses.
     * @example Guadalajara
     */
    borough: string;
    /**
     * @description The business name associated with the address. An address must have either a first last name or a business name.
     * @example Toy-O'Kon
     */
    business_name: string;
    /**
     * Call Recording Error
     * @example {
     *       "record_type": "event",
     *       "event_type": "call.recording.error",
     *       "id": "0ccc7b54-4df3-4bca-a65a-3da1ecc777f0",
     *       "occurred_at": "2018-02-02T22:25:27.521992Z",
     *       "payload": {
     *         "connection_id": "7267xxxxxxxxxxxxxx",
     *         "call_leg_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "call_session_id": "428c31b6-7af4-4bcb-b7f5-5013ef9657c1",
     *         "client_state": "aGF2ZSBhIG5pY2UgZGF5ID1d",
     *         "result": "Internal server error"
     *       }
     *     }
     */
    callRecordingError: {
      /**
       * @description Identifies the type of the resource.
       * @example event
       * @enum {string}
       */
      record_type?: 'event';
      /**
       * @description The type of event being delivered.
       * @example call.recording.error
       * @enum {string}
       */
      event_type?: 'call.recording.error';
      /**
       * Format: uuid
       * @description Identifies the type of resource.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      id?: string;
      /**
       * Format: date-time
       * @description ISO 8601 datetime of when the event occurred.
       * @example 2018-02-02T22:25:27.521992Z
       */
      occurred_at?: string;
      payload?: {
        /**
         * @description Call ID used to issue commands via Call Control API.
         * @example v3:MdI91X4lWFEs7IgbBEOT9M4AigoY08M0WWZFISt1Yw2axZ_IiE4pqg
         */
        call_control_id?: string;
        /**
         * @description Call Control App ID (formerly Telnyx connection ID) used in the call.
         * @example 7267xxxxxxxxxxxxxx
         */
        connection_id?: string;
        /**
         * @description ID that is unique to the call and can be used to correlate webhook events.
         * @example 428c31b6-7af4-4bcb-b7f5-5013ef9657c1
         */
        call_leg_id?: string;
        /**
         * @description ID that is unique to the call session and can be used to correlate webhook events. Call session is a group of related call legs that logically belong to the same phone call, e.g. an inbound and outbound leg of a transferred call.
         * @example 428c31b6-abf3-3bc1-b7f4-5013ef9657c1
         */
        call_session_id?: string;
        /**
         * @description State received from a command.
         * @example aGF2ZSBhIG5pY2UgZGF5ID1d
         */
        client_state?: string;
        /**
         * @description Indication that there was a problem recording the call.
         * @example Internal server error
         * @enum {string}
         */
        reason?:
          | 'Failed to authorize with storage using custom credentials'
          | 'Invalid credentials json'
          | 'Unsupported backend'
          | 'Internal server error';
      };
    };
    /** Call Recording Error Event */
    callRecordingErrorEvent: {
      data?: components['schemas']['callRecordingError'];
    };
    /**
     * @description The two-character (ISO 3166-1 alpha-2) country code of the address.
     * @example US
     */
    country_code: string;
    /**
     * @description A customer reference string for customer look ups.
     * @example MY REF 001
     */
    customer_reference: string;
    error: {
      /** Format: int */
      code?: string;
      title?: string;
      detail?: string;
    };
    /**
     * @description Additional street address information about the address such as, but not limited to, unit number or apartment number.
     * @example #504
     */
    extended_address: string;
    /**
     * @description The first name associated with the address. An address must have either a first last name or a business name.
     * @example Alfred
     */
    first_name: string;
    /** @description HTTP request and response information. */
    http: {
      /** @description Request details. */
      request?: {
        /** @example https://example.com/webhooks */
        url?: string;
        headers?: components['schemas']['http_headers'];
      };
      /** @description Response details, optional. */
      response?: {
        /** @example 200 */
        status?: number;
        headers?: components['schemas']['http_headers'];
        /** @description Raw response body, limited to 10kB. */
        body?: string;
      } | null;
    };
    /**
     * @description List of headers, limited to 10kB.
     * @example [
     *       [
     *         "header_name",
     *         "header_value"
     *       ]
     *     ]
     */
    http_headers: string[][];
    /**
     * @description The last name associated with the address. An address must have either a first last name or a business name.
     * @example Foster
     */
    last_name: string;
    /**
     * @description The locality of the address. For US addresses, this corresponds to the city of the address.
     * @example Chicago
     */
    locality: string;
    /**
     * @description The name associated with the authentication provider.
     * @example Okta
     */
    name: string;
    /**
     * @description The neighborhood of the address. This field is not used for addresses in the US but is used for some international addresses.
     * @example Ciudad de los deportes
     */
    neighborhood: string;
    /**
     * Format: uuid
     * @description The id from the Organization the authentication provider belongs to.
     * @example 24b4a4bb-c4df-46ad-bbcb-23fc741c5ad7
     */
    organization_id: string;
    /**
     * @description The phone number associated with the address.
     * @example +12125559000
     */
    phone_number: string;
    /**
     * @description The postal code of the address.
     * @example 60654
     */
    postal_code: string;
    /** @description The settings associated with the authentication provider. */
    settings: {
      /**
       * @description The Entity ID for the identity provider (IdP).
       * @example https://myorg.myidp.com/saml/metadata
       */
      idp_entity_id: string;
      /**
       * @description The SSO target url for the identity provider (IdP).
       * @example https://myorg.myidp.com/trust/saml2/http-post/sso
       */
      idp_sso_target_url: string;
      /**
       * @description The certificate fingerprint for the identity provider (IdP)
       * @example 13:38:C7:BB:C9:FF:4A:70:38:3A:E3:D9:5C:CD:DB:2E:50:1E:80:A7
       */
      idp_cert_fingerprint: string;
      /**
       * @description The algorithm used to generate the identity provider's (IdP) certificate fingerprint
       * @default sha1
       * @example sha256
       * @enum {string}
       */
      idp_cert_fingerprint_algorithm: 'sha1' | 'sha256' | 'sha384' | 'sha512';
    };
    /**
     * @description The URL for the identity provider metadata file to populate the settings automatically. If the settings attribute is provided, that will be used instead.
     * @example https://myorg.myidp.com/saml/metadata
     */
    settings_url: string;
    /**
     * @description The short name associated with the authentication provider. This must be unique and URL-friendly, as it's going to be part of the login URL.
     * @example myorg
     */
    short_name: string;
    /**
     * @description The primary street address information about the address.
     * @example 311 W Superior Street
     */
    street_address: string;
    /**
     * @description Indicates whether or not the address should be validated for emergency use upon creation or not. This should be left with the default value of `true` unless you have used the `/addresses/actions/validate` endpoint to validate the address separately prior to creation. If an address is not validated for emergency use upon creation and it is not valid, it will not be able to be used for emergency services.
     * @default true
     * @example true
     */
    validate_address: boolean;
    /** @description Record of all attempts to deliver a webhook. */
    webhook_delivery: {
      /**
       * Format: uuid
       * @description Uniquely identifies the webhook_delivery record.
       * @example f5586561-8ff0-4291-a0ac-84fe544797bd
       */
      id?: string;
      /**
       * Format: uuid
       * @description Uniquely identifies the user that owns the webhook_delivery record.
       * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
       */
      user_id?: string;
      /**
       * @description Identifies the type of the resource.
       * @example webhook_delivery
       */
      record_type?: string;
      /**
       * @description Delivery status: 'delivered' when successfuly delivered or 'failed' if all attempts have failed.
       * @enum {string}
       */
      status?: 'delivered' | 'failed';
      /**
       * @description Original webhook JSON data. Payload fields vary according to event type.
       * @example {
       *       "record_type": "event",
       *       "id": "C9C0797E-901D-4349-A33C-C2C8F31A92C2",
       *       "event_type": "call_initiated",
       *       "occurred_at": "2020-08-10T13:02:01.000Z",
       *       "payload": {
       *         "useful": "information"
       *       }
       *     }
       */
      webhook?: {
        /**
         * @description Identifies the type of the resource.
         * @example event
         * @enum {string}
         */
        record_type?: 'event';
        /**
         * @description The type of event being delivered.
         * @example webhook.command
         */
        event_type?: string;
        /**
         * Format: uuid
         * @description Identifies the type of resource.
         * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
         */
        id?: string;
        /**
         * Format: date-time
         * @description ISO 8601 datetime of when the event occurred.
         * @example 2018-02-02T22:25:27.521992Z
         */
        occurred_at?: string;
        payload?: Record<string, never>;
      };
      /**
       * Format: date-time
       * @description ISO 8601 timestamp indicating when the first request attempt was initiated.
       * @example 2020-08-10T14:00:00.000Z
       */
      started_at?: string;
      /**
       * Format: date-time
       * @description ISO 8601 timestamp indicating when the last webhook response has been received.
       * @example 2020-08-10T14:00:05.595Z
       */
      finished_at?: string;
      /**
       * @description Detailed delivery attempts, ordered by most recent.
       * @example [
       *       {
       *         "status": "delivered",
       *         "started_at": "2020-08-10T14:00:05.364Z",
       *         "finished_at": "2020-08-10T14:00:05.595Z",
       *         "http": {
       *           "request": {
       *             "url": "https://fallback.example.com/webhooks",
       *             "headers": [
       *               "Accept: *\/*"
       *             ]
       *           },
       *           "response": {
       *             "status": 200,
       *             "headers": [
       *               "Content-Type: text/html"
       *             ],
       *             "body": "All good."
       *           }
       *         }
       *       },
       *       {
       *         "status": "failed",
       *         "started_at": "2020-08-10T14:00:05.004Z",
       *         "finished_at": "2020-08-10T14:00:05.360Z",
       *         "http": {
       *           "request": {
       *             "url": "https://typo.example.com/webhooks",
       *             "headers": [
       *               "Accept: *\/*"
       *             ]
       *           },
       *           "response": {
       *             "status": 404,
       *             "headers": [
       *               "Content-Type: text/html",
       *               "Pragma: no-cache"
       *             ],
       *             "body": "Oops. Not found."
       *           }
       *         },
       *         "errors": [
       *           {
       *             "code": "75499",
       *             "title": "Webhook host returned HTTP 4XX",
       *             "detail": "The server returned another HTTP 4XX error"
       *           }
       *         ]
       *       }
       *     ]
       */
      attempts?: components['schemas']['attempt'][];
    };
  };
  responses: {
    /** @description Success Action Response */
    ActionSuccessResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: {
            /** @example ok */
            result?: string;
          };
        };
      };
    };
    /** @description Successful response with list of details about active calls. */
    ActiveCallsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ActiveCall'][];
          meta?: components['schemas']['CursorPaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    AddressResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Address'];
        };
      };
    };
    /** @description Successful response */
    AuthenticationProviderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['AuthenticationProvider'];
        };
      };
    };
    /** @description Successful response */
    AutoRechargePrefResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['AutoRechargePref'];
        };
      };
    };
    /** @description Bad request, the request was unacceptable, often due to missing a required parameter. */
    BadRequestResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Bucket Usage */
    BucketAPIUsageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BucketAPIUsageResponse'][];
        };
      };
    };
    /** @description Bucket Storage Usage */
    BucketUsageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BucketUsage'][];
          meta?: components['schemas']['PaginationMetaSimple'];
        };
      };
    };
    /** @description Successful response for Bulk credential requests */
    BulkCredentialResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: {
            /**
             * @description Amount of credentials affected
             * @example 0
             */
            credentials?: number;
          };
        };
      };
    };
    /** @description Successful response for Bulk Delete Room recordings requests */
    BulkDeleteRoomRecordingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: {
            /**
             * @description Amount of room recordings affected
             * @example 5
             */
            room_recordings?: number;
          };
        };
      };
    };
    /** @description Successful response with details about messaging bulk update phone numbers. */
    BulkMessagingSettingsUpdatePhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BulkMessagingSettingsUpdatePhoneNumbers'];
        };
      };
    };
    /** @description Successful Response */
    BulkSIMCardActionCollectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BulkSIMCardActionDetailed'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    BulkSIMCardActionDetailedResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BulkSIMCardActionDetailed'];
        };
      };
    };
    /** @description Successful Response */
    BulkSIMCardActionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BulkSIMCardAction'];
        };
      };
    };
    BulkSIMCardNetworkPreferenceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Multi requested SIM cards network preferences. */
          data?: components['schemas']['SIMCardNetworkPreferenceWithOTAUpdates'][];
          errors?: components['schemas']['Error'][];
        };
      };
    };
    /** @description Successful response */
    BulkUploadDocServiceDocumentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocServiceDocument'][];
        };
      };
    };
    /** @description Successful response with details about a call control application. */
    CallControlApplicationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CallControlApplication'];
        };
      };
    };
    /** @description Successful response upon making a call control command. */
    CallControlCommandResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CallControlCommandResult'];
        };
      };
    };
    /** @description Successful response upon accepting cancel fax command */
    CancelFaxResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @example ok */
          result?: string;
        };
      };
    };
    /** @description Successful response */
    CancelPortingOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrder'];
          meta?: {
            /** @description Link to list all phone numbers */
            phone_numbers_url?: string;
          };
        };
      };
    };
    /** @description A Comment Response */
    CommentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Comment'] & Record<string, never>;
        };
      };
    };
    /** @description Successful response upon making a conference command. */
    ConferenceCommandResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ConferenceCommandResult'];
        };
      };
    };
    /** @description Successful response with details about a conference. */
    ConferenceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Conference'];
        };
      };
    };
    /** @description Successful response */
    ConfirmPortingOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrder'];
          meta?: {
            /** @description Link to list all phone numbers */
            phone_numbers_url?: string;
          };
        };
      };
    };
    /** @description Successful response with details about a connection. */
    ConnectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Connection'];
        };
      };
    };
    /** @description Response for country coverage */
    CountryCoverageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CountryCoverage'][];
        };
      };
    };
    /** @description Expected billing group response to a valid request */
    CreateBillingGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BillingGroup'];
        };
      };
    };
    /** @description Successful Response */
    CreateCustomerServiceRecord: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CustomerServiceRecord'];
        };
      };
    };
    /** @description Expected ledger billing group report response to a valid request */
    CreateLedgerBillingGroupReportResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['LedgerBillingGroupReport'];
        };
      };
    };
    /** @description Portout Supporting Documents */
    CreatePortOutSupportingDocumentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortOutSupportingDocument'][];
        };
      };
    };
    /** @description Successful response */
    CreatePortingAdditionalDocuments: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingAdditionalDocument'][];
        };
      };
    };
    /** @description Successful response */
    CreatePortingLOAConfiguration: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingLOAConfiguration'];
        };
      };
    };
    /** @description Successful response */
    CreatePortingPhoneNumberConfigurations: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumberConfiguration'][];
        };
      };
    };
    /** @description Successful response */
    CreatePortingReport: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingReport'];
        };
      };
    };
    /** @description Successful response */
    CreatePortoutReport: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutReport'];
        };
      };
    };
    /** @description Successful Response */
    CreatePrivateWirelessGatewayResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PrivateWirelessGateway'];
        };
      };
    };
    /** @description Create room client token response. */
    CreateRoomClientTokenResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @example {
           *       "token": "eyJhbGciOiJFZDI1NTE5IiwidHlwIjoiSldUIn0.eyJhdWQiOiJ0ZWxueXhfYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjE5MDk0Mjk1LCJncmFudHMiOlt7ImFjdGlvbnMiOlsiam9pbiJdLCJyZXNvdXJjZXMiOlsidGVsbnl4OnZpZGVvOnJvb21zOjllMmEwY2JlLWNlNjYtNDExZS1hMWFjLTQ2OGYwYjEwM2M5YSJdLCJzdWJqZWN0cyI6WyJ0ZWxueXg6dXNlcnM6NzgyYjJjYmUtODQ2Ni00ZTNmLWE0ZDMtOTc4MWViNTc3ZTUwIl19XSwiZ3JhbnRzX3ZlcnNpb24iOiIxLjAuMCIsImlhdCI6MTYxOTA5MzY5NSwiaXNzIjoidGVsbnl4X2FjY2Vzc190b2tlbiIsImp0aSI6IjllNjIyOTA2LTc1ZTctNDBiNi1iOTAwLTc1NGIxZjNlZDMyZiIsIm5iZiI6MTYxOTA5MzY5NCwic3ViIjoibnVsbCIsInR5cCI6ImFjY2VzcyJ9.1JGK9PyHkTtoP_iMu-8TzXH_fhmnsDtZZOAJLDzLW6DDtAb80wZ93l1VH5yNx5tFqwIFG0t48dRiBKWlW-nzDA",
           *       "token_expires_at": "2021-04-22T12:24:55Z",
           *       "refresh_token": "eyJhbGciOiJFZDI1NTE5IiwidHlwIjoiSldUIn0.eyJhdWQiOiJ0ZWxueXhfYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjE5MDkzNzA1LCJncmFudHMiOlt7ImFjdGlvbnMiOlsiam9pbiJdLCJyZXNvdXJjZXMiOlsidGVsbnl4OnZpZGVvOnJvb21zOjllMmEwY2JlLWNlNjYtNDExZS1hMWFjLTQ2OGYwYjEwM2M5YSJdLCJzdWJqZWN0cyI6WyJ0ZWxueXg6dXNlcnM6NzgyYjJjYmUtODQ2Ni00ZTNmLWE0ZDMtOTc4MWViNTc3ZTUwIl19XSwiZ3JhbnRzX3ZlcnNpb24iOiIxLjAuMCIsImlhdCI6MTYxOTA5MzY5NSwiaXNzIjoidGVsbnl4X2FjY2Vzc190b2tlbiIsImp0aSI6ImQ3OWJlMzhjLWFkNTQtNGQ5ZC1hODc4LWExNjVjNTk0MGQwNyIsIm5iZiI6MTYxOTA5MzY5NCwic3ViIjoibnVsbCIsInR5cCI6InJlZnJlc2gifQ.FHsp7KlVXn1E5tTUiKZzmQ4of39gi57AakeQeqI0oAa8hzjFMVb0RGj-mxWTvHVen4GpgsUW_epqqaxK16viCA",
           *       "refresh_token_expires_at": "2021-04-22T12:15:05Z"
           *     } */
          data?: {
            /**
             * Format: jwt
             * @example eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJ0ZWxueXhfdGVsZXBob255IiwiZXhwIjoxNTkwMDEwMTQzLCJpYXQiOjE1ODc1OTA5NDMsImlzcyI6InRlbG55eF90ZWxlcGhvbnkiLCJqdGkiOiJiOGM3NDgzNy1kODllLTRhNjUtOWNmMi0zNGM3YTZmYTYwYzgiLCJuYmYiOjE1ODc1OTA5NDIsInN1YiI6IjVjN2FjN2QwLWRiNjUtNGYxMS05OGUxLWVlYzBkMWQ1YzZhZSIsInRlbF90b2tlbiI6InJqX1pra1pVT1pNeFpPZk9tTHBFVUIzc2lVN3U2UmpaRmVNOXMtZ2JfeENSNTZXRktGQUppTXlGMlQ2Q0JSbWxoX1N5MGlfbGZ5VDlBSThzRWlmOE1USUlzenl6U2xfYURuRzQ4YU81MHlhSEd1UlNZYlViU1ltOVdJaVEwZz09IiwidHlwIjoiYWNjZXNzIn0.gNEwzTow5MLLPLQENytca7pUN79PmPj6FyqZWW06ZeEmesxYpwKh0xRtA0TzLh6CDYIRHrI8seofOO0YFGDhpQ
             */
            token?: string;
            /**
             * Format: datetime
             * @description ISO 8601 timestamp when the token expires.
             * @example 2021-03-26T17:51:59Z
             */
            token_expires_at?: string;
            /**
             * Format: jwt
             * @example eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJ0ZWxueXhfdGVsZXBob255IiwiZXhwIjoxNTkwMDEwMTQzLCJpYXQiOjE1ODc1OTA5NDMsImlzcyI6InRlbG55eF90ZWxlcGhvbnkiLCJqdGkiOiJiOGM3NDgzNy1kODllLTRhNjUtOWNmMi0zNGM3YTZmYTYwYzgiLCJuYmYiOjE1ODc1OTA5NDIsInN1YiI6IjVjN2FjN2QwLWRiNjUtNGYxMS05OGUxLWVlYzBkMWQ1YzZhZSIsInRlbF90b2tlbiI6InJqX1pra1pVT1pNeFpPZk9tTHBFVUIzc2lVN3U2UmpaRmVNOXMtZ2JfeENSNTZXRktGQUppTXlGMlQ2Q0JSbWxoX1N5MGlfbGZ5VDlBSThzRWlmOE1USUlzenl6U2xfYURuRzQ4YU81MHlhSEd1UlNZYlViU1ltOVdJaVEwZz09IiwidHlwIjoiYWNjZXNzIn0.gNEwzTow5MLLPLQENytca7pUN79PmPj6FyqZWW06ZeEmesxYpwKh0xRtA0TzLh6CDYIRHrI8seofOO0YFGDhpQ
             */
            refresh_token?: string;
            /**
             * Format: datetime
             * @description ISO 8601 timestamp when the refresh token expires.
             * @example 2021-03-26T17:51:59Z
             */
            refresh_token_expires_at?: string;
          };
        };
      };
    };
    /** @description Create room composition response. */
    CreateRoomCompositionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomComposition'];
        };
      };
    };
    /** @description Create room response. */
    CreateRoomResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Room'];
        };
      };
    };
    /** @description Successful Response */
    CreateSimCardDataUsageNotificationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimCardDataUsageNotification'];
        };
      };
    };
    /** @description Successful Response */
    CreateSimCardGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardGroup'];
        };
      };
    };
    /** @description Successful Response */
    CreateSimCardOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardOrder'];
        };
      };
    };
    /** @description Successful response upon creating a TeXML secret. */
    CreateTeXMLSecretResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CreateTeXMLSecretResult'];
        };
      };
    };
    /** @description Successful response */
    CreateWdrReportResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WdrReport'];
        };
      };
    };
    /** @description Successful response with details about a credential connection. */
    CredentialConnectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CredentialConnection'];
        };
      };
    };
    /** @description A response with credentials resource. */
    CredentialsResponseBody: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['CredentialsResponse'];
      };
    };
    /** @description Successful response with details about a CSV download. */
    CsvDownloadResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CsvDownload'][];
        };
      };
    };
    /** @description A successful network preferences deletion response. <br/><br/>
     *     The delete won't be done right away - this is an asynchronous operation. The request will return the resource with an in-progress OTA update resource (in the ota_updates node) representing the delete operation. Similarly to the PUT API, the resource will only be deleted when the OTA updated is successfully completed. */
    DELETESIMCardNetworkPreferenceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardNetworkPreferenceWithOTAUpdates'];
        };
      };
    };
    /** @description Successful response */
    DefaultGatewayResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DefaultGateway'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Expected billing group response to a valid request */
    DeleteBillingGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BillingGroup'];
        };
      };
    };
    /** @description Successful response with details about a phone number. */
    DeletePhoneNumberResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberDeletedDetailed'];
        };
      };
    };
    /** @description Successful Response */
    DeletePrivateWirelessGatewayResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PrivateWirelessGateway'];
        };
      };
    };
    /** @description Successful Response */
    DeleteSimCardDataUsageNotificationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimCardDataUsageNotification'];
        };
      };
    };
    /** @description Successful Response */
    DeleteSimCardGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardGroup'];
        };
      };
    };
    /** @description Successful response */
    DeleteSimCardResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCard'];
        };
      };
    };
    /** @description Successful response */
    DeleteWdrReportResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WdrReport'];
        };
      };
    };
    /** @description New participant resource. */
    DialParticipantResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['NewParticipantResource'];
      };
    };
    /** @description Return details of the Dialogflow connection associated with the given CallControl connection. */
    DialogflowConnectionResponseBody: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['DialogflowConnectionResponse'];
      };
    };
    /** @description Successful response */
    DocReqsListRequirementTypesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocReqsRequirementTypeList'];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    DocReqsRequirementResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocReqsRequirement'];
        };
      };
    };
    /** @description Successful response */
    DocReqsRequirementTypeResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocReqsRequirementType'];
        };
      };
    };
    /** @description Successful response */
    DocServiceDocumentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocServiceDocument'];
        };
      };
    };
    /** @description Successful response */
    DownloadDocServiceDocumentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        '*': string;
      };
    };
    /** @description Successful response */
    DownloadLOATemplate: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/pdf': string;
      };
    };
    /** @description Dynamic Emergency Address Response */
    DynamicEmergencyAddressResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DynamicEmergencyAddress'];
        };
      };
    };
    /** @description Dynamic Emergency Endpoint Response */
    DynamicEmergencyEndpointResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DynamicEmergencyEndpoint'];
        };
      };
    };
    /** @description Successful response */
    ExternalConnectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ExternalConnection'];
        };
      };
    };
    /** @description Successful response */
    FaxApplicationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['FaxApplication'];
        };
      };
    };
    /** @description Forbidden */
    Forbidden: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description You do not have permission to perform the requested action on the specified resource or resources. */
    ForbiddenErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          errors?: components['schemas']['ForbiddenError'][];
        };
      };
    };
    /** @description Unauthorized response. Happens when the current user is not authorized to access the endpoint. */
    ForbiddenResponse: {
      headers: {
        [name: string]: unknown;
      };
      content?: never;
    };
    /** @description Successful response with details about an FQDN connection. */
    FqdnConnectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['FqdnConnection'];
        };
      };
    };
    /** @description Successful response with details about an FQDN connection. */
    FqdnResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Fqdn'];
        };
      };
    };
    /** @description Unexpected error */
    GenericErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Errors'];
      };
    };
    /** @description Successful response */
    GetAllAddressResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Address'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GetAllAuthenticationProviderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['AuthenticationProvider'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GetAllCivicAddressesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CivicAddress'][];
        };
      };
    };
    /** @description Successful response */
    GetAllExternalConnectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ExternalConnection'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GetAllFaxApplicationsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['FaxApplication'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    GetAllPrivateWirelessGatewaysResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PrivateWirelessGateway'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    GetAllSimCardGroupsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SearchedSIMCardGroup'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    GetAllSimCardOrdersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardOrder'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with multiple credentials */
    GetAllTelephonyCredentialResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['TelephonyCredential'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GetAllTexmlApplicationsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['TexmlApplication'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Call resource. */
    GetCallResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['CallResource'];
      };
    };
    /** @description Multiple call resources. */
    GetCallsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['CallResourceIndex'];
      };
    };
    /** @description Successful response */
    GetCivicAddressResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CivicAddress'];
        };
      };
    };
    /** @description Multiple conference recording resources. */
    GetConferenceRecordingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ConferenceRecordingResourceIndex'];
      };
    };
    /** @description Conference resource. */
    GetConferenceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ConferenceResource'];
      };
    };
    /** @description Multiple conference resources. */
    GetConferencesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ConferenceResourceIndex'];
      };
    };
    /** @description Successful response */
    GetExternalConnectionPhoneNumberResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ExternalConnectionPhoneNumber'];
        };
      };
    };
    /** @description Get fax response */
    GetFaxResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Fax'];
        };
      };
    };
    /** @description Requested channel zone */
    GetGcbChannelZoneRequestResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['GcbChannelZone'];
      };
    };
    /** @description A list of channel zones */
    GetGcbChannelZonesRequestResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GcbChannelZone'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description A list of phone numbers */
    GetGcbPhoneNumbersRequestResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GcbPhoneNumber'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GetLogMessageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          log_messages?: components['schemas']['LogMessage'][];
        };
      };
    };
    /** @description Participant resource. */
    GetParticipantResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ParticipantResource'];
      };
    };
    /** @description Multiple participant resources. */
    GetParticipantsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ParticipantResourceIndex'];
      };
    };
    /** @description Successful Response */
    GetPrivateWirelessGatewayResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PrivateWirelessGateway'];
        };
      };
    };
    /** @description Successful response */
    GetReleaseResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Release'];
        };
      };
    };
    /** @description Get room composition response. */
    GetRoomCompositionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomComposition'];
        };
      };
    };
    /** @description Get room participant response. */
    GetRoomParticipantResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomParticipant'];
        };
      };
    };
    /** @description Get room recording response. */
    GetRoomRecordingResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomRecording'];
        };
      };
    };
    /** @description Get room response. */
    GetRoomResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Room'];
        };
      };
    };
    /** @description Get room session response. */
    GetRoomSessionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomSession'];
        };
      };
    };
    /** @description Successful Response */
    GetSimCardDataUsageNotificationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimCardDataUsageNotification'];
        };
      };
    };
    /** @description Successful Response */
    GetSimCardGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardGroup'];
        };
      };
    };
    /** @description Successful Response */
    GetSimCardOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardOrder'];
        };
      };
    };
    /** @description Successful response */
    GetSimCardResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCard'];
        };
      };
    };
    /** @description Successful response */
    GetUploadResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Upload'];
        };
      };
    };
    /** @description Successful response */
    GetUploadsStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: {
            /** @description The count of phone numbers that are pending assignment to the external connection. */
            pending_numbers_count?: number;
            /** @description The count of number uploads that have not yet been uploaded to Microsoft. */
            pending_orders_count?: number;
          };
        };
      };
    };
    /** @description Successful response */
    GetWdrReportResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WdrReport'];
        };
      };
    };
    /** @description Successful response */
    GetWdrReportsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WdrReport'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpAllowedPortListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIPAllowedPort'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpAssignmentListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpAssignment'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GlobalIpAssignmentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpAssignment'];
        };
      };
    };
    /** @description Successful response */
    GlobalIpAssignmentUsageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpAssignmentUsageMetric'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpHealthCheckListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIPHealthCheck'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GlobalIpHealthCheckResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIPHealthCheck'];
        };
      };
    };
    /** @description Successful response */
    GlobalIpHealthCheckTypesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpHealthCheckType'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpHealthResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpAssignmentHealthMetric'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpLatencyResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpLatencyMetric'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIP'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    GlobalIpProtocolListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIPProtocol'][];
        };
      };
    };
    /** @description Successful response */
    GlobalIpResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIP'];
        };
      };
    };
    /** @description Successful response */
    GlobalIpUsageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GlobalIpUsageMetric'][];
        };
      };
    };
    /** @description Successful response upon initiating a TeXML call. */
    InitiateCallResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['InitiateCallResult'];
      };
    };
    /** @description Successful response with a list of inventory coverage levels */
    InventoryCoverageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['InventoryCoverage'][];
          meta?: components['schemas']['InventoryCoverageMetadata'];
        };
      };
    };
    /** @description Successful response with details about an IP connection. */
    IpConnectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['IpConnection'];
        };
      };
    };
    /** @description Successful response with details about an IP. */
    IpResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Ip'];
        };
      };
    };
    /** @description Successful response */
    ListAllowedFocWindows: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrdersAllowedFocWindow'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List of audit log entries */
    ListAuditLogsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['AuditLogEntry'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of available phone numbers blocks. */
    ListAvailablePhoneNumbersBlockResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['AvailablePhoneNumberBlock'][];
          meta?: components['schemas']['AvailablePhoneNumbersMetadata'];
        };
      };
    };
    /** @description Successful response with a list of available phone numbers. */
    ListAvailablePhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['AvailablePhoneNumber'][];
          meta?: components['schemas']['AvailablePhoneNumbersMetadata'];
        };
      };
    };
    /** @description A paginated array of billing groups */
    ListBillingGroupsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BillingGroup'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of call control applications. */
    ListCallControlApplicationsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CallControlApplication'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of call events. */
    ListCallEventsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CallEvent'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of conferences. */
    ListConferencesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Conference'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of connections. */
    ListConnectionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Connection'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of credential connections. */
    ListCredentialConnectionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CredentialConnection'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of CSV downloads. */
    ListCsvDownloadsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CsvDownload'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    ListCustomerServiceRecordPhoneNumberCoverage: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CustomerServiceRecordPhoneNumberCoverage'][];
        };
      };
    };
    /** @description Successful Response */
    ListCustomerServiceRecords: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CustomerServiceRecord'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListDocServiceDocumentLinksResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocServiceDocumentLink'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListDocServiceDocumentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocServiceDocument'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListDraftPortingOrdersWithoutPagination: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrder'][];
        };
      };
    };
    /** @description Successful response */
    ListExternalConnectionPhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ExternalConnectionPhoneNumber'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List faxes response */
    ListFaxesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Fax'][];
          /** @example {
           *       "page_number": 2,
           *       "page_size": 1,
           *       "total_pages": 3,
           *       "total_results": 3
           *     } */
          meta?: Record<string, never>;
        };
      };
    };
    /** @description Successful response with a list of FQDN connections. */
    ListFqdnConnectionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['FqdnConnection'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of FQDN connections. */
    ListFqdnsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Fqdn'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of IP connections. */
    ListIpConnectionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['IpConnection'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of IPs. */
    ListIpsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Ip'][];
        };
      };
    };
    /** @description Successful response */
    ListLogMessagesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          log_messages?: components['schemas']['LogMessage'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with information about allocatable global outbound channels. */
    ListManagedAccountsAllocatableGlobalOutboundChannelsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ManagedAccountsGlobalOutboundChannels'];
        };
      };
    };
    /** @description Successful response with a list of managed accounts. */
    ListManagedAccountsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ManagedAccountMultiListing'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description A response with a list of media resources */
    ListMediaResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MediaResource'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of messaging hosted number orders. */
    ListMessagingHostedNumberOrdersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingHostedNumberOrder'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of messaging profile metrics. */
    ListMessagingProfileMetrics: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingProfileHighLevelMetrics'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of messaging profile phone numbers. */
    ListMessagingProfilePhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberWithMessagingSettings'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of messaging profile short codes. */
    ListMessagingProfileShortCodesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ShortCode'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of messaging profiles. */
    ListMessagingProfilesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingProfile'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with details about a messaging URL domain. */
    ListMessagingUrlDomains: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingUrlDomain'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List Migrations Response */
    ListMigrationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MigrationParams'][];
          meta?: components['schemas']['PaginationMetaSimple'];
        };
      };
    };
    /** @description List Migrations Source Coverage Response */
    ListMigrationSourceCoverageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MigrationSourceCoverageParams'][];
          meta?: components['schemas']['PaginationMetaSimple'];
        };
      };
    };
    /** @description List Migration Sources Response */
    ListMigrationSourceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MigrationSourceParams'][];
          meta?: components['schemas']['PaginationMetaSimple'];
        };
      };
    };
    /** @description Successful response with a list of number block orders. */
    ListNumberBlockOrdersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberBlockOrder'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of number order documents. */
    ListNumberOrderDocumentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberOrderDocument'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of number order phone numbers. */
    ListNumberOrderPhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberOrderPhoneNumber'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of number orders. */
    ListNumberOrdersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberOrder'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of number reservations. */
    ListNumberReservationsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberReservation'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListOutboundVoiceProfilesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['OutboundVoiceProfile'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of conference participants. */
    ListParticipantsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Participant'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of phone number blocks background jobs. */
    ListPhoneNumberBlocksJobsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberBlocksJob'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of phone numbers background jobs. */
    ListPhoneNumbersJobsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumbersJob'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of phone numbers. */
    ListPhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberDetailed'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of phone numbers with messaging settings. */
    ListPhoneNumbersWithMessagingSettingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberWithMessagingSettings'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of phone numbers with voice settings. */
    ListPhoneNumbersWithVoiceSettingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberWithVoiceSettings'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingAdditionalDocuments: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingAdditionalDocument'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingEventsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingEvent'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingLOAConfigurations: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingLOAConfiguration'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingOrder: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrder'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingOrderRequirements: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrderRequirementDetail'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingOrdersActivationJobs: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrdersActivationJob'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingOrdersComments: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrdersComment'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingOrdersExceptionTypes: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrdersExceptionType'][];
        };
      };
    };
    /** @description Successful response */
    ListPortingPhoneNumberBlocks: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumberBlock'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingPhoneNumberConfigurations: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumberConfiguration'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingPhoneNumberExtensions: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumberExtension'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingPhoneNumbers: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumber'][];
          meta?: components['schemas']['PaginationMeta'];
        };
        'text/csv': string;
      };
    };
    /** @description Successful response */
    ListPortingReports: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingReport'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortingVerificationCodes: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingVerificationCode'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Portout Comments */
    ListPortoutComments: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutComment'][];
          meta?: components['schemas']['Metadata'];
        };
      };
    };
    /** @description Successful response */
    ListPortoutEventsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutEvent'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListPortoutReports: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutReport'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Portout Response */
    ListPortoutResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutDetails'][];
          meta?: components['schemas']['Metadata'];
        };
      };
    };
    /** @description Mobile mobile push credentials */
    ListPushCredentialsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content?: never;
    };
    /** @description Successful response with a list of calls in a queue. */
    ListQueueCallsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['QueueCall'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description A response listing recording transcriptions */
    ListRecordingTranscriptionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RecordingTranscription'][];
          meta?: components['schemas']['CursorPaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListReleasesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Release'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListRequirementsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DocReqsRequirementList'];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List room compositions response. */
    ListRoomCompositionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomComposition'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List room participants response. */
    ListRoomParticipantsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomParticipant'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List room recordings response. */
    ListRoomRecordingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomRecording'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List room sessions response. */
    ListRoomSessionsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RoomSession'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description List rooms response. */
    ListRoomsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Room'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of short codes. */
    ListShortCodesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ShortCode'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with a list of sub number orders. */
    ListSubNumberOrdersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SubNumberOrder'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response with multiple tags */
    ListTagsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: {
            /** @example a_tag */
            tag?: string;
            /** @example 1 */
            amount?: number;
          }[];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    ListUploadsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Upload'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description A paginated array of webhook_delivery attempts */
    ListWebhookDeliveriesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['webhook_delivery'][];
          meta?: components['schemas']['PaginationMetaSimple'];
        };
      };
    };
    /** @description Successful response with information about a single managed account. */
    ManagedAccountResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ManagedAccount'];
        };
      };
    };
    /** @description A response describing a media resource */
    MediaDownloadResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        '*/*': string;
      };
    };
    /** @description A response describing a media resource */
    MediaResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MediaResource'];
        };
      };
    };
    /** @description Successful response with details about a message. */
    MessageResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['OutboundMessagePayload'];
        };
      };
    };
    /** @description Successful response with details about a messaging hosted number order. */
    MessagingHostedNumberOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingHostedNumberOrder'];
        };
      };
    };
    /** @description Successful response with details about a messaging hosted number. */
    MessagingHostedNumberResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['HostedNumber'];
        };
      };
    };
    /** @description Successful response with details about a messaging profile. */
    MessagingProfileResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingProfile'];
        };
      };
    };
    /** @description Create Migration Response */
    MigrationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MigrationParams'];
        };
      };
    };
    /** @description Create Migration Source Response */
    MigrationSourceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MigrationSourceParams'];
        };
      };
    };
    /** @description Successful response */
    NetworkCoverageListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NetworkCoverage'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    NetworkInterfaceListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NetworkInterface'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    NetworkListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Network'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    NetworkResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Network'];
        };
      };
    };
    /** @description Resource Not Found */
    NotFoundErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Errors'];
      };
    };
    /** @description The requested resource doesn't exist. */
    NotFoundResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Successful response with details about a number block order. */
    NumberBlockOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberBlockOrder'];
        };
      };
    };
    /** @description Successful response */
    NumberLookupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberLookupRecord'];
        };
      };
    };
    /** @description Successful response with details about a number order document. */
    NumberOrderDocumentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberOrderDocument'];
        };
      };
    };
    /** @description Successful response with details about a number order phone number. */
    NumberOrderPhoneNumberResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberOrderPhoneNumber'];
        };
      };
    };
    /** @description Successful response with details about a number order. */
    NumberOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberOrderWithPhoneNumbers'];
        };
      };
    };
    /** @description Successful response with details about a number reservation. */
    NumberReservationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['NumberReservation'];
        };
      };
    };
    /** @description Successful response */
    OTAUpdateResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CompleteOTAUpdate'];
        };
      };
    };
    /** @description Successful response */
    OutboundVoiceProfileResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['OutboundVoiceProfile'];
        };
      };
    };
    /** @description A successful network preferences definition response. <br/><br/>
     *     The sent mobile_network_operators_preferences parameter won't be applied to the main resource right away - this is an asynchronous operation. While interacting with this API, you will face the following scenarios:
     *
     *       * The first request for this API will return an empty mobile_network_operators_preferences with an in-progress OTA update resource in the ota_updates node containing the exact sent parameters to indicate the operation progress. The value will be applied to the principal object when the OTA update finishes its processing, thus indicating the SIM card network preference current state.
     *       * The subsequent requests will contain the current state, that is what's applied to the SIM card settings, and return the related OTA update in the ota_updates node.
     *
     *     The returned OTA updated (present in the ota_updates node) will, by default, be the resource related to the operation, not all of them. */
    PUTSIMCardNetworkPreferenceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardNetworkPreferenceWithOTAUpdates'];
        };
      };
    };
    /** @description Successfuly patched channel zone */
    PatchGcbChannelZoneRequestResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['GcbChannelZone'];
      };
    };
    /** @description Update room response. */
    PatchRoomResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Room'];
        };
      };
    };
    /** @description Successful response with details about a phone number. */
    PhoneNumberResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberDetailed'];
        };
      };
    };
    /** @description Successful response with details about a phone number including voice settings. */
    PhoneNumberWithMessagingSettingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberWithMessagingSettings'];
        };
      };
    };
    /** @description Successful response with details about a phone number including voice settings. */
    PhoneNumberWithVoiceSettingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PhoneNumberWithVoiceSettings'];
        };
      };
    };
    /** @description Portout Supporting Documents */
    PortOutListSupportingDocumentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortOutSupportingDocument'][];
        };
      };
    };
    /** @description PortabilityCheck Response */
    PortabilityCheckResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortabilityCheckDetails'][];
        };
      };
    };
    /** @description Portout Comment Response */
    PortoutCommentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutComment'];
        };
      };
    };
    /** @description Portout Response */
    PortoutResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutDetails'];
        };
      };
    };
    /** @description A new inserted phone number */
    PostGcbPhoneNumberRequestResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['GcbPhoneNumber'];
      };
    };
    /** @description Presigned URL Object Response */
    PresignedObjectUrlResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['PresignedObjectUrl'];
      };
    };
    /** @description Successful response */
    PublicInternetGatewayListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PublicInternetGatewayRead'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    PublicInternetGatewayResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PublicInternetGatewayRead'];
        };
      };
    };
    /** @description Success response with details about a push credential */
    PushCredentialResponse: {
      headers: {
        [name: string]: unknown;
      };
      content?: never;
    };
    /** @description Successful response with details about a call in a queue. */
    QueueCallResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['QueueCall'];
        };
      };
    };
    /** @description Successful response with details about a queue. */
    QueueResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Queue'];
        };
      };
    };
    /** @description A Comment Response */
    ReadCommentResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ReadComment'] & Record<string, never>;
        };
      };
    };
    /** @description A response with recording resource. */
    RecordingResponseBody: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['RecordingResponse'];
      };
    };
    /** @description A response with a recording transcription resource. */
    RecordingTranscriptionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RecordingTranscription'];
        };
      };
    };
    /** @description A response with recordings. */
    RecordingsResponseBody: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RecordingResponse'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Refresh fax response */
    RefreshFaxResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @example ok */
          result?: string;
        };
      };
    };
    /** @description Refresh room client token response. */
    RefreshRoomClientTokenResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @example {
           *       "token": "eyJhbGciOiJFZDI1NTE5IiwidHlwIjoiSldUIn0.eyJhdWQiOiJ0ZWxueXhfYWNjZXNzX3Rva2VuIiwiZXhwIjoxNjE5MDk0Mjk1LCJncmFudHMiOlt7ImFjdGlvbnMiOlsiam9pbiJdLCJyZXNvdXJjZXMiOlsidGVsbnl4OnZpZGVvOnJvb21zOjllMmEwY2JlLWNlNjYtNDExZS1hMWFjLTQ2OGYwYjEwM2M5YSJdLCJzdWJqZWN0cyI6WyJ0ZWxueXg6dXNlcnM6NzgyYjJjYmUtODQ2Ni00ZTNmLWE0ZDMtOTc4MWViNTc3ZTUwIl19XSwiZ3JhbnRzX3ZlcnNpb24iOiIxLjAuMCIsImlhdCI6MTYxOTA5MzY5NSwiaXNzIjoidGVsbnl4X2FjY2Vzc190b2tlbiIsImp0aSI6IjllNjIyOTA2LTc1ZTctNDBiNi1iOTAwLTc1NGIxZjNlZDMyZiIsIm5iZiI6MTYxOTA5MzY5NCwic3ViIjoibnVsbCIsInR5cCI6ImFjY2VzcyJ9.1JGK9PyHkTtoP_iMu-8TzXH_fhmnsDtZZOAJLDzLW6DDtAb80wZ93l1VH5yNx5tFqwIFG0t48dRiBKWlW-nzDA",
           *       "token_expires_at": "2021-04-22T12:24:55Z"
           *     } */
          data?: {
            /**
             * Format: jwt
             * @example eyJhbGciOiJIUzUxMiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJ0ZWxueXhfdGVsZXBob255IiwiZXhwIjoxNTkwMDEwMTQzLCJpYXQiOjE1ODc1OTA5NDMsImlzcyI6InRlbG55eF90ZWxlcGhvbnkiLCJqdGkiOiJiOGM3NDgzNy1kODllLTRhNjUtOWNmMi0zNGM3YTZmYTYwYzgiLCJuYmYiOjE1ODc1OTA5NDIsInN1YiI6IjVjN2FjN2QwLWRiNjUtNGYxMS05OGUxLWVlYzBkMWQ1YzZhZSIsInRlbF90b2tlbiI6InJqX1pra1pVT1pNeFpPZk9tTHBFVUIzc2lVN3U2UmpaRmVNOXMtZ2JfeENSNTZXRktGQUppTXlGMlQ2Q0JSbWxoX1N5MGlfbGZ5VDlBSThzRWlmOE1USUlzenl6U2xfYURuRzQ4YU81MHlhSEd1UlNZYlViU1ltOVdJaVEwZz09IiwidHlwIjoiYWNjZXNzIn0.gNEwzTow5MLLPLQENytca7pUN79PmPj6FyqZWW06ZeEmesxYpwKh0xRtA0TzLh6CDYIRHrI8seofOO0YFGDhpQ
             */
            token?: string;
            /**
             * Format: datetime
             * @description ISO 8601 timestamp when the token expires.
             * @example 2021-03-26T17:51:59Z
             */
            token_expires_at?: string;
          };
        };
      };
    };
    /** @description Successful response */
    RegionListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Region'][];
        };
      };
    };
    /** @description Successful response */
    RegisterSimCardsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /** @description Successfully registered SIM cards. */
          data?: components['schemas']['SimpleSIMCard'][];
          errors?: components['schemas']['Error'][];
        };
      };
    };
    /** @description Successful response with details about a credential connection registration status. */
    RegistrationStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          /**
           * Registration Status
           * @example {
           *       "data": {
           *         "record_type": "registration_status",
           *         "status": "Expired",
           *         "sip_username": "rogerp",
           *         "ip_address": "190.106.106.121",
           *         "transport": "UDP",
           *         "port": 37223,
           *         "user_agent": "Z 5.4.12 v2.10.13.2-mod",
           *         "last_registration": "2021-09-28T15:11:02",
           *         "id": "6a09cdc3-8948-47f0-aa62-74ac943d6c58"
           *       }
           *     }
           */
          data?: {
            /**
             * @description Identifies the type of the resource.
             * @example registration_status
             */
            record_type?: string;
            /**
             * @description The current registration status of your SIP connection
             * @enum {string}
             */
            status?:
              | 'Not Applicable'
              | 'Not Registered'
              | 'Failed'
              | 'Expired'
              | 'Registered'
              | 'Unregistered';
            /**
             * @description The user name of the SIP connection
             * @example sip_username
             */
            sip_username?: string;
            /**
             * @description The ip used during the SIP connection
             * @example 190.106.106.121
             */
            ip_address?: string;
            /**
             * @description The protocol of the SIP connection
             * @example TCP
             */
            transport?: string;
            /**
             * @description The port of the SIP connection
             * @example 37223
             */
            port?: number;
            /**
             * @description The user agent of the SIP connection
             * @example Z 5.4.12 v2.10.13.2-mod
             */
            user_agent?: string;
            /**
             * @description ISO 8601 formatted date indicating when the resource was last updated.
             * @example 2018-02-02T22:25:27.521Z
             */
            last_registration?: string;
          };
        };
      };
    };
    /** @description Resource not found */
    ResourceNotFound: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Error'];
      };
    };
    /** @description Resource not found */
    ResourceNotFoundErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          errors?: components['schemas']['ResourceNotFoundError'][];
        };
      };
    };
    /** @description Expected billing group response to a valid request */
    RetrieveBillingGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BillingGroup'];
        };
      };
    };
    /** @description Successful response with details about a call status. */
    RetrieveCallStatusResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Call'];
        };
      };
    };
    /** @description Expected ledger billing group report response to a valid request */
    RetrieveLedgerBillingGroupReportResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['LedgerBillingGroupReport'];
        };
      };
    };
    /** @description Successful response with details about a messaging profile's metrics. */
    RetrieveMessagingProfileMetrics: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MessagingProfileDetailedMetrics'];
        };
      };
    };
    /** @description Expected portout response to a valid request */
    RetrievePortoutResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutDetails'];
        };
      };
    };
    /** @description Successful Response */
    SIMCardActionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardAction'];
        };
      };
    };
    /** @description Successful response */
    SIMCardActivationCodeResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardActivationCode'];
        };
      };
    };
    /** @description Successful response */
    SIMCardDeviceDetailsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardDeviceDetails'];
        };
      };
    };
    /** @description Successful Response */
    SIMCardGroupActionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardGroupAction'];
        };
      };
    };
    /** @description A successful network preferences definition response. */
    SIMCardNetworkPreferenceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardNetworkPreference'];
        };
      };
    };
    /** @description A successful network preferences definition response. */
    SIMCardNetworkPreferenceWithOTAUpdatesResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardNetworkPreferenceWithOTAUpdates'];
        };
      };
    };
    /** @description Successful Response */
    SIMCardOrdersPreviewResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardOrderPreview'];
        };
      };
    };
    /** @description Successful response */
    SIMCardPublicIPResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardPublicIP'];
        };
      };
    };
    /** @description SSL Certificate Response */
    SSLCertificateResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SSLCertificate'];
        };
      };
    };
    /** @description Successful Response */
    SearchMobileNetworkOperatorsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['MobileNetworkOperator'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    SearchOTAUpdateResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimplifiedOTAUpdate'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    SearchSimCardsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimpleSIMCard'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Send fax response */
    SendFaxResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Fax'];
        };
      };
    };
    /** @description Successful response */
    SharePortingOrder: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrderSharingToken'];
        };
      };
    };
    /** @description Successful response with details about a short code. */
    ShortCodeResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ShortCode'];
        };
      };
    };
    /** @description Successful Response */
    ShowCustomerServiceRecord: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CustomerServiceRecord'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingEventResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingEvent'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingLOAConfiguration: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingLOAConfiguration'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingOrder: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrder'];
          meta?: {
            /**
             * @description Link to list all phone numbers
             * @example /v2/porting_phone_numbers?filter[porting_order_id]=eef10fb8-f3df-4c67-97c5-e18179723222
             */
            phone_numbers_url?: string;
          };
        };
      };
    };
    /** @description Successful response */
    ShowPortingOrdersActivationJob: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrdersActivationJob'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingOrdersComment: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrdersComment'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingPhoneNumber: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumber'];
          meta?: {
            /**
             * Format: uri
             * @description Link to list porting order
             * @example /porting_orders/a700d03c-4062-4091-8189-1b75216cf7a2
             */
            porting_order_url?: string;
          };
        };
      };
    };
    /** @description Successful response */
    ShowPortingPhoneNumberBlock: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumberBlock'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingPhoneNumberExtension: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingPhoneNumberExtension'];
        };
      };
    };
    /** @description Successful response */
    ShowPortingReport: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingReport'];
        };
      };
    };
    /** @description Successful response */
    ShowPortoutEventResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutEvent'];
        };
      };
    };
    /** @description Successful response */
    ShowPortoutReport: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutReport'];
        };
      };
    };
    /** @description Successful Response */
    SimCardActionCollectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardAction'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    SimCardDataUsageNotificationCollectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimCardDataUsageNotification'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful Response */
    SimCardGroupActionCollectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardGroupAction'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    SimpleSimCardResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimpleSIMCard'];
        };
      };
    };
    /** @description Successful Response */
    SinglePhoneNumberCampaign: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['PhoneNumberCampaign'];
      };
    };
    /** @description Successful response with a list of phone numbers. */
    SlimListPhoneNumbersResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SlimPhoneNumberDetailed'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Response for specific country coverage */
    SpecificCountryResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['CountryCoverage'];
        };
      };
    };
    /** @description Successful response with details about a sub number order. */
    SubNumberOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SubNumberOrder'];
        };
      };
    };
    /** @description Successful response */
    SubRequestByPortingOrder: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['GetSubRequestByPortingOrder'];
        };
      };
    };
    /** @description Successful response with details about a credential */
    TelephonyCredentialResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['TelephonyCredential'];
        };
      };
    };
    /** @description Successful response */
    TexmlApplicationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['TexmlApplication'];
        };
      };
    };
    /** @description Successful call recording create response */
    TexmlCreateCallRecordingResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['TexmlCreateCallRecordingResponseBody'];
      };
    };
    /** @description Successful call streaming create response */
    TexmlCreateCallStreamingResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['TexmlCreateCallStreamingResponseBody'];
      };
    };
    /** @description Retrieves call recording resource. */
    TexmlGetCallRecordingResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['TexmlGetCallRecordingResponseBody'];
      };
    };
    /** @description Successful Get Call Recordings Response */
    TexmlGetCallRecordingsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['TexmlGetCallRecordingsResponseBody'];
      };
    };
    /** @description Successful get Recording Transcription Response */
    TexmlGetRecordingTranscriptionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['TexmlRecordingTranscription'];
      };
    };
    /** @description Successful list Recording Transcriptions Response */
    TexmlListRecordingTranscriptionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          transcriptions?: components['schemas']['TexmlRecordingTranscription'][];
          /**
           * @description The number of the last element on the page, zero-indexed
           * @example 1
           */
          end?: number;
          /**
           * Format: uri
           * @description Relative uri to the first page of the query results
           * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Transcriptions.json?Page=0&PageSize=1
           */
          first_page_uri?: string;
          /**
           * Format: uri
           * @description Relative uri to the previous page of the query results
           * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Transcriptions.json?PageToken=MZQTDUHX&PageSize=1
           */
          previous_page_uri?: string;
          /**
           * @description Relative uri to the next page of the query results
           * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Transcriptions.json?PageToken=KRWXZPO&PageSize=1
           */
          next_page_uri?: string;
          /**
           * @description Current page number, zero-indexed.
           * @example 0
           */
          page?: number;
          /**
           * @description The number of items on the page
           * @example 20
           */
          page_size?: number;
          /**
           * @description The number of the first element on the page, zero-indexed.
           * @example 0
           */
          start?: number;
          /**
           * @description The URI of the current page.
           * @example /v2/texml/Accounts/61bf923e-5e4d-4595-a110-56190ea18a1b/Transcriptions.json?PageToken=YTBNAXPI&PageSize=1
           */
          uri?: string;
        };
      };
    };
    /** @description Successful call streaming update response */
    TexmlUpdateCallStreamingResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['TexmlUpdateCallStreamingResponseBody'];
      };
    };
    /** @description Unauthorized */
    UnauthenticatedResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description The required authentication headers were either invalid or not included in the request. */
    UnauthorizedErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          errors?: components['schemas']['UnauthorizedError'][];
        };
      };
    };
    /** @description Unauthorized Request */
    UnauthorizedRequestErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Errors'];
      };
    };
    /** @description Unauthorized */
    UnauthorizedResponse: {
      headers: {
        [name: string]: unknown;
      };
      content?: never;
    };
    /** @description An unexpected error occurred. */
    UnexpectedErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          errors?: components['schemas']['UnexpectedError'][];
        };
      };
    };
    /** @description Unprocessable entity. Check the 'detail' field in response for details. */
    UnprocessableEntity: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['Errors'];
      };
    };
    /** @description Unprocessable entity. Check the 'detail' field in response for details. */
    UnprocessableEntityErrorResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          errors?: components['schemas']['UnprocessableEntityError'][];
        };
      };
    };
    /** @description The request was well-formed but was unable to be followed due to semantic errors. */
    UnprocessableEntityResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': components['schemas']['ErrorResponse'];
      };
    };
    /** @description Unprocessable entity. Check the 'detail' field in response for details. */
    UnprocessableManagedAccountEntity: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          errors?: components['schemas']['UnprocessableEntityError'][];
        };
      };
    };
    /** @description Expected billing group response to a valid request */
    UpdateBillingGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['BillingGroup'];
        };
      };
    };
    /** @description Successful response with information about the allocatable global outbound channels for the given account. */
    UpdateManagedAccountGlobalChannelLimitResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SingleManagedAccountGlobalOutboundChannels'];
        };
      };
    };
    /** @description Successful response */
    UpdatePortingLOAConfiguration: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingLOAConfiguration'];
        };
      };
    };
    /** @description Successful response */
    UpdatePortingOrderResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingOrder'];
          meta?: {
            /** @description Link to list all phone numbers */
            phone_numbers_url?: string;
          };
        };
      };
    };
    /** @description Expected portout response to a valid request */
    UpdatePortoutResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortoutDetails'];
        };
      };
    };
    /** @description Successful Response */
    UpdateSimCardDataUsageNotificationResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SimCardDataUsageNotification'];
        };
      };
    };
    /** @description Successful Response */
    UpdateSimCardGroupResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCardGroup'];
        };
      };
    };
    /** @description Successful response */
    UpdateSimCardResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['SIMCard'];
        };
      };
    };
    /** @description Successful response upon updating a TeXML call. */
    UpdateTeXMLCallResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['UpdateCommandResult'];
        };
      };
    };
    /** @description Get user balance details */
    UserBalanceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['UserBalance'];
        };
      };
    };
    /** @description Action response */
    ValidateAddressResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['ValidateAddressResult'];
        };
      };
    };
    /** @description Successful response */
    VerifyPortingVerificationCodes: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['PortingVerificationCode'][];
        };
      };
    };
    /** @description Successful response */
    VirtualCrossConnectCoverageListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['VirtualCrossConnectCoverage'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    VirtualCrossConnectListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['VirtualCrossConnectCombined'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    VirtualCrossConnectResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['VirtualCrossConnectCombined'];
        };
      };
    };
    /** @description Successful response */
    VoicemailResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['VoicemailPrefResponse'];
        };
      };
    };
    /** @description Successful response */
    WireguardInterfaceListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WireguardInterfaceRead'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    WireguardInterfaceResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WireguardInterfaceRead'];
        };
      };
    };
    /** @description Successful response */
    WireguardPeerListResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WireguardPeer'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Successful response */
    WireguardPeerResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WireguardPeer'];
        };
      };
    };
    /** @description Successful Response */
    WirelessConnectivityLogCollectionResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['WirelessConnectivityLog'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description An array of Comment Responses */
    listCommentsResponse: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['Comment'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
    /** @description Dynamic Emergency Address Responses */
    listDynamicEmergencyAddresses: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DynamicEmergencyAddress'][];
          meta?: components['schemas']['Metadata'];
        };
      };
    };
    /** @description Dynamic Emergency Endpoints Responses */
    listDynamicEmergencyEndpoints: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['DynamicEmergencyEndpoint'][];
          meta?: components['schemas']['Metadata'];
        };
      };
    };
    /** @description An array of Regulatory Requirements Responses */
    listRegulatoryRequirements: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RegulatoryRequirements'][];
        };
      };
    };
    /** @description An array of Regulatory Requirements Responses */
    listRegulatoryRequirementsPhoneNumbers: {
      headers: {
        [name: string]: unknown;
      };
      content: {
        'application/json': {
          data?: components['schemas']['RegulatoryRequirementsPhoneNumbers'][];
          meta?: components['schemas']['PaginationMeta'];
        };
      };
    };
  };
  parameters: {
    /** @description The id of the account the resource belongs to. */
    AccountSid: string;
    /** @description The ID of the TeXML application used for the call. */
    ApplicationId: string;
    /** @description Filter by the associated record type */
    AssociatedRecordType: 'account' | 'phone_number';
    /** @description The id of the billing group */
    BillingGroupId: string;
    /** @description Unique identifier and token for controlling the call */
    CallControlId: string;
    /** @description The CallSid that identifies the call to update. */
    CallSid: string;
    /** @description Filter by the id of a channel type */
    ChannelTypeId: 'webhook' | 'sms' | 'email' | 'voice';
    /** @description Identifies the child resource */
    ChildId: string;
    /** @description The ConferenceSid that uniquely identifies a conference. */
    ConferenceSid: string;
    /**
     * @description Filters conferences by status.
     * @example in-progress
     */
    ConferenceStatus: 'init' | 'in-progress' | 'completed';
    /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
    ConnectionId: string;
    /** @description Filters records to those created after a specific date. */
    CreatedAtGtFilter: string;
    /** @description Filters records to those created before a specific date. */
    CreatedAtLtFilter: string;
    /**
     * @description Filters conferences by the creation date. Expected format is YYYY-MM-DD. Also accepts inequality operators, e.g. DateCreated>=2023-05-22.
     * @example >=2023-05-22
     */
    DateCreated: string;
    /**
     * @description Filters conferences by the time they were last updated. Expected format is YYYY-MM-DD. Also accepts inequality operators, e.g. DateUpdated>=2023-05-22.
     * @example >=2023-05-22
     */
    DateUpdated: string;
    /** @description Filters requirements to those applying to a specific action. */
    DocReqsActionFilter: 'ordering' | 'porting';
    /** @description Filters results to those applying to a 2-character (ISO 3166-1 alpha-2) country code */
    DocReqsCountryFilter: string;
    /** @description Filters results to those applying to a specific `phone_number_type` */
    DocReqsPhoneNumberTypeFilter: 'local' | 'national' | 'toll-free';
    /**
     * @description Uniquely identifies the requirement_type record
     * @example a9dad8d5-fdbd-49d7-aa23-39bb08a5ebaa
     */
    DocReqsRequirementId: string;
    /**
     * @description Uniquely identifies the requirement_type record
     * @example a38c217a-8019-48f8-bff6-0fdd9939075b
     */
    DocReqsRequirementTypeId: string;
    /** @description Filters requirement types to those whose name contains a certain string. */
    DocReqsRequirementTypeNameFilter: string;
    /** @description Specifies the sort order for results. If you want to sort by a field in ascending order, include it as a sort parameter. If you want to sort in descending order, prepend a `-` in front of the field name. */
    DocReqsRequirementTypesSort: 'created_at' | 'name' | 'updated_at';
    /** @description Specifies the sort order for results. If you want to sort by a field in ascending order, include it as a sort parameter. If you want to sort in descending order, prepend a `-` in front of the field name. */
    DocReqsRequirementsSort:
      | 'action'
      | 'country_code'
      | 'locality'
      | 'phone_number_type';
    /** @description Identifies the associated document to filter on. */
    DocServiceDocumentIdFilter: string;
    /** @description Filter by created at greater than provided value. */
    DocumentsCreatedAtGreaterThanFilter: string;
    /** @description Filter by created at less than provided value. */
    DocumentsCreatedAtLessThanFilter: string;
    /** @description Filter documents by a customer references. */
    DocumentsCustomerReferenceEqFilter: string;
    /** @description Filter documents by a list of customer references. */
    DocumentsCustomerReferenceInFilter: string;
    /** @description Filter by string matching part of filename. */
    DocumentsFilenameContainsFilter: string;
    /** @description Specifies the sort order for results. If you want to sort by a field in ascending order, include it as a sort parameter. If you want to sort in descending order, prepend a `-` in front of the field name. */
    DocumentsSort: 'filename' | 'created_at' | 'updated_at';
    /**
     * @description Filters calls by their end date. Expected format is YYYY-MM-DD
     * @example 2023-05-22
     */
    EndTime: string;
    /**
     * @description Filters calls by their end date (before). Expected format is YYYY-MM-DD
     * @example 2023-05-22
     */
    'EndTime<': string;
    /**
     * @description Filters calls by their end date (after). Expected format is YYYY-MM-DD
     * @example 2023-05-22
     */
    'EndTime>': string;
    /** @description If present, only returns results with the <code>address_book</code> flag set to the given value. */
    FilterAddressBook: string;
    /** @description Filter by state or province where the address is located. */
    FilterAddressByAdministrativeArea: string;
    /** @description Filter by the mobile operator two-character (ISO 3166-1 alpha-2) origin country code. */
    FilterAddressByCountryCode: string;
    /** @description Returns entries with matching name of the supplemental field for address information. */
    FilterAddressByExtendedAddress: string;
    /** @description Uniquely identifies the address for the order. */
    FilterAddressById: string;
    /** @description Filter by the name of the city where the address is located. */
    FilterAddressByLocality: string;
    /** @description Filter by postal code for the address. */
    FilterAddressByPostalCode: string;
    /** @description Returns entries with matching name of the street where the address is located. */
    FilterAddressByStreetAddress: string;
    /** @description If present, applications with <code>application_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
    FilterApplicationName: string;
    /** @description Filter by a specific status of the resource's lifecycle. */
    FilterBasicStatusLifecycle: 'in-progress' | 'completed' | 'failed';
    /** @description Filter by a bulk SIM card action ID. */
    FilterBulkSIMCardActionId: string;
    /** @description Filter results by phone number */
    FilterByPhoneNumber: string;
    /** @description Filter results by a list of phone numbers */
    FilterByPhoneNumberIn: string[];
    /** @description Filter results by portability status */
    FilterByPortabilityStatus: components['schemas']['PortabilityStatus'];
    /** @description Filter results by activation status */
    FilterByPortingOrderActivationStatus: components['schemas']['PortingOrderActivationStatus'];
    /** @description Filter results by porting order id */
    FilterByPortingOrderID: string;
    /** @description Filter results by a list of porting order ids */
    FilterByPortingOrderIdIn: string[];
    /** @description Filter results by status */
    FilterByPortingOrderStatus:
      | 'draft'
      | 'in-process'
      | 'submitted'
      | 'exception'
      | 'foc-date-confirmed'
      | 'cancel-pending'
      | 'ported'
      | 'cancelled';
    /** @description Filter porting orders by multiple statuses */
    FilterByPortingOrderStatusIn:
      | 'draft'
      | 'in-process'
      | 'submitted'
      | 'exception'
      | 'foc-date-confirmed'
      | 'cancel-pending'
      | 'ported'
      | 'cancelled';
    /** @description Filter results by support key */
    FilterBySupportKeyEq: string;
    /** @description Filter results by a list of support keys */
    FilterBySupportKeyIn: string[];
    /** @description Filter results by the TCR Brand id */
    FilterByTCRBrandID: string;
    /** @description Filter results by the TCR Campaign id */
    FilterByTCRCampaignID: string;
    /** @description Filter results by the Telnyx Brand id */
    FilterByTelnyxBrandID: string;
    /** @description Filter results by the Telnyx Campaign id */
    FilterByTelnyxCampaignID: string;
    /** @description Event status */
    FilterCallEventStatus: 'delivered' | 'failed';
    /** @description Event timestamp: equal */
    FilterCallEventTimestampEqualTo: string;
    /** @description Event timestamp: greater than */
    FilterCallEventTimestampGreaterThan: string;
    /** @description Event timestamp: greater than or equal */
    FilterCallEventTimestampGreaterThanOrEqualTo: string;
    /** @description Event timestamp: lower than */
    FilterCallEventTimestampLessThan: string;
    /** @description Event timestamp: lower than or equal */
    FilterCallEventTimestampLessThanOrEqualTo: string;
    /** @description Event type */
    FilterCallEventType: 'command' | 'webhook';
    /** @description The unique identifier of an individual call leg. */
    FilterCallLegId: string;
    /** @description The unique identifier of the call control session. A session may include multiple call leg events. */
    FilterCallSessionId: string;
    /** @description The civic address ID to filter by */
    FilterCivicAddressId: string;
    /** @description If present, conferences will be filtered to those with a matching `name` attribute. Matching is case-sensitive */
    FilterConferenceName: string;
    /** @description If present, conferences will be filtered by status. */
    FilterConferenceStatus: 'init' | 'in_progress' | 'completed';
    /** @description If present, connections with <code>connection_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
    FilterConnectionName: string;
    /** @description The total monetary amount of the order. */
    FilterCostByAmount: string;
    /** @description Filter by ISO 4217 currency string. */
    FilterCostByCurrency: string;
    /** @description Filter by ISO 8601 formatted date-time string matching resource creation date-time. */
    FilterCreatedAt: string;
    /** @description If present, addresses with <code>customer_reference</code> containing the given value will be returned. Matching is not case-sensitive. */
    FilterCustomerReferenceContains: string;
    /** @description Filter addresses via the customer reference set. Matching is not case-sensitive. */
    FilterCustomerReferenceEquals: string;
    /** @description If present, email containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
    FilterEmailContains: string;
    /** @description If present, only returns results with the <code>email</code> matching exactly the value given. */
    FilterEmailEq: string;
    /** @description The external connection ID to filter by or "null" to filter for logs without an external connection ID */
    FilterExternalConnectionId: string;
    /** @description If present, connections with <code>external_sip_connection</code> matching the given value will be returned. */
    FilterExternalSipConnection: 'zoom' | 'operator_connect';
    /** @description If present, connections with an `fqdn` that equals the given value will be returned. Matching is case-sensitive, and the full string must match. */
    FilterFqdn: string;
    /** @description If present, connections with <code>id</code> matching the given value will be returned. */
    FilterId: string;
    /** @description Identifies the associated outbound voice profile. */
    FilterInnerOutboundVoiceProfileId: string;
    /** @description The location ID to filter by */
    FilterLocationId: string;
    /** @description Filter by name */
    FilterName: string;
    /** @description If present, only returns results with the <code>organization_name</code> containing the given value. Matching is not case-sensitive. Requires at least three characters. */
    FilterOrganizationEmailContains: string;
    /** @description If present, only returns results with the <code>organization_name</code> matching exactly the value given. */
    FilterOrganizationEmailEq: string;
    /** @description Identifies the associated outbound voice profile. */
    FilterOutboundVoiceProfileId: string;
    /** @description If present, connections associated with the given phone_number will be returned. A full match is necessary with a e164 format. */
    FilterPhoneNumber: string;
    /** @description The partial phone number to filter by. Requires 3-15 digits. */
    FilterPhoneNumberContains: string;
    /** @description The phone number to filter by */
    FilterPhoneNumberEq: string;
    /** @description The partial phone number to filter log messages for. Requires 3-15 digits. */
    FilterPhoneNumberLogMessageContains: string;
    /** @description The phone number to filter log messages for or "null" to filter for logs without a phone number */
    FilterPhoneNumberLogMessageEq: string;
    /** @description Filter orders by how many SIM cards were ordered. */
    FilterQuantity: number;
    /** @description Returns orders with <code>quantity</code> lower than the specified argument. */
    FilterQuantityLessThan: number;
    /** @description The status of the release to filter by */
    FilterReleaseStatus: (
      | 'pending_upload'
      | 'pending'
      | 'in_progress'
      | 'complete'
      | 'failed'
      | 'expired'
      | 'unknown'
    )[];
    /** @description Filter by resource_id */
    FilterResourceId: string;
    /** @description A valid SIM card group ID. */
    FilterSIMCardGroupId: string;
    /** @description A valid SIM card ID. */
    FilterSIMCardId: string;
    /** @description Filter by sip_username */
    FilterSipUsername: string;
    /** @description Filter by status */
    FilterStatus: string;
    /** @description If present, addresses with <code>street_address</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
    FilterStreetAddress: string;
    /** @description Filter by ISO 8601 formatted date-time string matching resource last update date-time. */
    FilterUpdatedAt: string;
    /** @description The status of the upload to filter by */
    FilterUploadStatus: (
      | 'pending_upload'
      | 'pending'
      | 'in_progress'
      | 'success'
      | 'error'
    )[];
    /** @description If set as 'true', only addresses used as the emergency address for at least one active phone-number will be returned. When set to 'false', the opposite happens: only addresses not used as the emergency address from phone-numbers will be returned. */
    FilterUsedAsEmergency: string;
    /** @description Identifies the resource. */
    FqdnId: string;
    /**
     * @description Filters conferences by their friendly name.
     * @example weekly_review_call
     */
    FriendlyName: string;
    /**
     * @description Filters calls by the from number.
     * @example +1312345678
     */
    From: string;
    /** @description Channel zone identifier */
    GcbChannelZoneId: string;
    /** @description The phone number to be looked up */
    GcbPhoneNumber: string;
    /** @description Identifies the resource. */
    Id: string;
    /** @description Specifies if cancelled accounts should be included in the results. */
    IncludeCancelledAccounts: boolean;
    /** @description It includes the associated OTA update objects in the response when present. */
    IncludeOTAUpdates: boolean;
    /** @description It includes the associated SIM card group object in the response when present. */
    IncludeSIMCardGroup: boolean;
    /** @description Identifies the resource. */
    IntId: string;
    /** @description Identifies the type of resource. */
    IpId: string;
    /** @description The id of the ledger billing group report */
    LedgerBillingGroupReportId: string;
    /** @description The `linked_record_type` of the document to filter on. */
    LinkedRecordTypeFilter: string;
    /** @description The `linked_resource_id` of the document to filter on. */
    LinkedResourceIdFilter: string;
    /** @description Uniquely identifies a media resource. */
    MediaName: string;
    /** @description The id of the messaging profile to retrieve */
    MessagingProfileId: string;
    /** @description The id of the messaging profile(s) to retrieve */
    MessagingProfileMetric: string;
    /** @description The timeframe for which you'd like to retrieve metrics. */
    MessagingProfileMetricTimeFrame: '1h' | '3h' | '24h' | '3d' | '7d' | '30d';
    /** @description Optional filter on outbound voice profile name. */
    NameFilter: string;
    /** @description Filter by the id of a notification channel */
    NotificationChannelId: string;
    /** @description Filter by the id of a notification channel */
    NotificationEventConditionId: string;
    /** @description Filter by the id of a notification profile */
    NotificationProfileId: string;
    /** @description Specifies the type of number lookup to be performed */
    NumberLookupType: 'carrier' | 'caller-name';
    /** @description Filter by tag */
    OptionalTag: string;
    /**
     * @description The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
     * @example 1
     */
    Page: number;
    /** @description Opaque identifier of next page */
    PageAfter: string;
    /** @description Opaque identifier of previous page */
    PageBefore: string;
    /** @description Limit of records per single page */
    PageLimit: number;
    /** @description The page number to load */
    PageNumber: number;
    /** @description The size of the page */
    PageSize: number;
    /**
     * @description The number of records to be displayed on a page
     * @example 10
     */
    PageSizeTexml: number;
    /** @description Used to request the next page of results. */
    PageToken: string;
    /** @description Comment id */
    PathCommentID: string;
    /** @description The ID of the customer service record */
    PathCustomerServiceRecordId: string;
    /** @description Phone number */
    PathPhoneNumber: string;
    /** @description Porting Order id */
    PathPortingOrderID: string;
    /** @description Activation Job Identifier */
    PathPortingOrdersActivationJobID: string;
    /** @description The phone number to be looked up */
    PhoneNumber: string;
    /** @description Filters records to those with a specified number. */
    PhoneNumberEqFilter: string;
    /** @description Filters records to those with at least one number in the list. */
    PhoneNumberInFilter: string[];
    /** @description Identifies the private wireless gateway. */
    PrivateWirelessGatewayId: string;
    /** @description Include the first 50 phone number objects in the results */
    QueryIncludePhoneNumbers: boolean;
    /** @description Uniquely identifies the recording by id. */
    RecordingId: string;
    /** @description Uniquely identifies the recording by id. */
    RecordingSid: string;
    RecordingTranscriptionId: string;
    /** @description Uniquely identifies the recording transcription by id. */
    RecordingTranscriptionSid: string;
    /** @description Filter by tag, required by bulk operations. */
    RequiredTag: string;
    /** @description Identifies the resource. */
    ResourceId: string;
    /** @description Identifies the SIM group. */
    SIMCardGroupId: string;
    /** @description Identifies the SIM. */
    SIMCardId: string;
    /** @description The id of the short code */
    ShortCodeId: string;
    /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
     *     That is: <ul>
     *       <li>
     *         <code>email</code>: sorts the result by the
     *         <code>email</code> field in ascending order.
     *       </li>
     *
     *       <li>
     *         <code>-email</code>: sorts the result by the
     *         <code>email</code> field in descending order.
     *       </li>
     *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
    Sort: 'created_at' | 'email';
    /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
     *     That is: <ul>
     *       <li>
     *         <code>street_address</code>: sorts the result by the
     *         <code>street_address</code> field in ascending order.
     *       </li>
     *
     *       <li>
     *         <code>-street_address</code>: sorts the result by the
     *         <code>street_address</code> field in descending order.
     *       </li>
     *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
    SortAddress:
      | 'created_at'
      | 'first_name'
      | 'last_name'
      | 'business_name'
      | 'street_address';
    /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
     *     That is: <ul>
     *       <li>
     *         <code>friendly_name</code>: sorts the result by the
     *         <code>friendly_name</code> field in ascending order.
     *       </li>
     *
     *       <li>
     *         <code>-friendly_name</code>: sorts the result by the
     *         <code>friendly_name</code> field in descending order.
     *       </li>
     *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
    SortApplication: 'created_at' | 'friendly_name' | 'active';
    /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
     *     That is: <ul>
     *       <li>
     *         <code>name</code>: sorts the result by the
     *         <code>name</code> field in ascending order.
     *       </li>
     *
     *       <li>
     *         <code>-name</code>: sorts the result by the
     *         <code>name</code> field in descending order.
     *       </li>
     *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
    SortAuthenticationProvider:
      | 'name'
      | '-name'
      | 'short_name'
      | '-short_name'
      | 'active'
      | '-active'
      | 'created_at'
      | '-created_at'
      | 'updated_at'
      | '-updated_at';
    /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
     *     That is: <ul>
     *       <li>
     *         <code>connection_name</code>: sorts the result by the
     *         <code>connection_name</code> field in ascending order.
     *       </li>
     *
     *       <li>
     *         <code>-connection_name</code>: sorts the result by the
     *         <code>connection_name</code> field in descending order.
     *       </li>
     *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
    SortConnection: 'created_at' | 'connection_name' | 'active';
    /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code>-</code> prefix.<br/><br/>
     *     That is: <ul>
     *       <li>
     *         <code>name</code>: sorts the result by the
     *         <code>name</code> field in ascending order.
     *       </li>
     *
     *       <li>
     *         <code>-name</code>: sorts the result by the
     *         <code>name</code> field in descending order.
     *       </li>
     *     </ul> <br/> */
    SortOutboundVoiceProfile:
      | 'enabled'
      | '-enabled'
      | 'created_at'
      | '-created_at'
      | 'name'
      | '-name'
      | 'service_plan'
      | '-service_plan'
      | 'traffic_type'
      | '-traffic_type'
      | 'usage_payment_method'
      | '-usage_payment_method';
    /**
     * @description Filters calls by their start date. Expected format is YYYY-MM-DD.
     * @example 2023-05-22
     */
    StartTime: string;
    /**
     * @description Filters calls by their start date (before). Expected format is YYYY-MM-DD
     * @example 2023-05-22
     */
    'StartTime<': string;
    /**
     * @description Filters calls by their start date (after). Expected format is YYYY-MM-DD
     * @example 2023-05-22
     */
    'StartTime>': string;
    /**
     * @description Filters calls by status.
     * @example no-answer
     */
    Status: 'canceled' | 'completed' | 'failed' | 'busy' | 'no-answer';
    /** @description Filters records to those with a specific status. */
    StatusEqFilter: 'pending' | 'completed' | 'failed';
    /** @description Filters records to those with a least one status in the list. */
    StatusInFilter: ('pending' | 'completed' | 'failed')[];
    /** @description Uniquely identifies the streaming by id. */
    StreamingSid: string;
    /** @description Filters recording by the creation date. Expected format is ISO8601 date or date-time, ie. {YYYY}-{MM}-{DD} or {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}Z. Also accepts inequality operators, e.g. DateCreated>=2023-05-22. */
    TexmlDateCreated: string;
    /** @description Filter by timestamp greater than */
    TimestampGreater: string;
    /** @description Filter by timestamp less than */
    TimestampLess: string;
    /**
     * @description Filters calls by the to number.
     * @example +1312345678
     */
    To: string;
    /** @description Identifies a civic address or a location. */
    address_id: string;
    /** @description Identifies the resource. */
    id: string;
    /** @description A phone number's ID via the Telnyx API */
    phone_number_id: string;
    /** @description Identifies a Release request */
    release_id: string;
    /** @description Identifies an Upload request */
    ticket_id: string;
  };
  requestBodies: {
    /** @description Creates new credentials resource for given connection_id. */
    CreateCredentialsRequest: {
      content: {
        'application/json': components['schemas']['CustomStorageConfiguration'];
      };
    };
    CreateCustomerServiceRecord: {
      content: {
        'application/json': {
          /**
           * @description A valid US phone number in E164 format.
           * @example +1234567890
           */
          phone_number: string;
          /**
           * @description Callback URL to receive webhook notifications.
           * @example https://example.com/webhook
           */
          webhook_url?: string;
          additional_data?: components['schemas']['CustomerServiceRecordAdditionalData'];
        };
      };
    };
    /** @description A list of additional document parameters */
    CreatePortingAdditionalDocuments: {
      content: {
        'application/json': {
          additional_documents?: {
            /**
             * @description The type of document being created.
             * @enum {string}
             */
            document_type?: 'loa' | 'invoice' | 'csr' | 'other';
            /**
             * Format: uuid
             * @description The document identification
             */
            document_id?: string;
          }[];
        };
      };
    };
    CreatePortingLOAConfiguration: {
      content: {
        'application/json': {
          /**
           * @description The name of the LOA configuration
           * @example My LOA Configuration
           */
          name: string;
          /** @description The logo of the LOA configuration */
          logo: {
            /**
             * Format: uuid
             * @description The document identification
             */
            document_id: string;
          };
          /**
           * @description The name of the company
           * @example Telnyx
           */
          company_name: string;
          /** @description The address of the company. */
          address: {
            /**
             * @description The street address of the company
             * @example 311 W. Superior St
             */
            street_address: string;
            /**
             * @description The extended address of the company
             * @example Suite 504
             */
            extended_address?: string;
            /**
             * @description The locality of the company
             * @example Chicago
             */
            city?: string;
            /**
             * @description The administrative area of the company
             * @example IL
             */
            state?: string;
            /**
             * @description The postal code of the company
             * @example 60654
             */
            zip_code?: string;
            /**
             * @description The country code of the company
             * @example US
             */
            country_code: string;
          };
          /** @description The contact information of the company. */
          contact: {
            /**
             * Format: email
             * @description The email address of the contact
             * @example testing@telnyx.com
             */
            email: string;
            /**
             * @description The phone number of the contact
             * @example +12003270001
             */
            phone_number: string;
          };
        };
      };
    };
    CreatePortingPhoneNumberBlock: {
      content: {
        'application/json': {
          phone_number_range: {
            /**
             * @description Specifies the start of the phone number range for this porting phone number block.
             * @example +4930244999901
             */
            start_at: string;
            /**
             * @description Specifies the end of the phone number range for this porting phone number block.
             * @example +4930244999910
             */
            end_at: string;
          };
          /** @description Specifies the activation ranges for this porting phone number block. The activation range must be within the block range and should not overlap with other activation ranges. */
          activation_ranges: {
            /**
             * @description Specifies the start of the activation range. Must be greater or equal the start of the extension range.
             * @example +4930244999901
             */
            start_at: string;
            /**
             * @description Specifies the end of the activation range. It must be no more than the end of the extension range.
             * @example +4930244999910
             */
            end_at: string;
          }[];
        };
      };
    };
    /** @description A list of phone number configuration parameters */
    CreatePortingPhoneNumberConfigurations: {
      content: {
        'application/json': {
          phone_number_configurations?: {
            /**
             * Format: uuid
             * @description Identifies the porting phone number to be configured.
             * @example 927f4687-318c-44bc-9f2f-22a5898143a4
             */
            porting_phone_number_id: string;
            /**
             * Format: uuid
             * @description Identifies the user bundle to be associated with the porting phone number.
             * @example ff901545-3e27-462a-ba9d-2b34654cab82
             */
            user_bundle_id: string;
          }[];
        };
      };
    };
    CreatePortingPhoneNumberExtension: {
      content: {
        'application/json': {
          /**
           * Format: uuid
           * @description Identifies the porting phone number associated with this porting phone number extension.
           * @example f24151b6-3389-41d3-8747-7dd8c681e5e2
           */
          porting_phone_number_id: string;
          extension_range: {
            /**
             * @description Specifies the start of the extension range for this porting phone number extension.
             * @example 1
             */
            start_at: number;
            /**
             * @description Specifies the end of the extension range for this porting phone number extension.
             * @example 10
             */
            end_at: number;
          };
          /** @description Specifies the activation ranges for this porting phone number extension. The activation range must be within the extension range and should not overlap with other activation ranges. */
          activation_ranges: {
            /**
             * @description Specifies the start of the activation range. Must be greater or equal the start of the extension range.
             * @example 1
             */
            start_at: number;
            /**
             * @description Specifies the end of the activation range. It must be no more than the end of the extension range.
             * @example 10
             */
            end_at: number;
          }[];
        };
      };
    };
    CreatePortingReport: {
      content: {
        'application/json': {
          /**
           * @description Identifies the type of report
           * @example export_porting_orders_csv
           * @enum {string}
           */
          report_type: 'export_porting_orders_csv';
          params: components['schemas']['ExportPortingOrdersCSVReport'];
        };
      };
    };
    CreatePortoutReport: {
      content: {
        'application/json': {
          /**
           * @description Identifies the type of report
           * @example export_portouts_csv
           * @enum {string}
           */
          report_type: 'export_portouts_csv';
          params: components['schemas']['ExportPortoutsCSVReport'];
        };
      };
    };
    /** @description Deletes recordings for given ids. */
    DeleteRecordingsRequest: {
      content: {
        'application/json': string[];
      };
    };
    /** @description The params expected to create/update a Dialogflow Connection for given connection_id. */
    DialogflowConnectionRequest: {
      content: {
        'application/json': components['schemas']['DialogflowConnection'];
      };
    };
    /** @description A list of phone numbers to send the verification codes to and the method to send them by */
    SendPortingVerificationCodes: {
      content: {
        'application/json': {
          phone_numbers?: string[];
          /** @enum {string} */
          verification_method?: 'sms' | 'call';
        };
      };
    };
    SharePortingOrder: {
      content: {
        'application/json': {
          /** @description The number of seconds the token will be valid for */
          expires_in_seconds?: number;
          /**
           * @description The permissions the token will have
           * @enum {string}
           */
          permissions?:
            | 'porting_order.document.read'
            | 'porting_order.document.update';
        };
      };
    };
    /** @description Starts call recording on a call. */
    TexmlCreateCallRecordingRequest: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['TexmlCreateCallRecordingRequestBody'];
      };
    };
    /** @description Start streaming media from a call */
    TexmlCreateCallStreamingRequest: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['TexmlCreateCallStreamingRequestBody'];
      };
    };
    /** @description Update call recording on a call. */
    TexmlUpdateCallRecordingRequest: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['TexmlUpdateCallRecordingRequestBody'];
      };
    };
    /** @description Update streaming */
    TexmlUpdateCallStreamingRequest: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['TexmlUpdateCallStreamingRequestBody'];
      };
    };
    UpdatePortingOrdersActivationJob: {
      content: {
        'application/json': {
          /**
           * Format: date-time
           * @description The desired activation time. The activation time should be between any of the activation windows.
           * @example 2019-01-01T00:00:00Z
           */
          activate_at?: string;
        };
      };
    };
    VerifyCustomerServiceRecordPhoneNumberCoverage: {
      content: {
        'application/json': {
          /** @description The phone numbers list to be verified. */
          phone_numbers: string[];
        };
      };
    };
    /** @description A list of phone numbers and their verification codes */
    VerifyPortingVerificationCodes: {
      content: {
        'application/json': {
          verification_codes?: {
            phone_number?: string;
            code?: string;
          }[];
        };
      };
    };
  };
  headers: never;
  pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
  ListBuckets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/xml': components['schemas']['ListBucketsResponse'];
        };
      };
    };
  };
  ListAccessIpAddresses: {
    parameters: {
      query?: {
        'filter[ip_source]'?: string;
        'filter[ip_address]'?: string;
        'filter[created_at][gt]'?: string;
        'filter[created_at][lt]'?: string;
        'page[number]'?: number;
        'page[size]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccessIPAddressListResponseSchema'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  CreateAccessIpAddress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AccessIPAddressPOST'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccessIPAddressResponseSchema'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  GetAccessIpAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        access_ip_address_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccessIPAddressResponseSchema'];
        };
      };
    };
  };
  DeleteAccessIpAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        access_ip_address_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccessIPAddressResponseSchema'];
        };
      };
    };
  };
  ListAccessIpRanges: {
    parameters: {
      query?: {
        'filter[cidr_block]'?: string;
        'filter[cidr_block][startswith]'?: string;
        'filter[cidr_block][endswith]'?: string;
        'filter[cidr_block][contains]'?: string;
        'filter[created_at][gt]'?: string;
        'filter[created_at][lt]'?: string;
        'page[number]'?: number;
        'page[size]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccessIPRangeListResponseSchema'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  CreateAccessIPRange: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AccessIPRangePOST'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AccessIPRangeResponseSchema'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  CreateBulkTelephonyCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Requested parameters to create credentials on bulk */
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkCredentialRequest'];
      };
    };
    responses: {
      201: components['responses']['BulkCredentialResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteTelephonyCredentials: {
    parameters: {
      query: {
        /** @description Filter by tag, required by bulk operations. */
        'filter[tag]': components['parameters']['RequiredTag'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      201: components['responses']['BulkCredentialResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateBulkTelephonyCredential: {
    parameters: {
      query: {
        /** @description Filter by tag, required by bulk operations. */
        'filter[tag]': components['parameters']['RequiredTag'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters to update credentials on bulk */
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkCredentialRequest'];
      };
    };
    responses: {
      201: components['responses']['BulkCredentialResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  BulkSimCardNetworkPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': {
          /** @example [
           *       "6b14e151-8493-4fa1-8664-1cc4e6d14158",
           *       "6b14e151-8493-4fa1-8664-1cc4e6d14158"
           *     ] */
          sim_card_ids?: string[];
          mobile_network_operators_preferences?: components['schemas']['MobileNetworkOperatorsPreferencesRequest'];
        };
      };
    };
    responses: {
      202: components['responses']['BulkSIMCardNetworkPreferenceResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  PurchaseESim: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ESimPurchase'];
      };
    };
    responses: {
      202: components['responses']['RegisterSimCardsResponse'];
    };
  };
  RegisterSimCards: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SIMCardRegistration'];
      };
    };
    responses: {
      202: components['responses']['RegisterSimCardsResponse'];
    };
  };
  BulkCredentialAction: {
    parameters: {
      query: {
        /** @description Filter by tag, required by bulk operations. */
        'filter[tag]': components['parameters']['RequiredTag'];
      };
      header?: never;
      path: {
        /** @description Identifies the action to be taken. Activate will change the status to active. Deactivate will change the status to inactive. */
        action: 'activate' | 'deactivate';
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['BulkCredentialResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  FindAddresses: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter addresses via the customer reference set. Matching is not case-sensitive. */
        'filter[customer_reference][eq]'?: components['parameters']['FilterCustomerReferenceEquals'];
        /** @description If present, addresses with <code>customer_reference</code> containing the given value will be returned. Matching is not case-sensitive. */
        'filter[customer_reference][contains]'?: components['parameters']['FilterCustomerReferenceContains'];
        /** @description If set as 'true', only addresses used as the emergency address for at least one active phone-number will be returned. When set to 'false', the opposite happens: only addresses not used as the emergency address from phone-numbers will be returned. */
        'filter[used_as_emergency]'?: components['parameters']['FilterUsedAsEmergency'];
        /** @description If present, addresses with <code>street_address</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[street_address][contains]'?: components['parameters']['FilterStreetAddress'];
        /** @description If present, only returns results with the <code>address_book</code> flag set to the given value. */
        'filter[address_book][eq]'?: components['parameters']['FilterAddressBook'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>street_address</code>: sorts the result by the
         *         <code>street_address</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-street_address</code>: sorts the result by the
         *         <code>street_address</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortAddress'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllAddressResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateAddress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during address creation */
    requestBody: {
      content: {
        'application/json': components['schemas']['AddressCreate'];
      };
    };
    responses: {
      200: components['responses']['AddressResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ValidateAddress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during address validation */
    requestBody: {
      content: {
        'application/json': components['schemas']['ValidateAddressRequest'];
      };
    };
    responses: {
      200: components['responses']['ValidateAddressResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description address ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['AddressResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description address ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['AddressResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  acceptAddressSuggestions: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The UUID of the address that should be accepted. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['AcceptSuggestionsRequest'];
      };
    };
    responses: {
      /** @description This address suggestion has already been accepted. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AddressSuggestionResponse'];
        };
      };
      /** @description This address suggestion was accepted. The numbers associated to it will resume processing in the background. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AddressSuggestionResponse'];
        };
      };
      /** @description Address not found or not accessible by the user. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ResourceNotFoundError'];
        };
      };
    };
  };
  get_assistants_public_assistants_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssistantsListData'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  create_new_assistant_public_assistants_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateAssistantRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Assistant'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_assistant_public_assistants__assistant_id__get: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        assistant_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Assistant'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  update_assistant_public_assistants__assistant_id__post: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        assistant_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAssistantRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  delete_assistant_public_assistants__assistant_id__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        assistant_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssistantDeletedResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  audio_public_audio_transcriptions_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'multipart/form-data': components['schemas']['AudioTranscriptionRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AudioTranscriptionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  chat_public_chat_completions_post: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        /** @example {
         *       "messages": [
         *         {
         *           "role": "system",
         *           "content": "You are a friendly chatbot."
         *         },
         *         {
         *           "role": "user",
         *           "content": "Hello, world!"
         *         }
         *       ]
         *     } */
        'application/json': components['schemas']['ChatCompletionRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetTasksByStatus: {
    parameters: {
      query?: {
        /** @description List of task statuses i.e. `status=queued&status=processing` */
        status?: string[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BackgroundTasksQueryResponseData'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  PostEmbedding: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EmbeddingBucketRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EmbeddingResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetEmbeddingBuckets: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UserEmbeddedBucketsData'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetBucketName: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        bucket_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EmbeddingsBucketFilesData'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  embedding_bucket_files_public_embedding_buckets__bucket_name__delete: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        bucket_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Bucket Embeddings Deleted Successfully */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bucket Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BucketNotFoundError'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  PostEmbeddingSimilaritySearch: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['EmbeddingSimilaritySearchRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['EmbeddingSimilaritySearchResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetEmbeddingTask: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        task_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TaskStatusResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  get_models_public_models_get: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ModelsResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  PostSummary: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SummaryRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SummaryResponseData'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  FindAuthenticationProviders: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>name</code>: sorts the result by the
         *         <code>name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-name</code>: sorts the result by the
         *         <code>name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortAuthenticationProvider'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllAuthenticationProviderResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateAuthenticationProvider: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during authentication provider creation */
    requestBody: {
      content: {
        'application/json': components['schemas']['AuthenticationProviderCreate'];
      };
    };
    responses: {
      200: components['responses']['AuthenticationProviderResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetAuthenticationProvider: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description authentication provider ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['AuthenticationProviderResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteAuthenticationProvider: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description authentication provider ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['AuthenticationProviderResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateAuthenticationProvider: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated in a authentication provider */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateAuthenticationProviderRequest'];
      };
    };
    responses: {
      200: components['responses']['AuthenticationProviderResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListAvailablePhoneNumberBlocks: {
    parameters: {
      query?: {
        /** @description Filter phone numbers by city. */
        'filter[locality]'?: string;
        /** @description Filter phone numbers by country. */
        'filter[country_code]'?: string;
        /** @description Filter by the national destination code of the number. */
        'filter[national_destination_code]'?: string;
        /** @description Filter phone numbers by number type. */
        'filter[phone_number_type]'?:
          | 'local'
          | 'toll_free'
          | 'mobile'
          | 'national'
          | 'shared_cost';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListAvailablePhoneNumbersBlockResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListAvailablePhoneNumbers: {
    parameters: {
      query?: {
        /** @description Filter numbers starting with a pattern (excludes NDC if used with `national_destination_code` filter). */
        'filter[phone_number][starts_with]'?: string;
        /** @description Filter numbers ending with a pattern (excludes NDC if used with `national_destination_code` filter). */
        'filter[phone_number][ends_with]'?: string;
        /** @description Filter numbers containing a pattern (excludes NDC if used with `national_destination_code` filter). */
        'filter[phone_number][contains]'?: string;
        /** @description Filter phone numbers by city. */
        'filter[locality]'?: string;
        /** @description Find numbers in a particular US state or CA province. */
        'filter[administrative_area]'?: string;
        /** @description Filter phone numbers by country. */
        'filter[country_code]'?: string;
        /** @description Filter by the national destination code of the number. */
        'filter[national_destination_code]'?: string;
        /** @description Filter phone numbers by rate center. This filter is only applicable to USA and Canada numbers. */
        'filter[rate_center]'?: string;
        /** @description Filter phone numbers by number type. */
        'filter[phone_number_type]'?:
          | 'local'
          | 'toll_free'
          | 'mobile'
          | 'national'
          | 'shared_cost';
        /** @description Filter phone numbers with specific features. */
        'filter[features]'?: (
          | 'sms'
          | 'mms'
          | 'voice'
          | 'fax'
          | 'emergency'
          | 'hd_voice'
          | 'international_sms'
          | 'local_calling'
        )[];
        /** @description Limits the number of results. */
        'filter[limit]'?: number;
        /** @description Filter to determine if best effort results should be included. Only available in USA/CANADA. */
        'filter[best_effort]'?: boolean;
        /** @description Filter to exclude phone numbers that need additional time after to purchase to activate. Only applicable for +1 toll_free numbers. */
        'filter[quickship]'?: boolean;
        /** @description Filter to ensure only numbers that can be reserved are included in the results. */
        'filter[reservable]'?: boolean;
        /** @description Filter to exclude phone numbers that are currently on hold/reserved for your account. */
        'filter[exclude_held_numbers]'?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListAvailablePhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetUserBalance: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['UserBalanceResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListBillingGroups: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListBillingGroupsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateBillingGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description New billing group object */
    requestBody: {
      content: {
        'application/json': components['schemas']['NewBillingGroup'];
      };
    };
    responses: {
      200: components['responses']['CreateBillingGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetBillingGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the billing group */
        id: components['parameters']['BillingGroupId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RetrieveBillingGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteBillingGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the billing group */
        id: components['parameters']['BillingGroupId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeleteBillingGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateBillingGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the billing group */
        id: components['parameters']['BillingGroupId'];
      };
      cookie?: never;
    };
    /** @description Update billing group object */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBillingGroup'];
      };
    };
    responses: {
      200: components['responses']['UpdateBillingGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetBrands: {
    parameters: {
      query?: {
        page?: number;
        /** @description number of records per page. maximum of 500 */
        recordsPerPage?: number;
        /**
         * @description Specifies the sort order for results. If not given, results are sorted by createdAt in descending order.
         * @example -identityStatus
         */
        sort?:
          | 'assignedCampaignsCount'
          | '-assignedCampaignsCount'
          | 'brandId'
          | '-brandId'
          | 'createdAt'
          | '-createdAt'
          | 'displayName'
          | '-displayName'
          | 'identityStatus'
          | '-identityStatus'
          | 'status'
          | '-status'
          | 'tcrBrandId'
          | '-tcrBrandId';
        displayName?: string;
        entityType?: string;
        state?: string;
        country?: string;
        /** @description Filter results by the Telnyx Brand id */
        brandId?: string;
        /** @description Filter results by the TCR Brand id */
        tcrBrandId?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BrandRecordSetCSP'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  CreateBrandPost: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateBrand'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TelnyxBrand'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetBrandFeedbackById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['BrandFeedback'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetBrand: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TelnyxBrandWithCampaignsCount'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  UpdateBrand: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateBrand'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TelnyxBrand'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  DeleteBrand: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  ResendBrand2faEmail: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListExternalVettings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  PutExternalVettingRecord: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ImportExternalVetting'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExternalVetting'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  PostOrderExternalVetting: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['OrderExternalVetting'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  RevetBrand: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  ListBulkSimCardActions: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by action type. */
        'filter[action_type]'?: 'bulk_set_public_ips';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['BulkSIMCardActionCollectionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetBulkSimCardAction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['BulkSIMCardActionDetailedResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListCallControlApplications: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, applications with <code>application_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[application_name][contains]'?: components['parameters']['FilterApplicationName'];
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound_voice_profile_id]'?: components['parameters']['FilterOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortConnection'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListCallControlApplicationsResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateCallControlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Create call control application request. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCallControlApplicationRequest'];
      };
    };
    responses: {
      201: components['responses']['CallControlApplicationResponse'];
      /** @description Bad Request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RetrieveCallControlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CallControlApplicationResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteCallControlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CallControlApplicationResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateCallControlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Update call control application request. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCallControlApplicationRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlApplicationResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListCallEvents: {
    parameters: {
      query?: {
        /** @description The unique identifier of an individual call leg. */
        'filter[call_leg_id]'?: components['parameters']['FilterCallLegId'];
        /** @description The unique identifier of the call control session. A session may include multiple call leg events. */
        'filter[call_session_id]'?: components['parameters']['FilterCallSessionId'];
        /** @description Event status */
        'filter[status]'?: components['parameters']['FilterCallEventStatus'];
        /** @description Event type */
        'filter[type]'?: components['parameters']['FilterCallEventType'];
        /** @description Event timestamp: greater than */
        'filter[event_timestamp][gt]'?: components['parameters']['FilterCallEventTimestampGreaterThan'];
        /** @description Event timestamp: greater than or equal */
        'filter[event_timestamp][gte]'?: components['parameters']['FilterCallEventTimestampGreaterThanOrEqualTo'];
        /** @description Event timestamp: lower than */
        'filter[event_timestamp][lt]'?: components['parameters']['FilterCallEventTimestampLessThan'];
        /** @description Event timestamp: lower than or equal */
        'filter[event_timestamp][lte]'?: components['parameters']['FilterCallEventTimestampLessThanOrEqualTo'];
        /** @description Event timestamp: equal */
        'filter[event_timestamp][eq]'?: components['parameters']['FilterCallEventTimestampEqualTo'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListCallEventsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DialCall: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['CallRequest'];
      };
    };
    responses: {
      200: components['responses']['RetrieveCallStatusResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveCallStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RetrieveCallStatusResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  AnswerCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Answer call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['AnswerRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  BridgeCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Bridge call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['BridgeRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateClientState: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Updates client state for every subsequent webhook */
    requestBody: {
      content: {
        'application/json': components['schemas']['ClientStateUpdateRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  EnqueueCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Enqueue call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['EnqueueRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StartCallFork: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Fork media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StartForkingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StopCallFork: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Stop forking media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StopForkingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GatherCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Gather */
    requestBody: {
      content: {
        'application/json': components['schemas']['GatherRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StopCallGather: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Stop current gather */
    requestBody: {
      content: {
        'application/json': components['schemas']['StopGatherRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  callGatherUsingAI: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Gather using AI request */
    requestBody: {
      content: {
        'application/json': components['schemas']['GatherUsingAIRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GatherUsingAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Gather using audio request */
    requestBody: {
      content: {
        'application/json': components['schemas']['GatherUsingAudioRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GatherUsingSpeak: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Gather using speak request */
    requestBody: {
      content: {
        'application/json': components['schemas']['GatherUsingSpeakRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  HangupCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Hangup request */
    requestBody: {
      content: {
        'application/json': components['schemas']['HangupRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  LeaveQueue: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Removes the call from the queue, the call currently is enqueued in. */
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveQueueRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StartCallPlayback: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Play audio URL request */
    requestBody: {
      content: {
        'application/json': components['schemas']['PlayAudioUrlRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StopCallPlayback: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Stop audio playback request */
    requestBody: {
      content: {
        'application/json': components['schemas']['PlaybackStopRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PauseCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Pause recording call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['PauseRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ResumeCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Resume recording call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['ResumeRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StartCallRecord: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Start recording audio request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StartRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StopCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Stop recording call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StopRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ReferCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Refer request */
    requestBody: {
      content: {
        'application/json': components['schemas']['ReferRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RejectCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Reject request */
    requestBody: {
      content: {
        'application/json': components['schemas']['RejectRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SendDTMF: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Send DTMF request */
    requestBody: {
      content: {
        'application/json': components['schemas']['SendDTMFRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SendSIPInfo: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Send SIP INFO request */
    requestBody: {
      content: {
        'application/json': components['schemas']['SendSIPInfoRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SpeakCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Speak request */
    requestBody: {
      content: {
        'application/json': components['schemas']['SpeakRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StartCallStreaming: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Start streaming media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StartStreamingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StopCallStreaming: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Stop streaming media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StopStreamingRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  noiseSuppressionStart: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Start streaming media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['NoiseSuppressionStart'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  noiseSuppressionStop: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Start streaming media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['NoiseSuppressionStop'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StartCallTranscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Transcription start request */
    requestBody: {
      content: {
        'application/json': components['schemas']['TranscriptionStartRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  StopCallTranscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Transcription stop request */
    requestBody: {
      content: {
        'application/json': components['schemas']['TranscriptionStopRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  TransferCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    /** @description Transfer call request */
    requestBody: {
      content: {
        'application/json': components['schemas']['TransferCallRequest'];
      };
    };
    responses: {
      200: components['responses']['CallControlCommandResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetCampaigns: {
    parameters: {
      query: {
        brandId: string;
        /** @description The 1-indexed page number to get. The default value is `1`. */
        page?: number;
        /** @description The amount of records per page, limited to between 1 and 500 inclusive. The default value is `10`. */
        recordsPerPage?: number;
        /**
         * @description Specifies the sort order for results. If not given, results are sorted by createdAt in descending order.
         * @example -assignedPhoneNumbersCount
         */
        sort?:
          | 'assignedPhoneNumbersCount'
          | '-assignedPhoneNumbersCount'
          | 'createdAt'
          | '-createdAt'
          | 'status'
          | '-status'
          | 'tcrCampaignId'
          | '-tcrCampaignId';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CampaignRecordSet_CSP'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  AcceptCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description TCR's ID for the campaign to import */
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetCampaignCost: {
    parameters: {
      query: {
        usecase: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CampaignCost'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TelnyxCampaign_CSP'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  UpdateCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCampaignRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['TelnyxCampaign_CSP'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  DeactivateCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CampaignDeletionResponse'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetCampaignMnoMetadata: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the campaign in question */
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response. It constains a map of usecase metadata for each MNO. The key is the network ID of the MNO (e.g. 10017), the value is the mno metadata for the usecase. The metadata may also include some MNO specific fields. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MnoMetadata'];
        };
      };
      /** @description Unexpected Error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  GetCampaignOperationStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetCampaignOsrAttributes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': Record<string, never>;
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetCampaignSharingStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the campaign in question */
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CampaignSharingChain'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  PostCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CampaignRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | Record<string, never>
            | components['schemas']['TelnyxCampaign_CSP'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetUsecaseQualification: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        usecase: string;
        brandId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UsecaseMetadata'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetChannelZones: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetGcbChannelZonesRequestResponse'];
    };
  };
  GetChannelZone: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetGcbChannelZoneRequestResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PatchChannelZone: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
      };
      cookie?: never;
    };
    /** @description Quantity of reserved channels */
    requestBody: {
      content: {
        'application/json': {
          /** Format: int64 */
          channels?: number;
        };
      };
    };
    responses: {
      200: components['responses']['PatchGcbChannelZoneRequestResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPhoneNumbers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetGcbPhoneNumbersRequestResponse'];
    };
  };
  AssignPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
      };
      cookie?: never;
    };
    /** @description Phone number to assign to the channel zone. The phone number should be in E.164 format. */
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: +E.164
           * @example +15554441234
           */
          phone_number: string;
        };
      };
    };
    responses: {
      200: components['responses']['PostGcbPhoneNumberRequestResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UnassignPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Channel zone identifier */
        channel_zone_id: components['parameters']['GcbChannelZoneId'];
        /** @description The phone number to be looked up */
        phone_number: components['parameters']['GcbPhoneNumber'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The phone number is successfully deleted */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListComments: {
    parameters: {
      query: {
        /** @description Record type that the comment relates to i.e number_order, sub_number_order or number_order_phone_number */
        'filter[comment_record_type]': string;
        /** @description ID of the record the comments relate to */
        'filter[comment_record_id]': string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['listCommentsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveComment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The comment ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CommentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  MarkCommentRead: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The comment ID. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ReadCommentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListConferences: {
    parameters: {
      query?: {
        /** @description If present, conferences will be filtered to those with a matching `name` attribute. Matching is case-sensitive */
        'filter[name]'?: components['parameters']['FilterConferenceName'];
        /** @description If present, conferences will be filtered by status. */
        'filter[status]'?: components['parameters']['FilterConferenceStatus'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListConferencesResponse'];
      401: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  CreateConference: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Create a conference */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateConferenceRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceResponse'];
      401: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ListConferenceParticipants: {
    parameters: {
      query?: {
        /** @description If present, participants will be filtered to those who are/are not muted */
        'filter[muted]'?: boolean;
        /** @description If present, participants will be filtered to those who are/are not put on hold */
        'filter[on_hold]'?: boolean;
        /** @description If present, participants will be filtered to those who are whispering or are not */
        'filter[whispering]'?: boolean;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id */
        conference_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListParticipantsResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  RetrieveConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ConferenceResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  HoldConferenceParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferenceHoldRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  JoinConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    /** @description Join Conference request object */
    requestBody: {
      content: {
        'application/json': components['schemas']['JoinConferenceRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  LeaveConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    /** @description Leave Conference request object */
    requestBody: {
      content: {
        'application/json': components['schemas']['LeaveConferenceRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  MuteConferenceParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferenceMuteRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  PlayConferenceAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferencePlayRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  PauseConferenceRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PauseConferenceRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ResumeConferenceRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ResumeConferenceRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  StartConferenceRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the conference to record by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['StartConferenceRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  StopConferenceRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the conference to stop the recording for by id or name */
        id: string;
      };
      cookie?: never;
    };
    /** @description Stop recording conference request */
    requestBody: {
      content: {
        'application/json': components['schemas']['StopRecordingRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  SpeakTextToConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Specifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferenceSpeakRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  StopConferenceAudio: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferenceStopRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  UnholdConferenceParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferenceUnholdRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  UnmuteConferenceParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['ConferenceUnmuteRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  UpdateConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the conference by id or name */
        id: string;
      };
      cookie?: never;
    };
    /** @description Update Conference request object */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateConferenceRequest'];
      };
    };
    responses: {
      200: components['responses']['ConferenceCommandResponse'];
      401: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ListConnections: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, connections with <code>connection_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[connection_name][contains]'?: components['parameters']['FilterConnectionName'];
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound_voice_profile_id]'?: components['parameters']['FilterOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortConnection'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListConnectionsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
    };
  };
  ListConnectionActiveCalls: {
    parameters: {
      query?: {
        /** @description Limit of records per single page */
        'page[limit]'?: components['parameters']['PageLimit'];
        /** @description Opaque identifier of next page */
        'page[after]'?: components['parameters']['PageAfter'];
        /** @description Opaque identifier of previous page */
        'page[before]'?: components['parameters']['PageBefore'];
      };
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ActiveCallsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description IP Connection ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ConnectionResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  retreiveCountryCoverage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CountryCoverageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  retreiveSpecificCountryCoverage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Country ISO code. */
        country_code: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SpecificCountryResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListCredentialConnections: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, connections with <code>connection_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[connection_name][contains]'?: components['parameters']['FilterConnectionName'];
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound.outbound_voice_profile_id]'?: components['parameters']['FilterInnerOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortConnection'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListCredentialConnectionsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
    };
  };
  CreateCredentialConnection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during credential connection creation */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateCredentialConnectionRequest'];
      };
    };
    responses: {
      201: components['responses']['CredentialConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  RetrieveCredentialConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CredentialConnectionResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteCredentialConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CredentialConnectionResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateCredentialConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated in a credential connection */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCredentialConnectionRequest'];
      };
    };
    responses: {
      200: components['responses']['CredentialConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  CheckRegistrationStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RegistrationStatusResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetCustomStorageCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CredentialsResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateCustomStorageCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreateCredentialsRequest'];
    responses: {
      200: components['responses']['CredentialsResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateCustomStorageCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreateCredentialsRequest'];
    responses: {
      200: components['responses']['CredentialsResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteCustomStorageCredentials: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The credentials configuration for connection_id was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListCustomerServiceRecords: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        'sort[]'?: 'created_at' | '-created_at';
        /** @description Filters records to those with a specified number. */
        'filter[phone_number][eq]'?: components['parameters']['PhoneNumberEqFilter'];
        /** @description Filters records to those with at least one number in the list. */
        'filter[phone_number][in][]'?: components['parameters']['PhoneNumberInFilter'];
        /** @description Filters records to those with a specific status. */
        'filter[status][eq]'?: components['parameters']['StatusEqFilter'];
        /** @description Filters records to those with a least one status in the list. */
        'filter[status][in][]'?: components['parameters']['StatusInFilter'];
        /** @description Filters records to those created after a specific date. */
        'filter[created_at][lt]'?: components['parameters']['CreatedAtGtFilter'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListCustomerServiceRecords'];
      401: components['responses']['UnauthorizedErrorResponse'];
      403: components['responses']['ForbiddenErrorResponse'];
      422: components['responses']['UnprocessableEntityErrorResponse'];
      500: components['responses']['UnexpectedErrorResponse'];
    };
  };
  CreateCustomerServiceRecord: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreateCustomerServiceRecord'];
    responses: {
      201: components['responses']['CreateCustomerServiceRecord'];
      401: components['responses']['UnauthorizedErrorResponse'];
      403: components['responses']['ForbiddenErrorResponse'];
      422: components['responses']['UnprocessableEntityErrorResponse'];
      500: components['responses']['UnexpectedErrorResponse'];
    };
  };
  VerifyPhoneNumberCoverage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['VerifyCustomerServiceRecordPhoneNumberCoverage'];
    responses: {
      201: components['responses']['ListCustomerServiceRecordPhoneNumberCoverage'];
      401: components['responses']['UnauthorizedErrorResponse'];
      403: components['responses']['ForbiddenErrorResponse'];
      422: components['responses']['UnprocessableEntityErrorResponse'];
      500: components['responses']['UnexpectedErrorResponse'];
    };
  };
  GetCustomerServiceRecord: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the customer service record */
        customer_service_record_id: components['parameters']['PathCustomerServiceRecordId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      201: components['responses']['ShowCustomerServiceRecord'];
      401: components['responses']['UnauthorizedErrorResponse'];
      403: components['responses']['ForbiddenErrorResponse'];
      404: components['responses']['ResourceNotFoundErrorResponse'];
      500: components['responses']['UnexpectedErrorResponse'];
    };
  };
  SearchDetailRecords: {
    parameters: {
      query: {
        /** @description Filter by the given record type. */
        'filter[record_type]':
          | 'amd'
          | 'conference'
          | 'conference-participant'
          | 'media_storage'
          | 'messaging'
          | 'verify'
          | 'whatsapp'
          | 'whatsapp-conversation'
          | 'wireless';
        /** @description Filter by the given user-friendly date range. You can specify one of the following enum values, or a dynamic one using this format: last_N_days. */
        'filter[date_range]'?:
          | 'yesterday'
          | 'today'
          | 'tomorrow'
          | 'last_week'
          | 'this_week'
          | 'next_week'
          | 'last_month'
          | 'this_month'
          | 'next_month';
        /** @description Filter records on a given record attribute and value. <br/>Example: filter[status]=delivered */
        filter?: {
          [key: string]: unknown;
        };
        /** @description Page number */
        'page[number]'?: number;
        /** @description Page size */
        'page[size]'?: number;
        /** @description Specifies the sort order for results. <br/>Example: sort=-created_at */
        sort?: string[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['DetailRecordsSearchResponse'];
        };
      };
    };
  };
  GetDialogflowConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DialogflowConnectionResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateDialogflowConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['DialogflowConnectionRequest'];
    responses: {
      200: components['responses']['DialogflowConnectionResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateDialogflowConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['DialogflowConnectionRequest'];
    responses: {
      201: components['responses']['DialogflowConnectionResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteDialogflowConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a Telnyx application (Call Control, TeXML) or Sip connection resource. */
        connection_id: components['parameters']['ConnectionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The Dialogflow Connection for connection_id was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListDocumentLinks: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Identifies the associated document to filter on. */
        'filter[document_id]'?: components['parameters']['DocServiceDocumentIdFilter'];
        /** @description The `linked_record_type` of the document to filter on. */
        'filter[linked_record_type]'?: components['parameters']['LinkedRecordTypeFilter'];
        /** @description The `linked_resource_id` of the document to filter on. */
        'filter[linked_resource_id]'?: components['parameters']['LinkedResourceIdFilter'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListDocServiceDocumentLinksResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListDocuments: {
    parameters: {
      query?: {
        /** @description Filter by string matching part of filename. */
        'filter[filename][contains]'?: components['parameters']['DocumentsFilenameContainsFilter'];
        /** @description Filter documents by a customer references. */
        'filter[customer_reference][eq]'?: components['parameters']['DocumentsCustomerReferenceEqFilter'];
        /** @description Filter documents by a list of customer references. */
        'filter[customer_reference][in][]'?: components['parameters']['DocumentsCustomerReferenceInFilter'];
        /** @description Filter by created at greater than provided value. */
        'filter[created_at][gt]'?: components['parameters']['DocumentsCreatedAtGreaterThanFilter'];
        /** @description Filter by created at less than provided value. */
        'filter[created_at][lt]'?: components['parameters']['DocumentsCreatedAtLessThanFilter'];
        /** @description Specifies the sort order for results. If you want to sort by a field in ascending order, include it as a sort parameter. If you want to sort in descending order, prepend a `-` in front of the field name. */
        'sort[]'?: components['parameters']['DocumentsSort'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListDocServiceDocumentsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateDocServiceDocumentRequest'];
        'multipart/form-data': components['schemas']['CreateMultiPartDocServiceDocumentRequest'];
      };
    };
    responses: {
      200: components['responses']['DocServiceDocumentResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DocServiceDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DocServiceDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DocServiceDocument'];
      };
    };
    responses: {
      200: components['responses']['DocServiceDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DownloadDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DownloadDocServiceDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListDynamicEmergencyAddresses: {
    parameters: {
      query?: {
        /** @description Filter by status. */
        'filter[status]'?: 'pending' | 'activated' | 'rejected';
        /** @description Filter by country code. */
        'filter[country_code]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['listDynamicEmergencyAddresses'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateDynamicEmergencyAddress: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DynamicEmergencyAddress'];
      };
    };
    responses: {
      201: components['responses']['DynamicEmergencyAddressResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetDynamicEmergencyAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Dynamic Emergency Address id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DynamicEmergencyAddressResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteDynamicEmergencyAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Dynamic Emergency Address id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DynamicEmergencyAddressResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListDynamicEmergencyEndpoints: {
    parameters: {
      query?: {
        /** @description Filter by status. */
        'filter[status]'?: 'pending' | 'activated' | 'rejected';
        /** @description Filter by country code. */
        'filter[country_code]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['listDynamicEmergencyEndpoints'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateDynamicEmergencyEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DynamicEmergencyEndpoint'];
      };
    };
    responses: {
      201: components['responses']['DynamicEmergencyEndpointResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetDynamicEmergencyEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Dynamic Emergency Endpoint id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DynamicEmergencyEndpointResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteDynamicEmergencyEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Dynamic Emergency Endpoint id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DynamicEmergencyEndpointResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetEnumEndpoint: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        endpoint:
          | 'mno'
          | 'optionalAttributes'
          | 'usecase'
          | 'vertical'
          | 'altBusinessIdType'
          | 'brandIdentityStatus'
          | 'brandRelationship'
          | 'campaignStatus'
          | 'entityType'
          | 'extVettingProvider'
          | 'vettingStatus'
          | 'brandStatus'
          | 'operationStatus'
          | 'approvedPublicCompany'
          | 'stockExchange'
          | 'vettingClass';
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['EnumListResponse']
            | components['schemas']['EnumObjectResponse']
            | components['schemas']['EnumPaginatedResponse'];
        };
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  ListExternalConnections: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, connections with <code>connection_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[connection_name][contains]'?: components['parameters']['FilterConnectionName'];
        /** @description If present, connections with <code>external_sip_connection</code> matching the given value will be returned. */
        'filter[external_sip_connection]'?: components['parameters']['FilterExternalSipConnection'];
        /** @description If present, connections with <code>id</code> matching the given value will be returned. */
        'filter[id]'?: components['parameters']['FilterId'];
        /** @description Filter by ISO 8601 formatted date-time string matching resource creation date-time. */
        'filter[created_at]'?: components['parameters']['FilterCreatedAt'];
        /** @description If present, connections associated with the given phone_number will be returned. A full match is necessary with a e164 format. */
        'filter[phone_number][contains]'?: components['parameters']['FilterPhoneNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllExternalConnectionResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateExternalConnection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be set when creating a External Connection */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateExternalConnectionRequest'];
      };
    };
    responses: {
      201: components['responses']['ExternalConnectionResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListExternalConnectionLogMessages: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The external connection ID to filter by or "null" to filter for logs without an external connection ID */
        'filter[external_connection_id]'?: components['parameters']['FilterExternalConnectionId'];
        /** @description The partial phone number to filter log messages for. Requires 3-15 digits. */
        'filter[telephone_number][contains]'?: components['parameters']['FilterPhoneNumberLogMessageContains'];
        /** @description The phone number to filter log messages for or "null" to filter for logs without a phone number */
        'filter[telephone_number][eq]'?: components['parameters']['FilterPhoneNumberLogMessageEq'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListLogMessagesResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnectionLogMessage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetLogMessageResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteExternalConnectionLogMessage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Describes wether or not the operation was successful */
            success?: boolean;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ExternalConnectionResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteExternalConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ExternalConnectionResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateExternalConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    /** @description Parameters to be updated for the External Connection */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateExternalConnectionRequest'];
      };
    };
    responses: {
      200: components['responses']['ExternalConnectionResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListCivicAddresses: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllCivicAddressesResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unexpected Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Gateway */
      502: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnectionCivicAddress: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
        /** @description Identifies a civic address or a location. */
        address_id: components['parameters']['address_id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetCivicAddressResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unexpected Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad Gateway */
      502: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListExternalConnectionPhoneNumbers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The phone number to filter by */
        'filter[phone_number][eq]'?: components['parameters']['FilterPhoneNumberEq'];
        /** @description If present, connections associated with the given phone_number will be returned. A full match is necessary with a e164 format. */
        'filter[phone_number][contains]'?: components['parameters']['FilterPhoneNumber'];
        /** @description The civic address ID to filter by */
        'filter[civic_address_id][eq]'?: components['parameters']['FilterCivicAddressId'];
        /** @description The location ID to filter by */
        'filter[location_id][eq]'?: components['parameters']['FilterLocationId'];
      };
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListExternalConnectionPhoneNumbersResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnectionPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
        /** @description A phone number's ID via the Telnyx API */
        phone_number_id: components['parameters']['phone_number_id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetExternalConnectionPhoneNumberResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateExternalConnectionPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
        /** @description A phone number's ID via the Telnyx API */
        phone_number_id: components['parameters']['phone_number_id'];
      };
      cookie?: never;
    };
    /** @description Values that can be set when updating a phone number */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateExternalConnectionPhoneNumberRequest'];
      };
    };
    responses: {
      200: components['responses']['GetExternalConnectionPhoneNumberResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListExternalConnectionReleases: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The status of the release to filter by */
        'filter[status][eq]'?: components['parameters']['FilterReleaseStatus'];
        /** @description The civic address ID to filter by */
        'filter[civic_address_id][eq]'?: components['parameters']['FilterCivicAddressId'];
        /** @description The location ID to filter by */
        'filter[location_id][eq]'?: components['parameters']['FilterLocationId'];
        /** @description The phone number to filter by */
        'filter[phone_number][eq]'?: components['parameters']['FilterPhoneNumberEq'];
        /** @description The partial phone number to filter by. Requires 3-15 digits. */
        'filter[phone_number][contains]'?: components['parameters']['FilterPhoneNumberContains'];
      };
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListReleasesResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnectionRelease: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
        /** @description Identifies a Release request */
        release_id: components['parameters']['release_id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetReleaseResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListExternalConnectionUploads: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The status of the upload to filter by */
        'filter[status][eq]'?: components['parameters']['FilterUploadStatus'];
        /** @description The civic address ID to filter by */
        'filter[civic_address_id][eq]'?: components['parameters']['FilterCivicAddressId'];
        /** @description The location ID to filter by */
        'filter[location_id][eq]'?: components['parameters']['FilterLocationId'];
        /** @description The phone number to filter by */
        'filter[phone_number][eq]'?: components['parameters']['FilterPhoneNumberEq'];
        /** @description The partial phone number to filter by. Requires 3-15 digits. */
        'filter[phone_number][contains]'?: components['parameters']['FilterPhoneNumberContains'];
      };
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListUploadsResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateExternalConnectionUpload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    /** @description Parameters that can be set when creating an Upload request. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateExternalConnectionUploadRequest'];
      };
    };
    responses: {
      /** @description Successful response */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Describes wether or not the operation was successful */
            success?: boolean;
            /**
             * Format: uuid
             * @description Ticket id of the upload request
             */
            ticket_id?: string;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Payload too large. The maximum allowed phone numbers for the numbers_ids array is 1000. */
      413: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Gateway Timeout */
      504: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RefreshExternalConnectionUploads: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            /** @description Describes wether or not the operation was successful */
            success?: boolean;
          };
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Status refresh is still in progress, please wait before calling again */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnectionUploadsStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetUploadsStatusResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetExternalConnectionUpload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
        /** @description Identifies an Upload request */
        ticket_id: components['parameters']['ticket_id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetUploadResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  RetryUpload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
        /** @description Identifies an Upload request */
        ticket_id: components['parameters']['ticket_id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['GetUploadResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Order is still in progress, please wait before retrying */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListFaxApplications: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, applications with <code>application_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[application_name][contains]'?: components['parameters']['FilterApplicationName'];
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound_voice_profile_id]'?: components['parameters']['FilterOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>friendly_name</code>: sorts the result by the
         *         <code>friendly_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-friendly_name</code>: sorts the result by the
         *         <code>friendly_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortApplication'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllFaxApplicationsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
    };
  };
  CreateFaxApplication: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be set when creating a Fax Application */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateFaxApplicationRequest'];
      };
    };
    responses: {
      201: components['responses']['FaxApplicationResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  GetFaxApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['FaxApplicationResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteFaxApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['FaxApplicationResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateFaxApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    /** @description Parameters to be updated for the Fax Application */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateFaxApplicationRequest'];
      };
    };
    responses: {
      200: components['responses']['FaxApplicationResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ListFaxes: {
    parameters: {
      query?: {
        /** @description ISO 8601 date time for filtering faxes created after or on that date */
        'filter[created_at][gte]'?: string;
        /** @description ISO 8601 date time for filtering faxes created after that date */
        'filter[created_at][gt]'?: string;
        /** @description ISO 8601 formatted date time for filtering faxes created on or before that date */
        'filter[created_at][lte]'?: string;
        /** @description ISO 8601 formatted date time for filtering faxes created before that date */
        'filter[created_at][lt]'?: string;
        /** @description The direction, inbound or outbound, for filtering faxes sent from this account */
        'filter[direction][eq]'?: string;
        /** @description The phone number, in E.164 format for filtering faxes sent from this number */
        'filter[from][eq]'?: string;
        /** @description The phone number, in E.164 format for filtering faxes sent to this number */
        'filter[to][eq]'?: string;
        /** @description Number of fax resourcxes for the single page returned */
        'page[size]'?: number;
        /** @description Number of the page to be retrieved */
        'page[number]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListFaxesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SendFax: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Send fax request */
    requestBody: {
      content: {
        'application/json': components['schemas']['SendFaxRequest'];
        'multipart/form-data': components['schemas']['SendFaxMultipartRequest'];
      };
    };
    responses: {
      202: components['responses']['SendFaxResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ViewFax: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a fax. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetFaxResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteFax: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a fax. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CancelFax: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a fax. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['CancelFaxResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RefreshFax: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a fax. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RefreshFaxResponse'];
      404: components['responses']['NotFoundResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListFqdnConnections: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, connections with <code>connection_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[connection_name][contains]'?: components['parameters']['FilterConnectionName'];
        /** @description If present, connections with an `fqdn` that equals the given value will be returned. Matching is case-sensitive, and the full string must match. */
        'filter[fqdn]'?: components['parameters']['FilterFqdn'];
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound_voice_profile_id]'?: components['parameters']['FilterOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortConnection'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListFqdnConnectionsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  CreateFqdnConnection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during FQDN connection creation */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateFqdnConnectionRequest'];
      };
    };
    responses: {
      201: components['responses']['FqdnConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  RetrieveFqdnConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['FqdnConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  DeleteFqdnConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['FqdnConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  UpdateFqdnConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated in a FQDN connection */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateFqdnConnectionRequest'];
      };
    };
    responses: {
      200: components['responses']['FqdnConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ListFqdns: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description ID of the FQDN connection to which the FQDN belongs. */
        'filter[connection_id]'?: string;
        /** @description FQDN represented by the resource. */
        'filter[fqdn]'?: string;
        /** @description Port to use when connecting to the FQDN. */
        'filter[port]'?: number;
        /** @description DNS record type used by the FQDN. */
        'filter[dns_record_type]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListFqdnsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
    };
  };
  CreateFqdn: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateFqdnRequest'];
      };
    };
    responses: {
      201: components['responses']['FqdnResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  RetrieveFqdn: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['FqdnId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['FqdnResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteFqdn: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['FqdnId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['FqdnResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateFqdn: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['FqdnId'];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateFqdnRequest'];
      };
    };
    responses: {
      200: components['responses']['FqdnResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ListGlobalIpAllowedPorts: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpAllowedPortListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIpAssignmentHealth: {
    parameters: {
      query?: {
        /** @description Filter by Global IP ID(s) separated by commas */
        'filter[global_ip_id][in]'?: string;
        /** @description Filter by Global IP Assignment ID(s) separated by commas */
        'filter[global_ip_assignment_id][in]'?: string;
        /** @description Filter by timestamp greater than */
        'filter[timestamp][gt]'?: components['parameters']['TimestampGreater'];
        /** @description Filter by timestamp less than */
        'filter[timestamp][lt]'?: components['parameters']['TimestampLess'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpHealthResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListGlobalIpAssignments: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpAssignmentListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateGlobalIpAssignment: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GlobalIpAssignment'];
      };
    };
    responses: {
      202: components['responses']['GlobalIpAssignmentResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIpAssignment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpAssignmentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteGlobalIpAssignment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpAssignmentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateGlobalIpAssignment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GlobalIpAssignmentUpdate'];
      };
    };
    responses: {
      200: components['responses']['GlobalIpAssignmentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIpAssignmentUsage: {
    parameters: {
      query?: {
        /** @description Filter by Global IP Assignment ID(s) separated by commas */
        'filter[global_ip_assignment_id][in]'?: string;
        /** @description Filter by Global IP ID(s), separated by commas */
        'filter[global_ip_id][in]'?: string;
        /** @description Filter by timestamp greater than */
        'filter[timestamp][gt]'?: components['parameters']['TimestampGreater'];
        /** @description Filter by timestamp less than */
        'filter[timestamp][lt]'?: components['parameters']['TimestampLess'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpAssignmentUsageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListGlobalIpHealthCheckTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpHealthCheckTypesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListGlobalIpHealthChecks: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpHealthCheckListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateGlobalIpHealthCheck: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GlobalIPHealthCheck'];
      };
    };
    responses: {
      202: components['responses']['GlobalIpHealthCheckResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIpHealthCheck: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpHealthCheckResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteGlobalIpHealthCheck: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpHealthCheckResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIpLatency: {
    parameters: {
      query?: {
        /** @description Filter by Global IP ID(s) separated by commas */
        'filter[global_ip_id][in]'?: string;
        /** @description Filter by timestamp greater than */
        'filter[timestamp][gt]'?: components['parameters']['TimestampGreater'];
        /** @description Filter by timestamp less than */
        'filter[timestamp][lt]'?: components['parameters']['TimestampLess'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpLatencyResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListGlobalIpProtocols: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpProtocolListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIpUsage: {
    parameters: {
      query?: {
        /** @description Filter by Global IP ID(s) separated by commas */
        'filter[global_ip_id][in]'?: string;
        /** @description Filter by timestamp greater than */
        'filter[timestamp][gt]'?: components['parameters']['TimestampGreater'];
        /** @description Filter by timestamp less than */
        'filter[timestamp][lt]'?: components['parameters']['TimestampLess'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpUsageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListGlobalIps: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateGlobalIp: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['GlobalIP'];
      };
    };
    responses: {
      202: components['responses']['GlobalIpResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetGlobalIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteGlobalIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GlobalIpResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateInventoryCoverage: {
    parameters: {
      query: {
        /** @example 318 */
        'filter[npa]'?: number;
        /** @example 202 */
        'filter[nxx]'?: number;
        /** @example LA */
        'filter[administrative_area]'?: string;
        /** @example local */
        'filter[phone_number_type]'?:
          | 'local'
          | 'toll_free'
          | 'national'
          | 'mobile'
          | 'landline'
          | 'shared_cost';
        /** @example US */
        'filter[country_code]'?:
          | 'AT'
          | 'AU'
          | 'BE'
          | 'BG'
          | 'CA'
          | 'CH'
          | 'CN'
          | 'CY'
          | 'CZ'
          | 'DE'
          | 'DK'
          | 'EE'
          | 'ES'
          | 'FI'
          | 'FR'
          | 'GB'
          | 'GR'
          | 'HU'
          | 'HR'
          | 'IE'
          | 'IT'
          | 'LT'
          | 'LU'
          | 'LV'
          | 'NL'
          | 'NZ'
          | 'MX'
          | 'NO'
          | 'PL'
          | 'PT'
          | 'RO'
          | 'SE'
          | 'SG'
          | 'SI'
          | 'SK'
          | 'US';
        /** @example true */
        'filter[count]'?: boolean;
        /** @description Filter if the phone number should be used for voice, fax, mms, sms, emergency. Returns features in the response when used. */
        'filter[features]'?: ('sms' | 'mms' | 'voice' | 'fax' | 'emergency')[];
        /** @example nxx */
        'filter[groupBy]': 'locality' | 'npa' | 'national_destination_code';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['InventoryCoverageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListIpConnections: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, connections with <code>connection_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[connection_name][contains]'?: components['parameters']['FilterConnectionName'];
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound.outbound_voice_profile_id]'?: components['parameters']['FilterInnerOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-connection_name</code>: sorts the result by the
         *         <code>connection_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortConnection'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListIpConnectionsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
    };
  };
  CreateIpConnection: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during IP connection creation */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateIpConnectionRequest'];
      };
    };
    responses: {
      201: components['responses']['IpConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  RetrieveIpConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description IP Connection ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['IpConnectionResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteIpConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['IpConnectionResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateIpConnection: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated in a IP connection */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateIpConnectionRequest'];
      };
    };
    responses: {
      200: components['responses']['IpConnectionResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  ListIps: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description ID of the IP Connection to which this IP should be attached. */
        'filter[connection_id]'?: string;
        /** @description IP adddress represented by this resource. */
        'filter[ip_address]'?: string;
        /** @description Port to use when connecting to this IP. */
        'filter[port]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListIpsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
    };
  };
  CreateIp: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateIpRequest'];
      };
    };
    responses: {
      201: components['responses']['IpResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  RetrieveIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: components['parameters']['IpId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['IpResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: components['parameters']['IpId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['IpResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: components['parameters']['IpId'];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['UpdateIpRequest'];
      };
    };
    responses: {
      200: components['responses']['IpResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  CreateBillingGroupReport: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description New ledger billing group report parameters */
    requestBody: {
      content: {
        'application/json': components['schemas']['NewLedgerBillingGroupReport'];
      };
    };
    responses: {
      200: components['responses']['CreateLedgerBillingGroupReportResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetBillingGroupReport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the ledger billing group report */
        id: components['parameters']['LedgerBillingGroupReportId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RetrieveLedgerBillingGroupReportResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListManagedAccounts: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, email containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[email][contains]'?: components['parameters']['FilterEmailContains'];
        /** @description If present, only returns results with the <code>email</code> matching exactly the value given. */
        'filter[email][eq]'?: components['parameters']['FilterEmailEq'];
        /** @description If present, only returns results with the <code>organization_name</code> containing the given value. Matching is not case-sensitive. Requires at least three characters. */
        'filter[organization_name][contains]'?: components['parameters']['FilterOrganizationEmailContains'];
        /** @description If present, only returns results with the <code>organization_name</code> matching exactly the value given. */
        'filter[organization_name][eq]'?: components['parameters']['FilterOrganizationEmailEq'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>email</code>: sorts the result by the
         *         <code>email</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-email</code>: sorts the result by the
         *         <code>email</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['Sort'];
        /** @description Specifies if cancelled accounts should be included in the results. */
        include_cancelled_accounts?: components['parameters']['IncludeCancelledAccounts'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListManagedAccountsResponse'];
      401: components['responses']['UnauthorizedResponse'];
    };
  };
  CreateManagedAccount: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that define the managed account to be created */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateManagedAccountRequest'];
      };
    };
    responses: {
      200: components['responses']['ManagedAccountResponse'];
      401: components['responses']['UnauthorizedResponse'];
      422: components['responses']['UnprocessableManagedAccountEntity'];
    };
  };
  ListAllocatableGlobalOutboundChannels: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListManagedAccountsAllocatableGlobalOutboundChannelsResponse'];
      401: components['responses']['UnauthorizedResponse'];
      403: components['responses']['ForbiddenResponse'];
    };
  };
  RetrieveManagedAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Managed Account User ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ManagedAccountResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateManagedAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Managed Account User ID */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that define the updates to the managed account */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateManagedAccountRequest'];
      };
    };
    responses: {
      200: components['responses']['ManagedAccountResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      422: components['responses']['UnprocessableManagedAccountEntity'];
    };
  };
  DisableManagedAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Managed Account User ID */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ManagedAccountResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      422: components['responses']['UnprocessableManagedAccountEntity'];
    };
  };
  EnableManagedAccount: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Managed Account User ID */
        id: string;
      };
      cookie?: never;
    };
    /** @description Additional parameters for what to do when enabling the managed account */
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description When true, all connections owned by this managed account will automatically be re-enabled. Note: Any connections that do not pass validations will not be re-enabled.
           * @default false
           * @example true
           */
          reenable_all_connections?: boolean;
        };
      };
    };
    responses: {
      200: components['responses']['ManagedAccountResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      422: components['responses']['UnprocessableManagedAccountEntity'];
    };
  };
  UpdateManagedAccountGlobalChannelLimit: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Managed Account User ID */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that define the changes to the global outbounds channels for the managed account */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateManagedAccountGlobalChannelLimitRequest'];
      };
    };
    responses: {
      200: components['responses']['UpdateManagedAccountGlobalChannelLimitResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      422: components['responses']['UnprocessableManagedAccountEntity'];
    };
  };
  ListMediaStorage: {
    parameters: {
      query?: {
        /** @description Filters files by given content types */
        'filter[content_type][]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMediaResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateMediaStorage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Upload media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['UploadMediaRequest'];
        'multipart/form-data': components['schemas']['UploadMediaMultipartRequest'];
      };
    };
    responses: {
      201: components['responses']['MediaResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetMediaStorage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a media resource. */
        media_name: components['parameters']['MediaName'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MediaResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateMediaStorage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a media resource. */
        media_name: components['parameters']['MediaName'];
      };
      cookie?: never;
    };
    /** @description Update media request */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateMediaRequest'];
        'multipart/form-data': components['schemas']['UpdateMediaMultipartRequest'];
      };
    };
    responses: {
      200: components['responses']['MediaResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteMediaStorage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a media resource. */
        media_name: components['parameters']['MediaName'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The media was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DownloadMedia: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies a media resource. */
        media_name: components['parameters']['MediaName'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MediaDownloadResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SendMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateMessageRequest'];
      };
    };
    responses: {
      200: components['responses']['MessageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateGroupMmsMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateGroupMMSMessageRequest'];
      };
    };
    responses: {
      200: components['responses']['MessageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateLongCodeMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateLongCodeMessageRequest'];
      };
    };
    responses: {
      200: components['responses']['MessageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNumberPoolMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateNumberPoolMessageRequest'];
      };
    };
    responses: {
      200: components['responses']['MessageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateShortCodeMessage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateShortCodeMessageRequest'];
      };
    };
    responses: {
      200: components['responses']['MessageResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetMessage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the message */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response with details of a message. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?:
              | components['schemas']['OutboundMessagePayload']
              | components['schemas']['InboundMessagePayload'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListMessagingHostedNumberOrders: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMessagingHostedNumberOrdersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateMessagingHostedNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'application/json': components['schemas']['CreateMessagingHostedNumberOrderRequest'];
      };
    };
    responses: {
      200: components['responses']['MessagingHostedNumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetMessagingHostedNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MessagingHostedNumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UploadMessagingHostedNumberOrderFile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Message payload */
    requestBody?: {
      content: {
        'multipart/form-data': components['schemas']['UploadFileMessagingHostedNumberOrderRequest'];
      };
    };
    responses: {
      200: components['responses']['MessagingHostedNumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteMessagingHostedNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MessagingHostedNumberResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  BulkUpdateMessagingSettingsOnPhoneNumbers: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['BulkMessagingSettingsUpdatePhoneNumbersRequest'];
      };
    };
    responses: {
      200: components['responses']['BulkMessagingSettingsUpdatePhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetBulkUpdateMessagingSettingsOnPhoneNumbersStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Order ID to verify bulk update status. */
        order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['BulkMessagingSettingsUpdatePhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListProfileMetrics: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The id of the messaging profile(s) to retrieve */
        id?: components['parameters']['MessagingProfileMetric'];
        /** @description The timeframe for which you'd like to retrieve metrics. */
        time_frame?: components['parameters']['MessagingProfileMetricTimeFrame'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMessagingProfileMetrics'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListMessagingProfiles: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by name */
        'filter[name]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMessagingProfilesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateMessagingProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description New Messaging Profile object */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateMessagingProfileRequest'];
      };
    };
    responses: {
      200: components['responses']['MessagingProfileResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveMessagingProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the messaging profile to retrieve */
        id: components['parameters']['MessagingProfileId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MessagingProfileResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteMessagingProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the messaging profile to retrieve */
        id: components['parameters']['MessagingProfileId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MessagingProfileResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateMessagingProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the messaging profile to retrieve */
        id: components['parameters']['MessagingProfileId'];
      };
      cookie?: never;
    };
    /** @description New Messaging Profile object */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateMessagingProfileRequest'];
      };
    };
    responses: {
      200: components['responses']['MessagingProfileResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetMessagingProfileMetrics: {
    parameters: {
      query?: {
        /** @description The timeframe for which you'd like to retrieve metrics. */
        time_frame?: components['parameters']['MessagingProfileMetricTimeFrame'];
      };
      header?: never;
      path: {
        /** @description The id of the messaging profile to retrieve */
        id: components['parameters']['MessagingProfileId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RetrieveMessagingProfileMetrics'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListProfilePhoneNumbers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description The id of the messaging profile to retrieve */
        id: components['parameters']['MessagingProfileId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMessagingProfilePhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListProfileShortCodes: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description The id of the messaging profile to retrieve */
        id: components['parameters']['MessagingProfileId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMessagingProfileShortCodesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetAutorespConfigs: {
    parameters: {
      query?: {
        country_code?: string;
        'created_at[gte]'?: string;
        'created_at[lte]'?: string;
        'updated_at[gte]'?: string;
        'updated_at[lte]'?: string;
      };
      header?: never;
      path: {
        profile_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AutorespConfigsResponseSchema'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateAutorespConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        profile_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AutoRespConfigCreateSchema'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AutorespConfigResponseSchema'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetAutorespConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        profile_id: string;
        autoresp_cfg_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AutorespConfigResponseSchema'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateAutoRespConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        profile_id: string;
        autoresp_cfg_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AutoRespConfigCreateSchema'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AutorespConfigResponseSchema'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteAutorespConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        profile_id: string;
        autoresp_cfg_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListVerificationRequests: {
    parameters: {
      query: {
        page: number;
        /** @description
         *             Request this many records per page
         *
         *             This value is automatically clamped if the provided value is too large.
         *              */
        page_size: number;
        date_start?: string;
        date_end?: string;
        status?: components['schemas']['TFVerificationStatus'];
        phone_number?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Paginated_VerificationRequestStatus_'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SubmitVerificationRequest: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TFVerificationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerificationRequestEgress'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetVerificationRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerificationRequestStatus'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteVerificationRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': unknown;
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateVerificationRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['TFVerificationRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerificationRequestEgress'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListMessagingUrlDomains: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMessagingUrlDomains'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetMobileNetworkOperators: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by name starting with. */
        'filter[name][starts_with]'?: string;
        /** @description Filter by name containing match. */
        'filter[name][contains]'?: string;
        /** @description Filter by name ending with. */
        'filter[name][ends_with]'?: string;
        /** @description Filter by exact country_code. */
        'filter[country_code]'?: string;
        /** @description Filter by exact MCC. */
        'filter[mcc]'?: string;
        /** @description Filter by exact MNC. */
        'filter[mnc]'?: string;
        /** @description Filter by exact TADIG. */
        'filter[tadig]'?: string;
        /** @description Filter by network_preferences_enabled. */
        'filter[network_preferences_enabled]'?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SearchMobileNetworkOperatorsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListPushCredentials: {
    parameters: {
      query?: {
        /** @description type of mobile push credentials */
        'filter[type]'?: 'ios' | 'android';
        /** @description Unique mobile push credential alias */
        'filter[alias]'?: string;
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Mobile mobile push credentials */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['responses']['ListPushCredentialsResponse'];
        };
      };
      /** @description Unauthorized request */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  CreatePushCredential: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Mobile push credential parameters that need to be sent in the request */
    requestBody: {
      content: {
        'application/json':
          | components['schemas']['CreateIosPushCredentialRequest']
          | components['schemas']['CreateAndroidPushCredentialRequest'];
      };
    };
    responses: {
      /** @description Mobile push credential created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['responses']['PushCredentialResponse'];
        };
      };
      /** @description Unauthorized request */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      /** @description Unable to process request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  GetPushCredentialById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a mobile push credential */
        push_credential_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful get mobile push credential response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['responses']['PushCredentialResponse'];
        };
      };
      /** @description Unauthorized request */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      /** @description Unable to process request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  DeletePushCredentialById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a mobile push credential */
        push_credential_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The mobile push credential was deleted successfully */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized request */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      /** @description Unable to process request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
    };
  };
  ListNetworkCoverage: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The region of associated location to filter on. */
        'filters[available_services][contains]'?: components['schemas']['AvailableService'];
        /** @description The region of associated location to filter on. */
        'filter[location.region]'?: string;
        /** @description The site of associated location to filter on. */
        'filter[location.site]'?: string;
        /** @description The POP of associated location to filter on. */
        'filter[location.pop]'?: string;
        /** @description The code of associated location to filter on. */
        'filter[location.code]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NetworkCoverageListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNetworks: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The network name to filter on. */
        'filter[name]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NetworkListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNetwork: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NetworkCreate'];
      };
    };
    responses: {
      200: components['responses']['NetworkResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetNetwork: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NetworkResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteNetwork: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NetworkResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateNetwork: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['NetworkCreate'];
      };
    };
    responses: {
      200: components['responses']['NetworkResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetDefaultGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DefaultGatewayResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateDefaultGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['DefaultGateway'];
      };
    };
    responses: {
      200: components['responses']['DefaultGatewayResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteDefaultGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DefaultGatewayResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNetworkInterfaces: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The interface name to filter on. */
        'filter[name]'?: string;
        /** @description The interface type to filter on. */
        'filter[type]'?: string;
        /** @description The interface status to filter on. */
        'filter[status]'?: components['schemas']['InterfaceStatus'];
      };
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NetworkInterfaceListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNotificationChannels: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by the id of a channel type */
        'filter[channel_type_id][eq]'?: components['parameters']['ChannelTypeId'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a list of notification channels. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationChannel'][];
            meta?: components['schemas']['PaginationMeta'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNotificationChannels: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Add a Notification Channel */
    requestBody?: {
      content: {
        'application/json': components['schemas']['NotificationChannel'];
      };
    };
    responses: {
      /** @description A Notification Channel response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationChannel'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Notification Channel response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationChannel'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Notification Channel response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationChannel'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateNotificationChannel: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    /** @description Update notification channel object */
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationChannel'];
      };
    };
    responses: {
      /** @description A Notification Channel response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationChannel'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  FindNotificationsEventsConditions: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by the associated record type */
        'filter[associated_record_type][eq]'?: components['parameters']['AssociatedRecordType'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a list of notification event conditions available. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationEventCondition'][];
            meta?: components['schemas']['PaginationMeta'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  FindNotificationsEvents: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a list of notification events available. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationEvent'][];
            meta?: components['schemas']['PaginationMeta'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  FindNotificationsProfiles: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a list of notification profiles. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationProfile'][];
            meta?: components['schemas']['PaginationMeta'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNotificationProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Add a Notification Profile */
    requestBody?: {
      content: {
        'application/json': components['schemas']['NotificationProfile'];
      };
    };
    responses: {
      /** @description A Notification Profile response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationProfile'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetNotificationProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Notification Profile response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationProfile'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteNotificationProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Notification Profile response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationProfile'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateNotificationProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    /** @description Update notification profile object */
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationProfile'];
      };
    };
    responses: {
      /** @description A Notification Profile response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationProfile'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNotificationSettings: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by the id of a notification profile */
        'filter[notification_profile_id][eq]'?: components['parameters']['NotificationProfileId'];
        /** @description Filter by the id of a notification channel */
        'filter[notification_channel][eq]'?: components['parameters']['NotificationChannelId'];
        /** @description Filter by the id of a notification channel */
        'filter[notification_event_condition_id][eq]'?: components['parameters']['NotificationEventConditionId'];
        /** @description Filter by the associated record type */
        'filter[associated_record_type][eq]'?: components['parameters']['AssociatedRecordType'];
        /**
         * @description Filters calls by status.
         * @example no-answer
         */
        Status?: components['parameters']['Status'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Returns a list of notification settings. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationSetting'][];
            meta?: components['schemas']['PaginationMeta'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNotificationSetting: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['NotificationSetting'];
      };
    };
    responses: {
      /** @description A Notification Setting response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationSetting'];
          };
        };
      };
      /** @description A Notification Setting response - async */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationSetting'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetNotificationSetting: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Notification Setting response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationSetting'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteNotificationSetting: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['Id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A Notification Setting response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationSetting'];
          };
        };
      };
      /** @description A Notification Setting response - async */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['NotificationSetting'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNumberBlockOrders: {
    parameters: {
      query?: {
        /** @description Filter number block orders by status. */
        'filter[status]'?: string;
        /** @description Filter number block orders later than this value. */
        'filter[created_at][gt]'?: string;
        /** @description Filter number block orders earlier than this value. */
        'filter[created_at][lt]'?: string;
        /** @description Filter number block  orders having these phone numbers. */
        'filter[phone_numbers.starting_number]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListNumberBlockOrdersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNumberBlockOrder: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateNumberBlockOrderRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberBlockOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveNumberBlockOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number block order ID. */
        number_block_order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberBlockOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  LookupNumber: {
    parameters: {
      query?: {
        /** @description Specifies the type of number lookup to be performed */
        type?: components['parameters']['NumberLookupType'];
      };
      header?: never;
      path: {
        /** @description The phone number to be looked up */
        phone_number: components['parameters']['PhoneNumber'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberLookupResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNumberOrderDocuments: {
    parameters: {
      query?: {
        /** @description Filter number order documents by `requirement_id`. */
        'filter[requirement_id]'?: string;
        /** @description Filter number order documents after this datetime. */
        'filter[created_at][gt]'?: string;
        /** @description Filter number order documents from before this datetime. */
        'filter[created_at][lt]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListNumberOrderDocumentsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNumberOrderDocument: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateNumberOrderDocumentRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberOrderDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveNumberOrderDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number order document ID. */
        number_order_document_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberOrderDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateNumberOrderDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number order document ID. */
        number_order_document_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNumberOrderDocumentRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberOrderDocumentResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveOrderPhoneNumbers: {
    parameters: {
      query?: {
        /** @description Country code of the order phone number. */
        'filter[country_code]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListNumberOrderPhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetNumberOrderPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number order phone number ID. */
        number_order_phone_number_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberOrderPhoneNumberResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateNumberOrderPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number order phone number ID. */
        number_order_phone_number_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNumberOrderPhoneNumberRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberOrderPhoneNumberResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNumberOrders: {
    parameters: {
      query?: {
        /** @description Filter number orders by status. */
        'filter[status]'?: string;
        /** @description Filter number orders later than this value. */
        'filter[created_at][gt]'?: string;
        /** @description Filter number orders earlier than this value. */
        'filter[created_at][lt]'?: string;
        /** @description Filter number order with this amount of numbers */
        'filter[phone_numbers_count]'?: string;
        /** @description Filter number orders via the customer reference set. */
        'filter[customer_reference]'?: string;
        /** @description Filter number orders by requirements met. */
        'filter[requirements_met]'?: boolean;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListNumberOrdersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateNumberOrderRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number order ID. */
        number_order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number order ID. */
        number_order_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateNumberOrderRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListNumberReservations: {
    parameters: {
      query?: {
        /** @description Filter number reservations by status. */
        'filter[status]'?: string;
        /** @description Filter number reservations later than this value. */
        'filter[created_at][gt]'?: string;
        /** @description Filter number reservations earlier than this value. */
        'filter[created_at][lt]'?: string;
        /** @description Filter number reservations having these phone numbers. */
        'filter[phone_numbers.phone_number]'?: string;
        /** @description Filter number reservations via the customer reference set. */
        'filter[customer_reference]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListNumberReservationsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateNumberReservation: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateNumberReservationRequest'];
      };
    };
    responses: {
      200: components['responses']['NumberReservationResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveNumberReservation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number reservation ID. */
        number_reservation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberReservationResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ExtendNumberReservationExpiryTime: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The number reservation ID. */
        number_reservation_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['NumberReservationResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PostNumbersFeatures: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          phone_numbers: string[];
        };
      };
    };
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: {
              /** Format: phone */
              phone_number: string;
              features: string[];
            }[];
          };
        };
      };
    };
  };
  ListOtaUpdates: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by a specific status of the resource's lifecycle. */
        'filter[status]'?: components['parameters']['FilterBasicStatusLifecycle'];
        /** @description The SIM card identification UUID. */
        'filter[sim_card_id]'?: string;
        /** @description Filter by type. */
        'filter[type]'?: 'sim_card_network_preferences';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SearchOTAUpdateResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetOtaUpdate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['OTAUpdateResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListOutboundVoiceProfiles: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Optional filter on outbound voice profile name. */
        'filter[name][contains]'?: components['parameters']['NameFilter'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code>-</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>name</code>: sorts the result by the
         *         <code>name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-name</code>: sorts the result by the
         *         <code>name</code> field in descending order.
         *       </li>
         *     </ul> <br/> */
        sort?: components['parameters']['SortOutboundVoiceProfile'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListOutboundVoiceProfilesResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateVoiceProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined when creating an outbound voice profile */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateOutboundVoiceProfileRequest'];
      };
    };
    responses: {
      200: components['responses']['OutboundVoiceProfileResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetOutboundVoiceProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['OutboundVoiceProfileResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteOutboundVoiceProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['OutboundVoiceProfileResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateOutboundVoiceProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated on an outbound voice profile */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateOutboundVoiceProfileRequest'];
      };
    };
    responses: {
      200: components['responses']['OutboundVoiceProfileResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPartnerCampaignsSharedByUser: {
    parameters: {
      query?: {
        /** @description The 1-indexed page number to get. The default value is `1`. */
        page?: number;
        /** @description The amount of records per page, limited to between 1 and 500 inclusive. The default value is `10`. */
        recordsPerPage?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SharedCampaignRecordSet'];
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetPartnerCampaignSharingStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the campaign in question */
        campaignId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            [key: string]: components['schemas']['CampaignSharingStatus'];
          };
        };
      };
      /** @description Validation Error */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['HTTPValidationError'];
        };
      };
    };
  };
  GetAutoRechargePrefs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['AutoRechargePrefResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateAutoRechargePrefs: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Details to update auto recharge preferences */
    requestBody: {
      content: {
        'application/json': components['schemas']['AutoRechargePrefRequest'];
      };
    };
    responses: {
      200: components['responses']['AutoRechargePrefResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PostAssignMessagingProfileToCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['AssignProfileToCampaignRequest'];
      };
    };
    responses: {
      /** @description Successful Response */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json':
            | components['schemas']['AssignProfileToCampaignResponse']
            | components['schemas']['SettingsDataErrorMessage'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetAssignmentTaskStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        taskId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['AssignmentTaskStatusResponse'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPhoneNumberStatus: {
    parameters: {
      query?: {
        recordsPerPage?: unknown;
        page?: unknown;
      };
      header?: never;
      path: {
        taskId: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberStatusResponsePaginated'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetAllPhoneNumberCampaignsCamelCase: {
    parameters: {
      query?: {
        recordsPerPage?: unknown;
        page?: unknown;
        /** @description Filter results by the Telnyx Campaign id */
        'filter[telnyx_campaign_id]'?: components['parameters']['FilterByTelnyxCampaignID'];
        /** @description Filter results by the Telnyx Brand id */
        'filter[telnyx_brand_id]'?: components['parameters']['FilterByTelnyxBrandID'];
        /** @description Filter results by the TCR Campaign id */
        'filter[tcr_campaign_id]'?: components['parameters']['FilterByTCRCampaignID'];
        /** @description Filter results by the TCR Brand id */
        'filter[tcr_brand_id]'?: components['parameters']['FilterByTCRBrandID'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaignPaginated'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePhoneNumberCampaignCamelCase: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumberCampaignCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaign'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPhoneNumberCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        phoneNumber: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaign'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePhoneNumberCampaignCamelCasePut: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        phoneNumber: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumberCampaignCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaign'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeletePhoneNumberCampaignCamelCase: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        phoneNumber: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SinglePhoneNumberCampaign'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListPhoneNumberBlocksJobs: {
    parameters: {
      query?: {
        /** @description Filter the phone number blocks jobs by type. */
        'filter[type]'?: 'delete_phone_number_block';
        /** @description Filter the phone number blocks jobs by status. */
        'filter[status]'?: 'pending' | 'in_progress' | 'completed' | 'failed';
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        sort?: 'created_at';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPhoneNumberBlocksJobsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePhoneNumberBlockDeletionJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumberBlocksJobDeletePhoneNumberBlockRequest'];
      };
    };
    responses: {
      /** @description Phone number blocks job delete phone numbers requested. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumberBlocksJob'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPhoneNumberBlocksJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the Phone Number Blocks Job. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Phone number blocks job details. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumberBlocksJob'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetAllPhoneNumberCampaigns: {
    parameters: {
      query?: {
        recordsPerPage?: unknown;
        page?: unknown;
        /** @description Filter results by the Telnyx Campaign id */
        'filter[telnyx_campaign_id]'?: components['parameters']['FilterByTelnyxCampaignID'];
        /** @description Filter results by the Telnyx Brand id */
        'filter[telnyx_brand_id]'?: components['parameters']['FilterByTelnyxBrandID'];
        /** @description Filter results by the TCR Campaign id */
        'filter[tcr_campaign_id]'?: components['parameters']['FilterByTCRCampaignID'];
        /** @description Filter results by the TCR Brand id */
        'filter[tcr_brand_id]'?: components['parameters']['FilterByTCRBrandID'];
        /**
         * @description Specifies the sort order for results. If not given, results are sorted by createdAt in descending order.
         * @example -phoneNumber
         */
        sort?:
          | 'assignmentStatus'
          | '-assignmentStatus'
          | 'createdAt'
          | '-createdAt'
          | 'phoneNumber'
          | '-phoneNumber';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaignPaginated'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePhoneNumberCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumberCampaignCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaign'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSinglePhoneNumberCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        phoneNumber: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaign'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PutPhoneNumberCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        phoneNumber: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumberCampaignCreate'];
      };
    };
    responses: {
      /** @description Successful Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['PhoneNumberCampaign'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeletePhoneNumberCampaign: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        phoneNumber: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SinglePhoneNumberCampaign'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListPhoneNumbers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by phone number tags. */
        'filter[tag]'?: string;
        /** @description Filter by phone number. Requires at least three digits.
         *                  Non-numerical characters will result in no values being returned. */
        'filter[phone_number]'?: string;
        /** @description Filter by phone number status. */
        'filter[status]'?:
          | 'purchase_pending'
          | 'purchase_failed'
          | 'port_pending'
          | 'active'
          | 'deleted'
          | 'port_failed'
          | 'emergency_only'
          | 'ported_out'
          | 'port_out_pending';
        /** @description Filter by connection_id. */
        'filter[connection_id]'?: string;
        /** @description Filter contains connection name. Requires at least three characters. */
        'filter[voice.connection_name][contains]'?: string;
        /** @description Filter starts with connection name. Requires at least three characters. */
        'filter[voice.connection_name][starts_with]'?: string;
        /** @description Filter ends with connection name. Requires at least three characters. */
        'filter[voice.connection_name][ends_with]'?: string;
        /** @description Filter by connection name. */
        'filter[voice.connection_name][eq]'?: string;
        /** @description Filter by usage_payment_method. */
        'filter[voice.usage_payment_method]'?: 'pay-per-minute' | 'channel';
        /** @description Filter by the billing_group_id associated with phone numbers. To filter to only phone numbers that have no billing group associated them, set the value of this filter to the string 'null'. */
        'filter[billing_group_id]'?: string;
        /** @description Filter by the emergency_address_id associated with phone numbers. To filter only phone numbers that have no emergency address associated with them, set the value of this filter to the string 'null'. */
        'filter[emergency_address_id]'?: string;
        /** @description Filter numbers via the customer_reference set. */
        'filter[customer_reference]'?: string;
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        sort?:
          | 'purchased_at'
          | 'phone_number'
          | 'connection_name'
          | 'usage_payment_method';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListCsvDownloads: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListCsvDownloadsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateCsvDownload: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CsvDownloadResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetCsvDownload: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the CSV download. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CsvDownloadResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListInboundChannels: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Inbound Channels Response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: {
              /**
               * @description The current number of concurrent channels set for the account
               * @example 7
               */
              channels?: number;
              /**
               * @description Identifies the type of the response
               * @example inbound_channels
               */
              record_type?: string;
            };
          };
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateOutboundChannels: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Inbound channels update */
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The new number of concurrent channels for the account
           * @example 7
           */
          channels: number;
        };
      };
    };
    responses: {
      /** @description Expected Update response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: {
              /**
               * @description The number of channels set for the account
               * @example 7
               */
              channels?: number;
              /**
               * @description Identifies the type of the response
               * @example inbound_channels
               */
              record_type?: string;
            };
          };
        };
      };
      /** @description Unexpected error */
      default: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            errors?: {
              /** Format: int */
              code: string;
              title: string;
              detail?: string;
              source?: {
                /**
                 * Format: json-pointer
                 * @description JSON pointer (RFC6901) to the offending entity.
                 */
                pointer?: string;
                /** @description Indicates which query parameter caused the error. */
                parameter?: string;
              };
              meta?: Record<string, never>;
            }[];
          };
        };
      };
    };
  };
  ListPhoneNumbersJobs: {
    parameters: {
      query?: {
        /** @description Filter the phone number jobs by type. */
        'filter[type]'?:
          | 'update_emergency_settings'
          | 'delete_phone_numbers'
          | 'update_phone_numbers';
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        sort?: 'created_at';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPhoneNumbersJobsResponse'];
      401: components['responses']['UnauthorizedResponse'];
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateDeletePhoneNumbersJob: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumbersJobDeletePhoneNumbersRequest'];
      };
    };
    responses: {
      /** @description Phone numbers job delete phone numbers requested. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumbersJob'];
          };
        };
      };
      401: components['responses']['UnauthorizedResponse'];
      403: components['responses']['ForbiddenResponse'];
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePhoneNumbersJobUpdateEmergencySettings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumbersJobUpdateEmergencySettingsRequest'];
      };
    };
    responses: {
      /** @description Phone numbers enable emergency requested. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumbersJob'];
          };
        };
      };
      401: components['responses']['UnauthorizedResponse'];
      403: components['responses']['ForbiddenResponse'];
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateUpdatePhoneNumbersJob: {
    parameters: {
      query?: {
        /** @description Filter by phone number that have bundles. */
        'filter[has_bundle]'?: string;
        /** @description Filter by phone number tags. */
        'filter[tag]'?: string;
        /** @description Filter by connection_id. */
        'filter[connection_id]'?: string;
        /** @description Filter by phone number. Requires at least three digits.
         *                  Non-numerical characters will result in no values being returned. */
        'filter[phone_number]'?: string;
        /** @description Filter by phone number status. */
        'filter[status]'?:
          | 'purchase_pending'
          | 'purchase_failed'
          | 'port_pending'
          | 'active'
          | 'deleted'
          | 'port_failed'
          | 'emergency_only'
          | 'ported_out'
          | 'port_out_pending';
        /** @description Filter contains connection name. Requires at least three characters. */
        'filter[voice.connection_name][contains]'?: string;
        /** @description Filter by usage_payment_method. */
        'filter[voice.usage_payment_method]'?: 'pay-per-minute' | 'channel';
        /** @description Filter by the billing_group_id associated with phone numbers. To filter to only phone numbers that have no billing group associated them, set the value of this filter to the string 'null'. */
        'filter[billing_group_id]'?: string;
        /** @description Filter by the emergency_address_id associated with phone numbers. To filter only phone numbers that have no emergency address associated with them, set the value of this filter to the string 'null'. */
        'filter[emergency_address_id]'?: string;
        /** @description Filter numbers via the customer_reference set. */
        'filter[customer_reference]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumbersJobUpdatePhoneNumbersRequest'];
      };
    };
    responses: {
      /** @description Phone numbers job update phone numbers requested. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumbersJob'];
          };
        };
      };
      401: components['responses']['UnauthorizedResponse'];
      /** @description Forbidden */
      403: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      /** @description Unprocessable Entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrievePhoneNumbersJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the Phone Numbers Job. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Phone numbers job details. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumbersJob'];
          };
        };
      };
      401: components['responses']['UnauthorizedResponse'];
      /** @description Not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['Errors'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListPhoneNumbersWithMessagingSettings: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPhoneNumbersWithMessagingSettingsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SlimListPhoneNumbers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Include the connection associated with the phone number. */
        include_connection?: boolean;
        /** @description Include the tags associated with the phone number. */
        include_tags?: boolean;
        /** @description Filter by phone number tags. (This requires the include_tags param) */
        'filter[tag]'?: string;
        /** @description Filter by phone number. Requires at least three digits.
         *                  Non-numerical characters will result in no values being returned. */
        'filter[phone_number]'?: string;
        /** @description Filter by phone number status. */
        'filter[status]'?:
          | 'purchase_pending'
          | 'purchase_failed'
          | 'port_pending'
          | 'active'
          | 'deleted'
          | 'port_failed'
          | 'emergency_only'
          | 'ported_out'
          | 'port_out_pending';
        /** @description Filter by connection_id. */
        'filter[connection_id]'?: string;
        /** @description Filter contains connection name. Requires at least three characters and the include_connection param. */
        'filter[voice.connection_name][contains]'?: string;
        /** @description Filter starts with connection name. Requires at least three characters and the include_connection param. */
        'filter[voice.connection_name][starts_with]'?: string;
        /** @description Filter ends with connection name. Requires at least three characters and the include_connection param. */
        'filter[voice.connection_name][ends_with]'?: string;
        /** @description Filter by connection name , requires the include_connection param and the include_connection param. */
        'filter[voice.connection_name]'?: string;
        /** @description Filter by usage_payment_method. */
        'filter[voice.usage_payment_method]'?: 'pay-per-minute' | 'channel';
        /** @description Filter by the billing_group_id associated with phone numbers. To filter to only phone numbers that have no billing group associated them, set the value of this filter to the string 'null'. */
        'filter[billing_group_id]'?: string;
        /** @description Filter by the emergency_address_id associated with phone numbers. To filter only phone numbers that have no emergency address associated with them, set the value of this filter to the string 'null'. */
        'filter[emergency_address_id]'?: string;
        /** @description Filter numbers via the customer_reference set. */
        'filter[customer_reference]'?: string;
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        sort?:
          | 'purchased_at'
          | 'phone_number'
          | 'connection_name'
          | 'usage_payment_method';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SlimListPhoneNumbersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListPhoneNumbersWithVoiceSettings: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by phone number. Requires at least three digits.
         *                  Non-numerical characters will result in no values being returned. */
        'filter[phone_number]'?: string;
        /** @description Filter contains connection name. Requires at least three characters. */
        'filter[connection_name][contains]'?: string;
        /** @description Filter numbers via the customer_reference set. */
        'filter[customer_reference]'?: string;
        /** @description Filter by usage_payment_method. */
        'filter[voice.usage_payment_method]'?: 'pay-per-minute' | 'channel';
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        sort?:
          | 'purchased_at'
          | 'phone_number'
          | 'connection_name'
          | 'usage_payment_method';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPhoneNumbersWithVoiceSettingsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrievePhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['IntId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PhoneNumberResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeletePhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['IntId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeletePhoneNumberResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdatePhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['IntId'];
      };
      cookie?: never;
    };
    /** @description Updated settings for the phone number. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePhoneNumberRequest'];
      };
    };
    responses: {
      200: components['responses']['PhoneNumberResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  EnablePhoneNumberEmergency: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['IntId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PhoneNumberEnableEmergencyRequest'];
      };
    };
    responses: {
      /** @description Phone number emergency enabled. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumberWithVoiceSettings'];
          };
        };
      };
      /** @description Phone number emergency requested. */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['PhoneNumberWithVoiceSettings'];
          };
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPhoneNumberMessagingSettings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the type of resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PhoneNumberWithMessagingSettingsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdatePhoneNumberMessagingSettings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The phone number to update. */
        id: string;
      };
      cookie?: never;
    };
    /** @description The new configuration to set for this phone number.
     *
     *     To avoid modifying a value, either omit the field or set its value to `null`. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePhoneNumberMessagingSettingsRequest'];
      };
    };
    responses: {
      200: components['responses']['PhoneNumberWithMessagingSettingsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPhoneNumberVoiceSettings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['IntId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PhoneNumberWithVoiceSettingsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdatePhoneNumberVoiceSettings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['IntId'];
      };
      cookie?: never;
    };
    /** @description Updated voice settings for the phone number. */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePhoneNumberVoiceSettingsRequest'];
      };
    };
    responses: {
      200: components['responses']['PhoneNumberWithVoiceSettingsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetVoicemail: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The ID of the phone number.
         * @example 123455678900
         */
        phone_number_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['VoicemailResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateVoicemail: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The ID of the phone number.
         * @example 123455678900
         */
        phone_number_id: string;
      };
      cookie?: never;
    };
    /** @description Details to create */
    requestBody: {
      content: {
        'application/json': components['schemas']['VoicemailRequest'];
      };
    };
    responses: {
      200: components['responses']['VoicemailResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateVoicemail: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description The ID of the phone number.
         * @example 123455678900
         */
        phone_number_id: string;
      };
      cookie?: never;
    };
    /** @description Details to update */
    requestBody: {
      content: {
        'application/json': components['schemas']['VoicemailRequest'];
      };
    };
    responses: {
      200: components['responses']['VoicemailResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListRegulatoryRequirementsPhoneNumbers: {
    parameters: {
      query: {
        /** @description Record type phone number/ phone numbers */
        'filter[phone_number]': string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['listRegulatoryRequirementsPhoneNumbers'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PostPortabilityCheck: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description The list of +E.164 formatted phone numbers to check for portability
           * @example [
           *       "+13035550000",
           *       "+13035550001",
           *       "+13035550002"
           *     ]
           */
          phone_numbers?: string[];
        };
      };
    };
    responses: {
      201: components['responses']['PortabilityCheckResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listPortingEvents: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by event type. */
        'filter[type]'?:
          | 'porting_order.deleted'
          | 'porting_order.loa_updated'
          | 'porting_order.messaging_changed'
          | 'porting_order.status_changed'
          | 'porting_order.sharing_token_expired'
          | 'porting_order.new_comment'
          | 'porting_order.split';
        /** @description Filter by porting order ID. */
        'filter[porting_order_id]'?: string;
        /** @description Filter by created at greater than or equal to. */
        'filter[created_at][gte]'?: string;
        /** @description Filter by created at less than or equal to. */
        'filter[created_at][lte]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingEventsResponse'];
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  showPortingEvent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the porting event. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortingEventResponse'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  republishPortingEvent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the porting event. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PreviewLoaConfigurationParams: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingLOAConfiguration'];
    responses: {
      200: components['responses']['DownloadLOATemplate'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListLoaConfigurations: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingLOAConfigurations'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateLoaConfiguration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingLOAConfiguration'];
    responses: {
      201: components['responses']['CreatePortingLOAConfiguration'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetLoaConfiguration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies a LOA configuration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortingLOAConfiguration'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteLoaConfiguration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies a LOA configuration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateLoaConfiguration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies a LOA configuration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingLOAConfiguration'];
    responses: {
      200: components['responses']['UpdatePortingLOAConfiguration'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PreviewLoaConfiguration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies a LOA configuration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DownloadLOATemplate'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortingReports: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter reports of a specific type */
        'filter[report_type]'?: 'export_porting_orders_csv';
        /** @description Filter reports of a specific status */
        'filter[status]'?: 'pending' | 'completed';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingReports'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreatePortingReport: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingReport'];
    responses: {
      201: components['responses']['CreatePortingReport'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortingOrders: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Include the first 50 phone number objects in the results */
        include_phone_numbers?: components['parameters']['QueryIncludePhoneNumbers'];
        /** @description Filter results by status */
        'filter[status]'?: components['parameters']['FilterByPortingOrderStatus'];
        /** @description Filter porting orders by multiple statuses */
        'filter[status][in][]'?: components['parameters']['FilterByPortingOrderStatusIn'];
        /**
         * @description Filter results by customer_reference
         * @example 123abc
         */
        'filter[customer_reference]'?: string;
        /**
         * @description Filter results by parent_support_key
         * @example 123abc
         */
        'filter[parent_support_key]'?: string;
        /**
         * @description Filter results by country ISO 3166-1 alpha-2 code
         * @example US
         */
        'filter[phone_numbers.country_code]'?: string;
        /**
         * @description Filter results by old service provider
         * @example Telnyx
         */
        'filter[phone_numbers.carrier_name]'?: string;
        /**
         * @description Filter results by porting order type
         * @example full
         */
        'filter[misc.type]'?: components['schemas']['PortingOrderType'];
        /**
         * @description Filter results by person or company name
         * @example Porter McPortersen
         */
        'filter[end_user.admin.entity_name]'?: string;
        /**
         * @description Filter results by authorized person
         * @example Admin McPortersen
         */
        'filter[end_user.admin.auth_person_name]'?: string;
        /**
         * @description Filter results by fast port eligible
         * @example false
         */
        'filter[activation_settings.fast_port_eligible]'?: boolean;
        /**
         * @description Filter results by foc date later than this value
         * @example 2021-03-25T10:00:00.000Z
         */
        'filter[activation_settings.foc_datetime_requested][gt]'?: string;
        /**
         * @description Filter results by foc date earlier than this value
         * @example 2021-03-25T10:00:00.000Z
         */
        'filter[activation_settings.foc_datetime_requested][lt]'?: string;
        /**
         * @description Filter results by full or partial phone_number
         * @example +13038675309
         */
        'filter[phone_numbers.phone_number][contains]'?: string;
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        'sort[]'?:
          | 'created_at'
          | '-created_at'
          | 'activation_settings.foc_datetime_requested'
          | '-activation_settings.foc_datetime_requested';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingOrder'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreatePortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePortingOrder'];
      };
    };
    responses: {
      201: components['responses']['ListDraftPortingOrdersWithoutPagination'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListExceptionTypes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingOrdersExceptionTypes'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPhoneNumberConfigurations: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter results by porting order id */
        'filter[porting_order_id]'?: components['parameters']['FilterByPortingOrderID'];
        /** @description Filter results by a list of porting order ids */
        'filter[porting_order_id][in][]'?: components['parameters']['FilterByPortingOrderIdIn'];
        /** @description Filter results by a specific porting order status */
        'filter[porting_order.status]'?:
          | 'activation-in-progress'
          | 'cancel-pending'
          | 'cancelled'
          | 'draft'
          | 'exception'
          | 'foc-date-confirmed'
          | 'in-process'
          | 'ported'
          | 'submitted';
        /** @description Filter results by specific porting order statuses */
        'filter[porting_order.status][in][]'?: (
          | 'activation-in-progress'
          | 'cancel-pending'
          | 'cancelled'
          | 'draft'
          | 'exception'
          | 'foc-date-confirmed'
          | 'in-process'
          | 'ported'
          | 'submitted'
        )[];
        /** @description Filter results by a specific porting phone number ID */
        'filter[porting_phone_number]'?: string;
        /** @description Filter results by a list of porting phone number IDs */
        'filter[porting_phone_number][in][]'?: string[];
        /** @description Filter results by a specific user bundle ID */
        'filter[user_bundle_id]'?: string;
        /** @description Filter results by a list of user bundle IDs */
        'filter[user_bundle_id][in][]'?: string[];
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        'sort[]'?: 'created_at' | '-created_at';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingPhoneNumberConfigurations'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreatePhoneNumberConfigurations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingPhoneNumberConfigurations'];
    responses: {
      201: components['responses']['CreatePortingPhoneNumberConfigurations'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPortingOrder: {
    parameters: {
      query?: {
        /** @description Include the first 50 phone number objects in the results */
        include_phone_numbers?: components['parameters']['QueryIncludePhoneNumbers'];
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortingOrder'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeletePortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdatePortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdatePortingOrder'];
      };
    };
    responses: {
      200: components['responses']['UpdatePortingOrderResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ActivatePortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['ShowPortingOrdersActivationJob'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CancelPortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['CancelPortingOrderResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ConfirmPortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ConfirmPortingOrderResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SharePortingOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['SharePortingOrder'];
    responses: {
      201: components['responses']['SharePortingOrder'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Porting Order not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortingOrderActivationJobs: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingOrdersActivationJobs'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPortingOrdersActivationJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
        /** @description Activation Job Identifier */
        activationJobId: components['parameters']['PathPortingOrdersActivationJobID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortingOrdersActivationJob'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdatePortingOrdersActivationJob: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
        /** @description Activation Job Identifier */
        activationJobId: components['parameters']['PathPortingOrdersActivationJobID'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['UpdatePortingOrdersActivationJob'];
    responses: {
      200: components['responses']['ShowPortingOrdersActivationJob'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListAdditionalDocuments: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter additional documents of a specific document type */
        'filter[document_type]'?: 'loa' | 'invoice' | 'csr' | 'other';
        /** @description Filter additional documents by a list of document types */
        'filter[document_type][in][]'?: ('loa' | 'invoice' | 'csr' | 'other')[];
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        'sort[]'?: 'created_at' | '-created_at';
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingAdditionalDocuments'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateAdditionalDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingAdditionalDocuments'];
    responses: {
      201: components['responses']['CreatePortingAdditionalDocuments'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteAdditionalDocument: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
        /** @description Additional document identification. */
        additional_document_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListAllowedFocWindows: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListAllowedFocWindows'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortingOrderComments: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingOrdersComments'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateComment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreatePortingOrderComment'];
      };
    };
    responses: {
      201: components['responses']['ShowPortingOrdersComment'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPortingOrderLoaTemplate: {
    parameters: {
      query?: {
        /**
         * @description The identifier of the LOA configuration to use for the template. If not provided, the default LOA configuration will be used.
         * @example a36c2277-446b-4d11-b4ea-322e02a5c08d
         */
        loa_configuration_id?: string;
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DownloadLOATemplate'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortingOrderRequirements: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingOrderRequirements'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPortingOrderSubRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SubRequestByPortingOrder'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Porting Order not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListVerificationCodes: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter results by phone number */
        'filter[phone_number]'?: components['parameters']['FilterByPhoneNumber'];
        /** @description Filter results by a list of phone numbers */
        'filter[phone_number][in][]'?: components['parameters']['FilterByPhoneNumberIn'];
        /** @description Filter verification codes that have been verified or not */
        'filter[verified]'?: boolean;
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order. */
        'sort[]'?: 'created_at' | '-created_at';
      };
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingVerificationCodes'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  SendPortingVerificationCodes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody?: components['requestBodies']['SendPortingVerificationCodes'];
    responses: {
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  VerifyPortingVerificationCodes: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Porting Order id */
        id: components['parameters']['PathPortingOrderID'];
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['VerifyPortingVerificationCodes'];
    responses: {
      200: components['responses']['VerifyPortingVerificationCodes'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listPortingPhoneNumberBlocks: {
    parameters: {
      query?: {
        /** @description Filter results by phone number */
        'filter[phone_number]'?: components['parameters']['FilterByPhoneNumber'];
        /** @description Filter results by a list of phone numbers */
        'filter[phone_number][in][]'?: components['parameters']['FilterByPhoneNumberIn'];
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order */
        'sort[]'?: '-created_at' | 'created_at';
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Identifies the Porting Order associated with the phone number blocks */
        porting_order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingPhoneNumberBlocks'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createPortingPhoneNumberBlock: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the Porting Order associated with the phone number block */
        porting_order_id: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingPhoneNumberBlock'];
    responses: {
      201: components['responses']['ShowPortingPhoneNumberBlock'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deletePortingPhoneNumberBlock: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the Porting Order associated with the phone number block */
        porting_order_id: string;
        /** @description Identifies the phone number block to be deleted */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortingPhoneNumberBlock'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listPortingPhoneNumberExtensions: {
    parameters: {
      query?: {
        /** @description Filter results by phone number */
        'filter[phone_number]'?: components['parameters']['FilterByPhoneNumber'];
        /** @description Filter results by a list of phone numbers */
        'filter[phone_number][in][]'?: components['parameters']['FilterByPhoneNumberIn'];
        /** @description Filter results by porting phone number id */
        'filter[porting_phone_number_id]'?: string;
        /** @description Filter results by a list of porting phone number ids */
        'filter[porting_phone_number_id][in][]'?: string;
        /** @description Specifies the sort order for results. If not given, results are sorted by created_at in descending order */
        'sort[]'?: '-created_at' | 'created_at';
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Identifies the Porting Order associated with the phone number extensions */
        porting_order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingPhoneNumberExtensions'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  createPortingPhoneNumberExtension: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the Porting Order associated with the phone number extension */
        porting_order_id: string;
      };
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortingPhoneNumberExtension'];
    responses: {
      201: components['responses']['ShowPortingPhoneNumberExtension'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  deletePortingPhoneNumberExtension: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the Porting Order associated with the phone number extension */
        porting_order_id: string;
        /** @description Identifies the phone number extension to be deleted */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortingPhoneNumberExtension'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortingPhoneNumbers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter results by porting order id */
        'filter[porting_order_id]'?: components['parameters']['FilterByPortingOrderID'];
        /** @description Filter results by a list of porting order ids */
        'filter[porting_order_id][in][]'?: components['parameters']['FilterByPortingOrderIdIn'];
        /** @description Filter results by support key */
        'filter[support_key][eq]'?: components['parameters']['FilterBySupportKeyEq'];
        /** @description Filter results by a list of support keys */
        'filter[support_key][in][]'?: components['parameters']['FilterBySupportKeyIn'];
        /** @description Filter results by phone number */
        'filter[phone_number]'?: components['parameters']['FilterByPhoneNumber'];
        /** @description Filter results by a list of phone numbers */
        'filter[phone_number][in][]'?: components['parameters']['FilterByPhoneNumberIn'];
        /** @description Filter results by porting order status */
        'filter[porting_order_status]'?:
          | 'draft'
          | 'in-process'
          | 'submitted'
          | 'exception'
          | 'foc-date-confirmed'
          | 'cancel-pending'
          | 'ported'
          | 'cancelled';
        /** @description Filter results by activation status */
        'filter[activation_status]'?: components['parameters']['FilterByPortingOrderActivationStatus'];
        /** @description Filter results by portability status */
        'filter[portability_status]'?: components['parameters']['FilterByPortabilityStatus'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortingPhoneNumbers'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  listPortoutEvents: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by event type. */
        'filter[event_type]'?:
          | 'portout.status_changed'
          | 'portout.new_comment'
          | 'portout.foc_date_changed';
        /** @description Filter by port-out order ID. */
        'filter[portout_id]'?: string;
        /** @description Filter by created at greater than or equal to. */
        'filter[created_at][gte]'?: string;
        /** @description Filter by created at less than or equal to. */
        'filter[created_at][lte]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortoutEventsResponse'];
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  showPortoutEvent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the port-out event. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortoutEventResponse'];
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  republishPortoutEvent: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the port-out event. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description No content */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortoutReports: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter reports of a specific type */
        'filter[report_type]'?: 'export_portouts_csv';
        /** @description Filter reports of a specific status */
        'filter[status]'?: 'pending' | 'completed';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortoutReports'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreatePortoutReport: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['CreatePortoutReport'];
    responses: {
      201: components['responses']['CreatePortoutReport'];
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPortingReport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies a report. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShowPortoutReport'];
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Internal server error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListPortoutRequest: {
    parameters: {
      query?: {
        /** @description Filter by new carrier name. */
        'filter[carrier_name]'?: string;
        /** @description Filter by new carrier spid. */
        'filter[spid]'?: string;
        /** @description Filter by portout status. */
        'filter[status]'?:
          | 'pending'
          | 'authorized'
          | 'ported'
          | 'rejected'
          | 'rejected-pending'
          | 'canceled';
        /** @description Filter by a list of portout statuses */
        'filter[status_in]'?: (
          | 'pending'
          | 'authorized'
          | 'ported'
          | 'rejected'
          | 'rejected-pending'
          | 'canceled'
        )[];
        /** @description Filter by ported_out_at date greater than or equal. */
        'filter[ported_out_at][gte]'?: string;
        /** @description Filter by ported_out_at date less than or equal. */
        'filter[ported_out_at][lte]'?: string;
        /** @description Filter by inserted_at date greater than or equal. */
        'filter[inserted_at][gte]'?: string;
        /** @description Filter by inserted_at date less than or equal. */
        'filter[inserted_at][lte]'?: string;
        /** @description Filter by foc_date. Matches all portouts with the same date */
        'filter[foc_date]'?: string;
        /** @description Filter by a phone number on the portout. Matches all portouts with the phone number */
        'filter[phone_number]'?: string;
        /** @description Filter by the portout's support_key */
        'filter[support_key]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortoutResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  FindPortoutRequest: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Portout id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PortoutResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  FindPortoutComments: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Portout id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListPortoutComments'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PostPortRequestComment: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Portout id */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @description Comment to post on this portout request */
          body?: string;
        };
      };
    };
    responses: {
      201: components['responses']['PortoutCommentResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPortRequestSupportingDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Portout id */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      201: components['responses']['PortOutListSupportingDocumentsResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PostPortRequestSupportingDocuments: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Portout id */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @description List of supporting documents parameters */
          documents?: {
            /**
             * @description Identifies the type of the document
             * @example loa
             * @enum {string}
             */
            type: 'loa' | 'invoice';
            /**
             * Format: uuid
             * @description Identifies the associated document
             * @example 0ccc7b54-4df3-4bca-a65a-3da1ecc777f0
             */
            document_id: string;
          }[];
        };
      };
    };
    responses: {
      201: components['responses']['CreatePortOutSupportingDocumentsResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdatePortoutStatus: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Portout id */
        id: string;
        /** @description Updated portout status */
        status: 'authorized' | 'rejected-pending';
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Provide a reason if rejecting the port out request
           * @example I do not recognize this transaction
           */
          reason?: string;
        };
      };
    };
    responses: {
      200: components['responses']['PortoutResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity. Check message field in response for details. */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetPrivateWirelessGateways: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /**
         * @description The name of the Private Wireless Gateway.
         * @example my private gateway
         */
        'filter[name]'?: string;
        /**
         * @description The IP address range of the Private Wireless Gateway.
         * @example 192.168.0.0/24
         */
        'filter[ip_range]'?: string;
        /**
         * @description The name of the region where the Private Wireless Gateway is deployed.
         * @example ashburn-va
         */
        'filter[region_code]'?: string;
        /**
         * @description Private Wireless Gateway resource creation date.
         * @example 2018-02-02T22:25:27.521Z
         */
        'filter[created_at]'?: string;
        /**
         * @description When the Private Wireless Gateway was last updated.
         * @example 2018-02-02T22:25:27.521Z
         */
        'filter[updated_at]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllPrivateWirelessGatewaysResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePrivateWirelessGateway: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: uuid
           * @description The identification of the related network resource.
           * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
           */
          network_id: string;
          /**
           * @description The private wireless gateway name.
           * @example My private wireless gateway
           */
          name: string;
        };
      };
    };
    responses: {
      202: components['responses']['CreatePrivateWirelessGatewayResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPrivateWirelessGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the private wireless gateway. */
        id: components['parameters']['PrivateWirelessGatewayId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetPrivateWirelessGatewayResponse'];
      404: components['responses']['ResourceNotFound'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteWirelessGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the private wireless gateway. */
        id: components['parameters']['PrivateWirelessGatewayId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeletePrivateWirelessGatewayResponse'];
      404: components['responses']['ResourceNotFound'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListPublicInternetGateways: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The associated network id to filter on. */
        'filter[network_id]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PublicInternetGatewayListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreatePublicInternetGateway: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['PublicInternetGatewayCreate'];
      };
    };
    responses: {
      202: components['responses']['PublicInternetGatewayResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetPublicInternetGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PublicInternetGatewayResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeletePublicInternetGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['PublicInternetGatewayResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveCallQueue: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the queue by name */
        queue_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['QueueResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  ListQueueCalls: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Uniquely identifies the queue by name */
        queue_name: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListQueueCallsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  RetrieveCallFromQueue: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the queue by name */
        queue_name: string;
        /** @description Unique identifier and token for controlling the call */
        call_control_id: components['parameters']['CallControlId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['QueueCallResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  getRecordingTranscriptions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRecordingTranscriptionsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  getRecordingTranscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        recording_transcription_id: components['parameters']['RecordingTranscriptionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RecordingTranscriptionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  deleteRecordingTranscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        recording_transcription_id: components['parameters']['RecordingTranscriptionId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RecordingTranscriptionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetRecordings: {
    parameters: {
      query?: {
        /** @description Returns only recordings associated with a given conference */
        'filter[conference_id]'?: string;
        /** @description Returns only recordings created later than or at given ISO 8601 datetime */
        'filter[created_at][gte]'?: string;
        /** @description Returns only recordings created earlier than or at given ISO 8601 datetime */
        'filter[created_at][lte]'?: string;
        /** @description If present, recordings will be filtered to those with a matching call_leg_id. */
        'filter[call_leg_id]'?: string;
        /** @description If present, recordings will be filtered to those with a matching call_session_id. */
        'filter[call_session_id]'?: string;
        /** @description If present, recordings will be filtered to those with a matching `from` attribute. Matching is case-sensitive */
        'filter[from]'?: string;
        /** @description If present, recordings will be filtered to those with a matching `to` attribute. Matching is case-sensitive */
        'filter[to]'?: string;
        /** @description If present, recordings will be filtered to those with a matching `connection_id` attribute. Matching is case-sensitive */
        'filter[connection_id]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RecordingsResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteRecordings: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: components['requestBodies']['DeleteRecordingsRequest'];
    responses: {
      /** @description The recordings have been successfully deleted. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the recording by id. */
        recording_id: components['parameters']['RecordingId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RecordingResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the recording by id. */
        recording_id: components['parameters']['RecordingId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RecordingResponseBody'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListRegions: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['RegionListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListRegulatoryRequirements: {
    parameters: {
      query?: {
        /** @description Phone number to check requirements for */
        'filter[phone_number]'?: string;
        /** @description ID of requirement group to check requirements for */
        'filter[requirement_group_id]'?: string;
        /** @description Country code(iso2) to check requirements for */
        'filter[country_code]'?: string;
        /** @description Phone number type to check requirements for */
        'filter[phone_number_type]'?:
          | 'local'
          | 'toll_free'
          | 'mobile'
          | 'national'
          | 'shared_cost';
        /** @description Action to check requirements for */
        'filter[action]'?: 'ordering' | 'porting' | 'action';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['listRegulatoryRequirements'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetUsageReports: {
    parameters: {
      query?: {
        /** @description Page number */
        'page[number]'?: number;
        /** @description Size of the page */
        'page[size]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MdrGetUsageReportsResponse'];
        };
      };
    };
  };
  SubmitUsageReport: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Mdr usage report data */
    requestBody: {
      content: {
        '*/*': components['schemas']['MdrPostUsageReportRequest'];
      };
    };
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MdrPostUsageReportsResponse'];
        };
      };
    };
  };
  GetUsageReportSync: {
    parameters: {
      query: {
        start_date?: string;
        end_date?: string;
        aggregation_type: 'NO_AGGREGATION' | 'PROFILE' | 'TAGS';
        profiles?: string[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MdrGetSyncUsageReportResponse'];
        };
      };
    };
  };
  DeleteUsageReport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MdrDeleteUsageReportsResponse'];
        };
      };
    };
  };
  GetPaginatedMdrs: {
    parameters: {
      query?: {
        /** @description Pagination start date */
        start_date?: string;
        /** @description Pagination end date */
        end_date?: string;
        id?: string;
        direction?: 'INBOUND' | 'OUTBOUND';
        profile?: string;
        cld?: string;
        cli?: string;
        status?:
          | 'GW_TIMEOUT'
          | 'DELIVERED'
          | 'DLR_UNCONFIRMED'
          | 'DLR_TIMEOUT'
          | 'RECEIVED'
          | 'GW_REJECT'
          | 'FAILED';
        message_type?: 'SMS' | 'MMS';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['MdrGetDetailResponse'];
        };
      };
    };
  };
  GetPaginatedWdrs: {
    parameters: {
      query?: {
        /** @description Start date */
        start_date?: string;
        /** @description End date */
        end_date?: string;
        id?: string;
        mcc?: string;
        mnc?: string;
        imsi?: string;
        sim_group_name?: string;
        sim_group_id?: string;
        sim_card_id?: string;
        phone_number?: string;
        /** @description Page number */
        'page[number]'?: number;
        /** @description Size of the page */
        'page[size]'?: number;
        sort?: string[];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ExternalWdrGetDetailResponse'];
        };
      };
    };
  };
  GetRequirementGroups: {
    parameters: {
      query?: {
        /** @description Filter requirement groups by country code (iso alpha 2) */
        'filter[country_code]'?: string;
        /** @description Filter requirement groups by phone number type. */
        'filter[phone_number_type]'?:
          | 'local'
          | 'toll_free'
          | 'mobile'
          | 'national'
          | 'shared_cost';
        /** @description Filter requirement groups by action type */
        'filter[action]'?: 'ordering' | 'porting' | 'action';
        /** @description Filter requirement groups by customer reference */
        'filter[customer_reference]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description List requirement groups */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequirementGroup'][];
        };
      };
    };
  };
  CreateRequirementGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description ISO alpha 2 country code
           * @example US
           */
          country_code: string;
          /**
           * @example local
           * @enum {string}
           */
          phone_number_type:
            | 'local'
            | 'toll_free'
            | 'mobile'
            | 'national'
            | 'shared_cost';
          /**
           * @example ordering
           * @enum {string}
           */
          action: 'ordering' | 'porting';
          customer_reference?: string;
          regulatory_requirements?: {
            requirement_id?: string;
            field_value?: string;
          }[];
        };
      };
    };
    responses: {
      /** @description Requirement group created */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequirementGroup'];
        };
      };
    };
  };
  GetRequirementGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the requirement group to retrieve */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description A single requirement group */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequirementGroup'];
        };
      };
    };
  };
  DeleteRequirementGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the requirement group */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Deleted requirement group */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequirementGroup'];
        };
      };
    };
  };
  UpdateRequirementGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description ID of the requirement group */
        id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * @description Reference for the customer
           * @example 0002
           */
          customer_reference?: string;
          regulatory_requirements?: {
            /**
             * @description Unique identifier for the regulatory requirement
             * @example 53970723-fbff-4f46-a975-f62be6c1a585
             */
            requirement_id?: string;
            /**
             * @description New value for the regulatory requirement
             * @example new requirement value
             */
            field_value?: string;
          }[];
        };
      };
    };
    responses: {
      /** @description Updated requirement group */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RequirementGroup'];
        };
      };
    };
  };
  ListRequirementTypes: {
    parameters: {
      query?: {
        /** @description Filters requirement types to those whose name contains a certain string. */
        'filter[name][contains]'?: components['parameters']['DocReqsRequirementTypeNameFilter'];
        /** @description Specifies the sort order for results. If you want to sort by a field in ascending order, include it as a sort parameter. If you want to sort in descending order, prepend a `-` in front of the field name. */
        'sort[]'?: components['parameters']['DocReqsRequirementTypesSort'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DocReqsListRequirementTypesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveRequirementType: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description Uniquely identifies the requirement_type record
         * @example a38c217a-8019-48f8-bff6-0fdd9939075b
         */
        id: components['parameters']['DocReqsRequirementTypeId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DocReqsRequirementTypeResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListRequirements: {
    parameters: {
      query?: {
        /** @description Filters results to those applying to a 2-character (ISO 3166-1 alpha-2) country code */
        'filter[country_code]'?: components['parameters']['DocReqsCountryFilter'];
        /** @description Filters results to those applying to a specific `phone_number_type` */
        'filter[phone_number_type]'?: components['parameters']['DocReqsPhoneNumberTypeFilter'];
        /** @description Filters requirements to those applying to a specific action. */
        'filter[action]'?: components['parameters']['DocReqsActionFilter'];
        /** @description Specifies the sort order for results. If you want to sort by a field in ascending order, include it as a sort parameter. If you want to sort in descending order, prepend a `-` in front of the field name. */
        'sort[]'?: components['parameters']['DocReqsRequirementsSort'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRequirementsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveDocumentRequirements: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /**
         * @description Uniquely identifies the requirement_type record
         * @example a9dad8d5-fdbd-49d7-aa23-39bb08a5ebaa
         */
        id: components['parameters']['DocReqsRequirementId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DocReqsRequirementResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListRoomCompositions: {
    parameters: {
      query?: {
        /** @description ISO 8601 date for filtering room compositions created on that date. */
        'filter[date_created_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room compositions created after that date. */
        'filter[date_created_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room compositions created before that date. */
        'filter[date_created_at][lte]'?: string;
        /** @description The session_id for filtering room compositions. */
        'filter[session_id]'?: string;
        /** @description The status for filtering room compositions. */
        'filter[status]'?: 'completed' | 'processing' | 'enqueued';
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRoomCompositionsResponse'];
    };
  };
  CreateRoomComposition: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during room composition creation. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRoomCompositionRequest'];
      };
    };
    responses: {
      202: components['responses']['CreateRoomCompositionResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  ViewRoomComposition: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room composition. */
        room_composition_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetRoomCompositionResponse'];
      404: components['responses']['ResourceNotFound'];
    };
  };
  DeleteRoomComposition: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room composition. */
        room_composition_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components['responses']['ResourceNotFound'];
    };
  };
  ViewRoomParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room participant. */
        room_participant_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetRoomParticipantResponse'];
      404: components['responses']['ResourceNotFound'];
    };
  };
  ListRoomRecordings: {
    parameters: {
      query?: {
        /** @description ISO 8601 date for filtering room recordings ended on that date. */
        'filter[date_ended_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room recordings ended after that date. */
        'filter[date_ended_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room recordings ended before that date. */
        'filter[date_ended_at][lte]'?: string;
        /** @description ISO 8601 date for filtering room recordings started on that date. */
        'filter[date_started_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room recordings started after that date. */
        'filter[date_started_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room recordings started before that date. */
        'filter[date_started_at][lte]'?: string;
        /** @description room_id for filtering room recordings. */
        'filter[room_id]'?: string;
        /** @description participant_id for filtering room recordings. */
        'filter[participant_id]'?: string;
        /** @description session_id for filtering room recordings. */
        'filter[session_id]'?: string;
        /** @description status for filtering room recordings. */
        'filter[status]'?: string;
        /** @description type for filtering room recordings. */
        'filter[type]'?: string;
        /** @description duration_secs equal for filtering room recordings. */
        'filter[duration_secs][eq]'?: number;
        /** @description duration_secs less or equal for filtering room recordings. */
        'filter[duration_secs][lte]'?: number;
        /** @description duration_secs greater or equal for filtering room recordings. */
        'filter[duration_secs][gte]'?: number;
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRoomRecordingsResponse'];
    };
  };
  DeleteRoomRecordings: {
    parameters: {
      query?: {
        /** @description ISO 8601 date for filtering room recordings ended on that date. */
        'filter[date_ended_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room recordings ended after that date. */
        'filter[date_ended_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room recordings ended before that date. */
        'filter[date_ended_at][lte]'?: string;
        /** @description ISO 8601 date for filtering room recordings started on that date. */
        'filter[date_started_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room recordings started after that date. */
        'filter[date_started_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room recordings started before that date. */
        'filter[date_started_at][lte]'?: string;
        /** @description room_id for filtering room recordings. */
        'filter[room_id]'?: string;
        /** @description participant_id for filtering room recordings. */
        'filter[participant_id]'?: string;
        /** @description session_id for filtering room recordings. */
        'filter[session_id]'?: string;
        /** @description status for filtering room recordings. */
        'filter[status]'?: string;
        /** @description type for filtering room recordings. */
        'filter[type]'?: string;
        /** @description duration_secs equal for filtering room recordings. */
        'filter[duration_secs][eq]'?: number;
        /** @description duration_secs less or equal for filtering room recordings. */
        'filter[duration_secs][lte]'?: number;
        /** @description duration_secs greater or equal for filtering room recordings. */
        'filter[duration_secs][gte]'?: number;
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      201: components['responses']['BulkDeleteRoomRecordingsResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  ViewRoomRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room recording. */
        room_recording_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetRoomRecordingResponse'];
      404: components['responses']['ResourceNotFound'];
    };
  };
  DeleteRoomRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room recording. */
        room_recording_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components['responses']['ResourceNotFound'];
    };
  };
  ListRoomSessions: {
    parameters: {
      query?: {
        /** @description ISO 8601 date for filtering room sessions created on that date. */
        'filter[date_created_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room sessions created after that date. */
        'filter[date_created_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room sessions created before that date. */
        'filter[date_created_at][lte]'?: string;
        /** @description ISO 8601 date for filtering room sessions updated on that date. */
        'filter[date_updated_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room sessions updated after that date. */
        'filter[date_updated_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room sessions updated before that date. */
        'filter[date_updated_at][lte]'?: string;
        /** @description ISO 8601 date for filtering room sessions ended on that date. */
        'filter[date_ended_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room sessions ended after that date. */
        'filter[date_ended_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room sessions ended before that date. */
        'filter[date_ended_at][lte]'?: string;
        /** @description Room_id for filtering room sessions. */
        'filter[room_id]'?: string;
        /** @description Filter active or inactive room sessions. */
        'filter[active]'?: boolean;
        /** @description To decide if room participants should be included in the response. */
        include_participants?: boolean;
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRoomSessionsResponse'];
    };
  };
  ViewRoomSession: {
    parameters: {
      query?: {
        /** @description To decide if room participants should be included in the response. */
        include_participants?: boolean;
      };
      header?: never;
      path: {
        /** @description The unique identifier of a room session. */
        room_session_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetRoomSessionResponse'];
      404: components['responses']['ResourceNotFound'];
    };
  };
  EndSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room session. */
        room_session_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ActionSuccessResponse'];
    };
  };
  KickParticipantInSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room session. */
        room_session_id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be defined during Kick action. */
    requestBody: {
      content: {
        'application/json': components['schemas']['ActionsParticipantsRequest'];
      };
    };
    responses: {
      200: components['responses']['ActionSuccessResponse'];
    };
  };
  MuteParticipantInSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room session. */
        room_session_id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be defined during Mute action. */
    requestBody: {
      content: {
        'application/json': components['schemas']['ActionsParticipantsRequest'];
      };
    };
    responses: {
      200: components['responses']['ActionSuccessResponse'];
    };
  };
  UnmuteParticipantInSession: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room session. */
        room_session_id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be defined during Unmute action. */
    requestBody: {
      content: {
        'application/json': components['schemas']['ActionsParticipantsRequest'];
      };
    };
    responses: {
      200: components['responses']['ActionSuccessResponse'];
    };
  };
  ListRoomParticipants: {
    parameters: {
      query?: {
        /** @description ISO 8601 date for filtering room participants that joined on that date. */
        'filter[date_joined_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room participants that joined after that date. */
        'filter[date_joined_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room participants that joined before that date. */
        'filter[date_joined_at][lte]'?: string;
        /** @description ISO 8601 date for filtering room participants updated on that date. */
        'filter[date_updated_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room participants updated after that date. */
        'filter[date_updated_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room participants updated before that date. */
        'filter[date_updated_at][lte]'?: string;
        /** @description ISO 8601 date for filtering room participants that left on that date. */
        'filter[date_left_at][eq]'?: string;
        /** @description ISO 8601 date for filtering room participants that left after that date. */
        'filter[date_left_at][gte]'?: string;
        /** @description ISO 8601 date for filtering room participants that left before that date. */
        'filter[date_left_at][lte]'?: string;
        /** @description Filter room participants based on the context. */
        'filter[context]'?: string;
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path: {
        /** @description The unique identifier of a room session. */
        room_session_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRoomParticipantsResponse'];
    };
  };
  ListRooms: {
    parameters: {
      query?: {
        /** @description ISO 8601 date for filtering rooms created on that date. */
        'filter[date_created_at][eq]'?: string;
        /** @description ISO 8601 date for filtering rooms created after that date. */
        'filter[date_created_at][gte]'?: string;
        /** @description ISO 8601 date for filtering rooms created before that date. */
        'filter[date_created_at][lte]'?: string;
        /** @description ISO 8601 date for filtering rooms updated on that date. */
        'filter[date_updated_at][eq]'?: string;
        /** @description ISO 8601 date for filtering rooms updated after that date. */
        'filter[date_updated_at][gte]'?: string;
        /** @description ISO 8601 date for filtering rooms updated before that date. */
        'filter[date_updated_at][lte]'?: string;
        /** @description Unique_name for filtering rooms. */
        'filter[unique_name]'?: string;
        /** @description To decide if room sessions should be included in the response. */
        include_sessions?: boolean;
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListRoomsResponse'];
    };
  };
  CreateRoom: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during room creation. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRoomRequest'];
      };
    };
    responses: {
      201: components['responses']['CreateRoomResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  ViewRoom: {
    parameters: {
      query?: {
        /** @description To decide if room sessions should be included in the response. */
        include_sessions?: boolean;
      };
      header?: never;
      path: {
        /** @description The unique identifier of a room. */
        room_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetRoomResponse'];
      404: components['responses']['ResourceNotFound'];
    };
  };
  DeleteRoom: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room. */
        room_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components['responses']['ResourceNotFound'];
    };
  };
  UpdateRoom: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room. */
        room_id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be defined during room update. */
    requestBody: {
      content: {
        'application/json': components['schemas']['PatchRoomRequest'];
      };
    };
    responses: {
      200: components['responses']['PatchRoomResponse'];
      401: components['responses']['UnauthorizedResponse'];
      404: components['responses']['ResourceNotFound'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateRoomClientToken: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room. */
        room_id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be defined during Room Client Token creation. */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateRoomClientTokenRequest'];
      };
    };
    responses: {
      201: components['responses']['CreateRoomClientTokenResponse'];
      403: components['responses']['Forbidden'];
    };
  };
  RefreshRoomClientToken: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The unique identifier of a room. */
        room_id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be defined during Room Client Token refresh. */
    requestBody: {
      content: {
        'application/json': components['schemas']['RefreshRoomClientTokenRequest'];
      };
    };
    responses: {
      201: components['responses']['RefreshRoomClientTokenResponse'];
      403: components['responses']['Forbidden'];
    };
  };
  ListShortCodes: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by Messaging Profile ID. Use the string `null` for phone numbers without assigned profiles. A synonym for the `/messaging_profiles/{id}/short_codes` endpoint when querying about an extant profile. */
        'filter[messaging_profile_id]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListShortCodesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveShortCode: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the short code */
        id: components['parameters']['ShortCodeId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ShortCodeResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateShortCode: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the short code */
        id: components['parameters']['ShortCodeId'];
      };
      cookie?: never;
    };
    /** @description Short code update */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateShortCodeRequest'];
      };
    };
    responses: {
      200: components['responses']['ShortCodeResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListSimCardActions: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description A valid SIM card ID. */
        'filter[sim_card_id]'?: components['parameters']['FilterSIMCardId'];
        /** @description Filter by a specific status of the resource's lifecycle. */
        'filter[status]'?: components['parameters']['FilterBasicStatusLifecycle'];
        /** @description Filter by a bulk SIM card action ID. */
        'filter[bulk_sim_card_action_id]'?: components['parameters']['FilterBulkSIMCardActionId'];
        /** @description Filter by action type. */
        'filter[action_type]'?:
          | 'enable'
          | 'enable_standby_sim_card'
          | 'disable'
          | 'set_standby'
          | 'remove_public_ip'
          | 'set_public_ip';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SimCardActionCollectionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardAction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SIMCardActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListDataUsageNotifications: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description A valid SIM card ID. */
        'filter[sim_card_id]'?: components['parameters']['FilterSIMCardId'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SimCardDataUsageNotificationCollectionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PostSimCardDataUsageNotification: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: uuid
           * @description The identification UUID of the related SIM card resource.
           * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
           */
          sim_card_id: string;
          /** @description Data usage threshold that will trigger the notification. */
          threshold: {
            /**
             * Format: decimal
             * @example 2048.1
             */
            amount?: string;
            /**
             * @example MB
             * @enum {string}
             */
            unit?: 'MB' | 'GB';
          };
        };
      };
    };
    responses: {
      201: components['responses']['CreateSimCardDataUsageNotificationResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardDataUsageNotification: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetSimCardDataUsageNotificationResponse'];
      404: components['responses']['ResourceNotFound'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteSimCardDataUsageNotifications: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeleteSimCardDataUsageNotificationResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PatchSimCardDataUsageNotification: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SimCardDataUsageNotification'];
      };
    };
    responses: {
      200: components['responses']['UpdateSimCardDataUsageNotificationResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardGroupActions: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description A valid SIM card group ID. */
        'filter[sim_card_group_id]'?: components['parameters']['FilterSIMCardGroupId'];
        /** @description Filter by a specific status of the resource's lifecycle. */
        'filter[status]'?: components['parameters']['FilterBasicStatusLifecycle'];
        /** @description Filter by action type. */
        'filter[type]'?:
          | 'set_private_wireless_gateway'
          | 'remove_private_wireless_gateway';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SimCardGroupActionCollectionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardGroupAction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SIMCardGroupActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetAllSimCardGroups: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description A valid SIM card group name. */
        'filter[name]'?: string;
        /** @description A Private Wireless Gateway ID associated with the group. */
        'filter[private_wireless_gateway_id]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllSimCardGroupsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateSimCardGroup: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SIMCardGroupCreate'];
      };
    };
    responses: {
      200: components['responses']['CreateSimCardGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM group. */
        id: components['parameters']['SIMCardGroupId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetSimCardGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteSimCardGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM group. */
        id: components['parameters']['SIMCardGroupId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeleteSimCardGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateSimCardGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM group. */
        id: components['parameters']['SIMCardGroupId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SIMCardGroupPatch'];
      };
    };
    responses: {
      200: components['responses']['UpdateSimCardGroupResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RemoveSimCardGroupPrivateWirelessGateway: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM group. */
        id: components['parameters']['SIMCardGroupId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardGroupActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SetPrivateWirelessGatewayForSimCardGroup: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM group. */
        id: components['parameters']['SIMCardGroupId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: uuid
           * @description The identification of the related Private Wireless Gateway resource.
           * @example 6a09cdc3-8948-47f0-aa62-74ac943d6c58
           */
          private_wireless_gateway_id: string;
        };
      };
    };
    responses: {
      202: components['responses']['SIMCardGroupActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PreviewSimCardOrders: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': {
          /**
           * @description The amount of SIM cards that the user would like to purchase in the SIM card order.
           * @example 21
           */
          quantity: number;
          /**
           * Format: int64
           * @description Uniquely identifies the address for the order.
           * @example 1293384261075731499
           */
          address_id: string;
        };
      };
    };
    responses: {
      202: components['responses']['SIMCardOrdersPreviewResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  GetSimCardOrders: {
    parameters: {
      query?: {
        /** @description Filter by ISO 8601 formatted date-time string matching resource creation date-time. */
        'filter[created_at]'?: components['parameters']['FilterCreatedAt'];
        /** @description Filter by ISO 8601 formatted date-time string matching resource last update date-time. */
        'filter[updated_at]'?: components['parameters']['FilterUpdatedAt'];
        /** @description Filter orders by how many SIM cards were ordered. */
        'filter[quantity]'?: components['parameters']['FilterQuantity'];
        /** @description The total monetary amount of the order. */
        'filter[cost.amount]'?: components['parameters']['FilterCostByAmount'];
        /** @description Filter by ISO 4217 currency string. */
        'filter[cost.currency]'?: components['parameters']['FilterCostByCurrency'];
        /** @description Uniquely identifies the address for the order. */
        'filter[address.id]'?: components['parameters']['FilterAddressById'];
        /** @description Returns entries with matching name of the street where the address is located. */
        'filter[address.street_address]'?: components['parameters']['FilterAddressByStreetAddress'];
        /** @description Returns entries with matching name of the supplemental field for address information. */
        'filter[address.extended_address]'?: components['parameters']['FilterAddressByExtendedAddress'];
        /** @description Filter by the name of the city where the address is located. */
        'filter[address.locality]'?: components['parameters']['FilterAddressByLocality'];
        /** @description Filter by state or province where the address is located. */
        'filter[address.administrative_area]'?: components['parameters']['FilterAddressByAdministrativeArea'];
        /** @description Filter by the mobile operator two-character (ISO 3166-1 alpha-2) origin country code. */
        'filter[address.country_code]'?: components['parameters']['FilterAddressByCountryCode'];
        /** @description Filter by postal code for the address. */
        'filter[address.postal_code]'?: components['parameters']['FilterAddressByPostalCode'];
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllSimCardOrdersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateSimCardOrder: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SimCardOrderCreate'];
      };
    };
    responses: {
      200: components['responses']['CreateSimCardOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetSimCardOrderResponse'];
      404: components['responses']['ResourceNotFound'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCards: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description It includes the associated SIM card group object in the response when present. */
        include_sim_card_group?: components['parameters']['IncludeSIMCardGroup'];
        /** @description A valid SIM card group ID. */
        'filter[sim_card_group_id]'?: components['parameters']['FilterSIMCardGroupId'];
        /** @description A list of SIM card tags to filter on.<br/><br/>
         *      If the SIM card contains <b><i>all</i></b> of the given <code>tags</code> they will be found.<br/><br/>
         *     For example, if the SIM cards have the following tags: <ul>
         *       <li><code>['customers', 'staff', 'test']</code>
         *       <li><code>['test']</code></li>
         *       <li><code>['customers']</code></li>
         *     </ul>
         *     Searching for <code>['customers', 'test']</code> returns only the first because it's the only one with both tags.<br/> Searching for <code>test</code> returns the first two SIMs, because both of them have such tag.<br/> Searching for <code>customers</code> returns the first and last SIMs.<br/>
         *      */
        'filter[tags]'?: string[];
        /** @description A search string to partially match for the SIM card's ICCID. */
        'filter[iccid]'?: string;
        /** @description Filter by a SIM card's status. */
        'filter[status]'?: (
          | 'enabled'
          | 'disabled'
          | 'standby'
          | 'data_limit_exceeded'
          | 'unauthorized_imei'
        )[];
        /**
         * @description Sorts SIM cards by the given field. Defaults to ascending order unless field is prefixed with a minus sign.
         * @example -current_billing_period_consumed_data.amount
         */
        sort?: 'current_billing_period_consumed_data.amount';
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SearchSimCardsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SetNetworkPreferencesBulk: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': {
          /** @example [
           *       "6b14e151-8493-4fa1-8664-1cc4e6d14158"
           *     ] */
          sim_card_ids: components['schemas']['Id'][];
        };
      };
    };
    responses: {
      202: components['responses']['BulkSIMCardActionResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  SetPublicIPsBulk: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': {
          /** @example [
           *       "6b14e151-8493-4fa1-8664-1cc4e6d14158"
           *     ] */
          sim_card_ids: components['schemas']['Id'][];
        };
      };
    };
    responses: {
      202: components['responses']['BulkSIMCardActionResponse'];
      422: components['responses']['UnprocessableEntity'];
    };
  };
  ValidateRegistrationCodes: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          registration_codes?: string[];
        };
      };
    };
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['SIMCardRegistrationCodeValidations'];
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCard: {
    parameters: {
      query?: {
        /** @description It includes the associated SIM card group object in the response when present. */
        include_sim_card_group?: components['parameters']['IncludeSIMCardGroup'];
      };
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetSimCardResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteSimCard: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeleteSimCardResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateSimCard: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['SIMCard'];
      };
    };
    responses: {
      200: components['responses']['UpdateSimCardResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteNetworkPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DisableSimCard: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  EnableSimCard: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  RemoveSimCardPublicIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SetNetworkPreference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SetSimCardPublicIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  SetSimCardStandby: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['SIMCardActionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardActivationCode: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SIMCardActivationCodeResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardDeviceDetails: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SIMCardDeviceDetailsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardNetworkPreferences: {
    parameters: {
      query?: {
        /** @description It includes the associated OTA update objects in the response when present. */
        include_ota_updates?: components['parameters']['IncludeOTAUpdates'];
      };
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SIMCardNetworkPreferenceWithOTAUpdatesResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  PutSimCardNetworkPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': {
          /** @description A list of mobile network operators and the priority that should be applied when the SIM is connecting to the network. */
          mobile_network_operators_preferences?: components['schemas']['MobileNetworkOperatorPreferencesRequest'][];
        };
      };
    };
    responses: {
      202: components['responses']['PUTSIMCardNetworkPreferenceResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteSIMCardNetworkPreferences: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      202: components['responses']['DELETESIMCardNetworkPreferenceResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSimCardPublicIp: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SIMCardPublicIPResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWirelessConnectivityLogs: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description Identifies the SIM. */
        id: components['parameters']['SIMCardId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WirelessConnectivityLogCollectionResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetStorageSSLCertificates: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SSLCertificateResponse'];
    };
  };
  AddStorageSSLCertificate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'multipart/form-data': {
          /**
           * Format: binary
           * @description The SSL certificate file
           */
          certificate?: string;
          /**
           * Format: binary
           * @description The private key file
           */
          private_key?: string;
        };
      };
    };
    responses: {
      200: components['responses']['SSLCertificateResponse'];
    };
  };
  RemoveStorageSSLCertificate: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Bucket Name */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SSLCertificateResponse'];
    };
  };
  GetStorageAPIUsage: {
    parameters: {
      query: {
        /** @description The start time of the period to filter the usage (ISO microsecond format) */
        'filter[start_time]': string;
        /** @description The end time of the period to filter the usage (ISO microsecond format) */
        'filter[end_time]': string;
      };
      header?: never;
      path: {
        /** @description The name of the bucket */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['BucketAPIUsageResponse'];
    };
  };
  GetBucketUsage: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['BucketUsageResponse'];
    };
  };
  CreatePresignedObjectUrl: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket */
        bucketName: string;
        /** @description The name of the object */
        objectName: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['PresignedObjectUrlParams'];
      };
    };
    responses: {
      200: components['responses']['PresignedObjectUrlResponse'];
    };
  };
  ListMigrationSourceCoverage: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMigrationSourceCoverageResponse'];
    };
  };
  ListMigrationSources: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMigrationSourceResponse'];
    };
  };
  CreateMigrationSource: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['MigrationSourceParams'];
      };
    };
    responses: {
      200: components['responses']['MigrationSourceResponse'];
    };
  };
  GetMigrationSource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the data migration source. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MigrationSourceResponse'];
    };
  };
  DeleteMigrationSource: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the data migration source. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MigrationSourceResponse'];
    };
  };
  ListMigrations: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListMigrationResponse'];
    };
  };
  CreateMigration: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: {
      content: {
        'application/json': components['schemas']['MigrationParams'];
      };
    };
    responses: {
      200: components['responses']['MigrationResponse'];
    };
  };
  GetMigration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the data migration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MigrationResponse'];
    };
  };
  StopMigration: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Unique identifier for the data migration. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['MigrationResponse'];
    };
  };
  ListSubNumberOrders: {
    parameters: {
      query?: {
        /** @description Filter sub number orders by status. */
        'filter[status]'?: string;
        /** @description ID of the number order the sub number order belongs to */
        'filter[order_request_id]'?: string;
        /** @description ISO alpha-2 country code. */
        'filter[country_code]'?: string;
        /** @description Phone Number Type */
        'filter[phone_number_type]'?: string;
        /** @description Amount of numbers in the sub number order */
        'filter[phone_numbers_count]'?: number;
        /** @description Include the first 50 phone number objects for each sub order in the results. Note: use of this filter could produce unexpected results due to payload size. */
        'filter[include_phone_numbers]'?: boolean;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListSubNumberOrdersResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetSubNumberOrder: {
    parameters: {
      query?: {
        /** @description Include the first 50 phone number objects in the results */
        'filter[include_phone_numbers]'?: boolean;
      };
      header?: never;
      path: {
        /** @description The sub number order ID. */
        sub_number_order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SubNumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateSubNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The sub number order ID. */
        sub_number_order_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateSubNumberOrderRequest'];
      };
    };
    responses: {
      200: components['responses']['SubNumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CancelSubNumberOrder: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the sub number order. */
        sub_number_order_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['SubNumberOrderResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  FindTelephonyCredentials: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Filter by tag */
        'filter[tag]'?: components['parameters']['OptionalTag'];
        /** @description Filter by name */
        'filter[name]'?: components['parameters']['FilterName'];
        /** @description Filter by status */
        'filter[status]'?: components['parameters']['FilterStatus'];
        /** @description Filter by resource_id */
        'filter[resource_id]'?: components['parameters']['FilterResourceId'];
        /** @description Filter by sip_username */
        'filter[sip_username]'?: components['parameters']['FilterSipUsername'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllTelephonyCredentialResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateTelephonyCredential: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be defined during credential creation */
    requestBody: {
      content: {
        'application/json': components['schemas']['TelephonyCredentialCreateRequest'];
      };
    };
    responses: {
      201: components['responses']['TelephonyCredentialResponse'];
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListTags: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListTagsResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetTelephonyCredential: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TelephonyCredentialResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteTelephonyCredential: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TelephonyCredentialResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  UpdateTelephonyCredential: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated in a credential */
    requestBody: {
      content: {
        'application/json': components['schemas']['TelephonyCredentialUpdateRequest'];
      };
    };
    responses: {
      200: components['responses']['TelephonyCredentialResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Bad request */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PerformCredentialAction: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
        /** @description Identifies the action to be taken. */
        action: 'activate' | 'deactivate';
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TelephonyCredentialResponse'];
      /** @description Bad request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Resource not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateTelephonyCredentialToken: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description JWT */
      201: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/plain': string;
        };
      };
      /** @description Resource not Found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetTexmlCalls: {
    parameters: {
      query?: {
        /**
         * @description The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
         * @example 1
         */
        Page?: components['parameters']['Page'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Used to request the next page of results. */
        PageToken?: components['parameters']['PageToken'];
        /**
         * @description Filters calls by the to number.
         * @example +1312345678
         */
        To?: components['parameters']['To'];
        /**
         * @description Filters calls by the from number.
         * @example +1312345678
         */
        From?: components['parameters']['From'];
        /**
         * @description Filters calls by status.
         * @example no-answer
         */
        Status?: components['parameters']['Status'];
        /**
         * @description Filters calls by their start date. Expected format is YYYY-MM-DD.
         * @example 2023-05-22
         */
        StartTime?: components['parameters']['StartTime'];
        /**
         * @description Filters calls by their start date (after). Expected format is YYYY-MM-DD
         * @example 2023-05-22
         */
        'StartTime>'?: components['parameters']['StartTime>'];
        /**
         * @description Filters calls by their start date (before). Expected format is YYYY-MM-DD
         * @example 2023-05-22
         */
        'StartTime<'?: components['parameters']['StartTime<'];
        /**
         * @description Filters calls by their end date. Expected format is YYYY-MM-DD
         * @example 2023-05-22
         */
        EndTime?: components['parameters']['EndTime'];
        /**
         * @description Filters calls by their end date (after). Expected format is YYYY-MM-DD
         * @example 2023-05-22
         */
        'EndTime>'?: components['parameters']['EndTime>'];
        /**
         * @description Filters calls by their end date (before). Expected format is YYYY-MM-DD
         * @example 2023-05-22
         */
        'EndTime<'?: components['parameters']['EndTime<'];
      };
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetCallsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTexmlCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetCallResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  FetchTeXMLCallRecordings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlGetCallRecordingsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  StartTeXMLCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    requestBody?: components['requestBodies']['TexmlCreateCallRecordingRequest'];
    responses: {
      200: components['responses']['TexmlCreateCallRecordingResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateTeXMLCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
        /** @description Uniquely identifies the recording by id. */
        recording_sid: components['parameters']['RecordingSid'];
      };
      cookie?: never;
    };
    requestBody?: components['requestBodies']['TexmlUpdateCallRecordingRequest'];
    responses: {
      200: components['responses']['TexmlCreateCallRecordingResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  StartTeXMLCallStreaming: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    requestBody?: components['requestBodies']['TexmlCreateCallStreamingRequest'];
    responses: {
      200: components['responses']['TexmlCreateCallStreamingResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateTeXMLCallStreaming: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
        /** @description Uniquely identifies the streaming by id. */
        streaming_sid: components['parameters']['StreamingSid'];
      };
      cookie?: never;
    };
    requestBody?: components['requestBodies']['TexmlUpdateCallStreamingRequest'];
    responses: {
      200: components['responses']['TexmlUpdateCallStreamingResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTexmlConferences: {
    parameters: {
      query?: {
        /**
         * @description The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
         * @example 1
         */
        Page?: components['parameters']['Page'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description Used to request the next page of results. */
        PageToken?: components['parameters']['PageToken'];
        /**
         * @description Filters conferences by their friendly name.
         * @example weekly_review_call
         */
        FriendlyName?: components['parameters']['FriendlyName'];
        /**
         * @description Filters conferences by status.
         * @example in-progress
         */
        Status?: components['parameters']['ConferenceStatus'];
        /**
         * @description Filters conferences by the creation date. Expected format is YYYY-MM-DD. Also accepts inequality operators, e.g. DateCreated>=2023-05-22.
         * @example >=2023-05-22
         */
        DateCreated?: components['parameters']['DateCreated'];
        /**
         * @description Filters conferences by the time they were last updated. Expected format is YYYY-MM-DD. Also accepts inequality operators, e.g. DateUpdated>=2023-05-22.
         * @example >=2023-05-22
         */
        DateUpdated?: components['parameters']['DateUpdated'];
      };
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetConferencesResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTexmlConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetConferenceResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateTexmlConference: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
      };
      cookie?: never;
    };
    /** @description Update Conference request object */
    requestBody: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['UpdateConferenceRequest'];
      };
    };
    responses: {
      200: components['responses']['GetConferenceResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTexmlConferenceParticipants: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetParticipantsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DialTexmlConferenceParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
      };
      cookie?: never;
    };
    /** @description Dial Conference Participant request object */
    requestBody: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['DialConferenceParticipantRequest'];
      };
    };
    responses: {
      200: components['responses']['DialParticipantResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTexmlConferenceParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetParticipantResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateTexmlConferenceParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    /** @description Update Conference Participant request object */
    requestBody: {
      content: {
        'application/x-www-form-urlencoded': components['schemas']['UpdateConferenceParticipantRequest'];
      };
    };
    responses: {
      200: components['responses']['GetParticipantResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteTexmlConferenceParticipant: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTexmlConferenceRecordings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetConferenceRecordingsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  FetchTeXMLConferenceRecordings: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description The ConferenceSid that uniquely identifies a conference. */
        conference_sid: components['parameters']['ConferenceSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlGetCallRecordingsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTeXMLCallRecordings: {
    parameters: {
      query?: {
        /**
         * @description The number of the page to be displayed, zero-indexed, should be used in conjuction with PageToken.
         * @example 1
         */
        Page?: components['parameters']['Page'];
        /**
         * @description The number of records to be displayed on a page
         * @example 10
         */
        PageSize?: components['parameters']['PageSizeTexml'];
        /** @description Filters recording by the creation date. Expected format is ISO8601 date or date-time, ie. {YYYY}-{MM}-{DD} or {YYYY}-{MM}-{DD}T{hh}:{mm}:{ss}Z. Also accepts inequality operators, e.g. DateCreated>=2023-05-22. */
        DateCreated?: components['parameters']['TexmlDateCreated'];
      };
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlGetCallRecordingsResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTeXMLCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description Uniquely identifies the recording by id. */
        recording_sid: components['parameters']['RecordingSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlGetCallRecordingResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteTeXMLCallRecording: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description Uniquely identifies the recording by id. */
        recording_sid: components['parameters']['RecordingSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTeXMLRecordingTranscriptions: {
    parameters: {
      query?: {
        /** @description Used to request the next page of results. */
        PageToken?: components['parameters']['PageToken'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlListRecordingTranscriptionResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  GetTeXMLRecordingTranscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description Uniquely identifies the recording transcription by id. */
        recording_transcription_sid: components['parameters']['RecordingTranscriptionSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlGetRecordingTranscriptionResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteTeXMLRecordingTranscription: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The id of the account the resource belongs to. */
        account_sid: components['parameters']['AccountSid'];
        /** @description Uniquely identifies the recording transcription by id. */
        recording_transcription_sid: components['parameters']['RecordingTranscriptionSid'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      404: components['responses']['NotFoundResponse'];
    };
  };
  InitiateTexmlCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the TeXML application used for the call. */
        application_id: components['parameters']['ApplicationId'];
      };
      cookie?: never;
    };
    /** @description Iniatiate Call request object */
    requestBody: {
      content: {
        'application/json': components['schemas']['InitiateCallRequest'];
      };
    };
    responses: {
      200: components['responses']['InitiateCallResponse'];
    };
  };
  UpdateTexmlCall: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The CallSid that identifies the call to update. */
        call_sid: components['parameters']['CallSid'];
      };
      cookie?: never;
    };
    /** @description Update Call request object */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateCallRequest'];
      };
    };
    responses: {
      200: components['responses']['UpdateTeXMLCallResponse'];
    };
  };
  CreateTexmlSecret: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Create TeXML secret request object */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateTeXMLSecretRequest'];
      };
    };
    responses: {
      201: components['responses']['CreateTeXMLSecretResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  FindTexmlApplications: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description If present, applications with <code>friendly_name</code> containing the given value will be returned. Matching is not case-sensitive. Requires at least three characters. */
        'filter[friendly_name][contains]'?: string;
        /** @description Identifies the associated outbound voice profile. */
        'filter[outbound_voice_profile_id]'?: components['parameters']['FilterOutboundVoiceProfileId'];
        /** @description Specifies the sort order for results. By default sorting direction is ascending. To have the results sorted in descending order add the <code> -</code> prefix.<br/><br/>
         *     That is: <ul>
         *       <li>
         *         <code>friendly_name</code>: sorts the result by the
         *         <code>friendly_name</code> field in ascending order.
         *       </li>
         *
         *       <li>
         *         <code>-friendly_name</code>: sorts the result by the
         *         <code>friendly_name</code> field in descending order.
         *       </li>
         *     </ul> <br/> If not given, results are sorted by <code>created_at</code> in descending order. */
        sort?: components['parameters']['SortApplication'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetAllTexmlApplicationsResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
    };
  };
  CreateTexmlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    /** @description Parameters that can be set when creating a TeXML Application */
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateTexmlApplicationRequest'];
      };
    };
    responses: {
      201: components['responses']['TexmlApplicationResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  GetTexmlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlApplicationResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  DeleteTexmlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['TexmlApplicationResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
    };
  };
  UpdateTexmlApplication: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['id'];
      };
      cookie?: never;
    };
    /** @description Parameters that can be updated in a TeXML Application */
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateTexmlApplicationRequest'];
      };
    };
    responses: {
      200: components['responses']['TexmlApplicationResponse'];
      400: components['responses']['BadRequestResponse'];
      401: components['responses']['UnauthenticatedResponse'];
      403: components['responses']['UnauthorizedResponse'];
      404: components['responses']['NotFoundResponse'];
      422: components['responses']['UnprocessableEntityResponse'];
    };
  };
  GetUsageReport: {
    parameters: {
      query: {
        /** @description Telnyx product */
        product: string;
        /** @description Breakout by specified product dimensions */
        dimensions: string[];
        /** @description Specified product usage values */
        metrics: string[];
        /** @description The start date for the time range you are interested in. The maximum time range is 31 days. Format: YYYY-MM-DDTHH:mm:ssZ */
        start_date?: string;
        /** @description The end date for the time range you are interested in. The maximum time range is 31 days. Format: YYYY-MM-DDTHH:mm:ssZ */
        end_date?: string;
        /** @description A more user-friendly way to specify the timespan you want to filter by. More options can be found in the Telnyx API Reference docs. */
        date_range?: string;
        /** @description Filter records on dimensions */
        filter?: string;
        /** @description Return the aggregations for all Managed Accounts under the user making the request. */
        managed_accounts?: boolean;
        'page[number]'?: number;
        'page[size]'?: number;
        /** @description Specifies the sort order for results */
        sort?: string[];
        /** @description Specify the response format (csv or json). JSON is returned by default, even if not specified. */
        format?: 'csv' | 'json';
      };
      header?: {
        'Authorization: Bearer <TOKEN>'?: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UsageReportsResponse'];
          'text/csv': string;
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  ListUsageReportsOptions: {
    parameters: {
      query?: {
        /** @description Options (dimensions and metrics) for a given product. If none specified, all products will be returned. */
        product?: string;
      };
      header?: {
        'Authorization: Bearer <TOKEN>'?: string;
      };
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['UsageReportsOptionsResponse'];
        };
      };
      /** @description Bad Request */
      400: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Internal Server Error */
      500: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  updateLocation: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The ID of the external connection */
        id: string;
        /** @description The ID of the location to update */
        location_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /**
           * Format: uuid
           * @description A new static emergency address ID to update the location with
           */
          static_emergency_address_id: string;
        };
      };
    };
    responses: {
      /** @description Location successfully updated with no associated orders to process */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location update accepted; associated orders being processed */
      202: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['LocationResponse'];
        };
      };
      /** @description Location or external connection not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
      /** @description Unprocessable Entity - Location already has an accepted emergency address */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ErrorResponse'];
        };
      };
    };
  };
  ListVerifications: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The phone number associated with the verifications to retrieve. */
        phone_number: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVerificationsResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  VerifyVerificationCodeByPhoneNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The phone number associated with the verification code being verified. */
        phone_number: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyVerificationCodeRequestByPhoneNumber'];
      };
    };
    responses: {
      /** @description Expected verify response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyVerificationCodeResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  CreateVerificationCall: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateVerificationRequestCall'];
      };
    };
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateVerificationResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  CreateFlashcallVerification: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateVerificationRequestFlashcall'];
      };
    };
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateVerificationResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  CreateVerificationSms: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateVerificationRequestSMS'];
      };
    };
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateVerificationResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  RetrieveVerification: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The identifier of the verification to retrieve. */
        verification_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['RetrieveVerificationResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  VerifyVerificationCodeById: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The identifier of the verification to retrieve. */
        verification_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VerifyVerificationCodeRequestById'];
      };
    };
    responses: {
      /** @description Expected verify response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyVerificationCodeResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  ListVerifiedNumbers: {
    parameters: {
      query?: {
        'page[size]'?: number;
        'page[number]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVerifiedNumbersResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
      401: components['responses']['UnauthorizedRequestErrorResponse'];
      422: components['responses']['UnprocessableEntityErrorResponse'];
    };
  };
  CreateVerifiedNumber: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @example +15551234567 */
          phone_number: string;
          /**
           * @description Verification method.
           * @example sms
           * @enum {string}
           */
          verification_method: 'sms' | 'call';
        };
      };
    };
    responses: {
      /** @description Expected response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['CreateVerifiedNumberResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
      401: components['responses']['UnauthorizedRequestErrorResponse'];
      422: components['responses']['UnprocessableEntityErrorResponse'];
    };
  };
  GetVerifiedNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The phone number being requested. */
        phone_number: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifiedNumberResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
      401: components['responses']['UnauthorizedRequestErrorResponse'];
      404: components['responses']['NotFoundErrorResponse'];
    };
  };
  DeleteVerifiedNumber: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The phone number being deleted. */
        phone_number: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected verifications response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifiedNumberResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
      401: components['responses']['UnauthorizedRequestErrorResponse'];
      404: components['responses']['NotFoundErrorResponse'];
    };
  };
  VerifyVerificationCode: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The phone number being verified. */
        phone_number: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @example 123456 */
          verification_code: string;
        };
      };
    };
    responses: {
      /** @description Expected response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifiedNumberResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
      401: components['responses']['UnauthorizedRequestErrorResponse'];
      404: components['responses']['NotFoundErrorResponse'];
      422: components['responses']['UnprocessableEntityErrorResponse'];
    };
  };
  ListProfiles: {
    parameters: {
      query?: {
        'filter[name]'?: string;
        'page[size]'?: number;
        'page[number]'?: number;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected Verify profile response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVerifyProfilesResponse'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  CreateVerifyProfile: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @example Test Profile */
          name: string;
          /** @example http://example.com/webhook */
          webhook_url?: string;
          /** @example http://example.com/webhook/failover */
          webhook_failover_url?: string;
          sms?: components['schemas']['CreateVerifyProfileSMSRequest'];
          call?: components['schemas']['CreateVerifyProfileCallRequest'];
          flashcall?: components['schemas']['CreateVerifyProfileFlashcallRequest'];
          /** @example en-US */
          language?: string;
        };
      };
    };
    responses: {
      /** @description Expected Verify profile response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyProfileResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  ListProfileMessageTemplates: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected Verify profile message template response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['ListVerifyProfileMessageTemplateResponse'];
        };
      };
    };
  };
  GetVerifyProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The identifier of the Verify profile to retrieve. */
        verify_profile_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected Verify profile response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyProfileResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The identifier of the Verify profile to delete. */
        verify_profile_id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Expected Verify profile response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyProfileResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateVerifyProfile: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The identifier of the Verify profile to update. */
        verify_profile_id: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': {
          /** @example Test Profile */
          name?: string;
          /** @example http://example.com/webhook */
          webhook_url?: string;
          /** @example http://example.com/webhook/failover */
          webhook_failover_url?: string;
          sms?: components['schemas']['UpdateVerifyProfileSMSRequest'];
          call?: components['schemas']['UpdateVerifyProfileCallRequest'];
          flashcall?: components['schemas']['UpdateVerifyProfileFlashcallRequest'];
          /** @example en-US */
          language?: string;
        };
      };
    };
    responses: {
      /** @description Expected Verify profile response to a valid request. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': components['schemas']['VerifyProfileResponseDataWrapper'];
        };
      };
      400: components['responses']['GenericErrorResponse'];
    };
  };
  ListVirtualCrossConnects: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The associated network id to filter on. */
        'filter[network_id]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['VirtualCrossConnectListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateVirtualCrossConnect: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VirtualCrossConnectCreate'];
      };
    };
    responses: {
      200: components['responses']['VirtualCrossConnectResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetVirtualCrossConnect: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['VirtualCrossConnectResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteVirtualCrossConnect: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['VirtualCrossConnectResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateVirtualCrossConnect: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['VirtualCrossConnectPatch'];
      };
    };
    responses: {
      200: components['responses']['VirtualCrossConnectResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListVirtualCrossConnectCoverage: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /**
         * @description The available bandwidth to filter on.
         * @example 50
         */
        'filters[available_bandwidth][contains]'?: number;
        /** @description The Telnyx region code */
        'filter[cloud_provider]'?: 'aws' | 'azure' | 'gce';
        /** @description The cloud provider region code to filter on */
        'filter[cloud_provider_region]'?: string;
        /** @description The region of associated location to filter on. */
        'filter[location.region]'?: string;
        /** @description The site of associated location to filter on. */
        'filter[location.site]'?: string;
        /** @description The POP of associated location to filter on. */
        'filter[location.pop]'?: string;
        /** @description The code of associated location to filter on. */
        'filter[location.code]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['VirtualCrossConnectCoverageListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWebhookDeliveries: {
    parameters: {
      query?: {
        /** @description Return only webhook_deliveries matching the given `status` */
        'filter[status][eq]'?: 'delivered' | 'failed';
        /** @description Return only webhook_deliveries matching the given value of `event_type`. Accepts multiple values separated by a `,`. */
        'filter[event_type]'?: string;
        /** @description Return only webhook deliveries whose `webhook` component contains the given text */
        'filter[webhook][contains]'?: string;
        /** @description Return only webhook_deliveries whose `attempts` component contains the given text */
        'filter[attempts][contains]'?: string;
        /** @description Return only webhook_deliveries whose delivery started later than or at given ISO 8601 datetime */
        'filter[started_at][gte]'?: string;
        /** @description Return only webhook_deliveries whose delivery started earlier than or at given ISO 8601 datetime */
        'filter[started_at][lte]'?: string;
        /** @description Return only webhook_deliveries whose delivery finished later than or at given ISO 8601 datetime */
        'filter[finished_at][gte]'?: string;
        /** @description Return only webhook_deliveries whose delivery finished earlier than or at given ISO 8601 datetime */
        'filter[finished_at][lte]'?: string;
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['ListWebhookDeliveriesResponse'];
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description Unprocessable entity */
      422: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetWebhookDelivery: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Uniquely identifies the webhook_delivery. */
        id: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Webhook delivery record. */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'application/json': {
            data?: components['schemas']['webhook_delivery'];
          };
        };
      };
      /** @description Unauthorized */
      401: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description WebhookDelivery not found */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  ListWireguardInterfaces: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The associated network id to filter on. */
        'filter[network_id]'?: string;
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WireguardInterfaceListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateWireguardInterface: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WireguardInterfaceCreate'];
      };
    };
    responses: {
      202: components['responses']['WireguardInterfaceResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWireguardInterface: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WireguardInterfaceResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteWireguardInterface: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WireguardInterfaceResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListWireguardPeers: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
        /** @description The id of the associated WireGuard interface to filter on. */
        'filter[wireguard_interface_id]'?: string;
      };
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WireguardPeerListResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateWireguardPeer: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WireguardPeerCreate'];
      };
    };
    responses: {
      202: components['responses']['WireguardPeerResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWireguardPeer: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WireguardPeerResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteWireguardPeer: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['WireguardPeerResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  UpdateWireguardPeer: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WireguardPeerPatch'];
      };
    };
    responses: {
      200: components['responses']['WireguardPeerResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWireguardPeerConfig: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Successful response */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/plain; charset=utf-8': string;
        };
      };
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWdrReports: {
    parameters: {
      query?: {
        /** @description The page number to load */
        'page[number]'?: components['parameters']['PageNumber'];
        /** @description The size of the page */
        'page[size]'?: components['parameters']['PageSize'];
      };
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetWdrReportsResponse'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  CreateWdrReport: {
    parameters: {
      query?: never;
      header?: never;
      path?: never;
      cookie?: never;
    };
    requestBody: {
      content: {
        'application/json': components['schemas']['WdrReportRequest'];
      };
    };
    responses: {
      201: components['responses']['CreateWdrReportResponse'];
      422: components['responses']['UnprocessableEntity'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  GetWdrReport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['GetWdrReportResponse'];
      404: components['responses']['ResourceNotFound'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  DeleteWdrReport: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description Identifies the resource. */
        id: components['parameters']['ResourceId'];
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      200: components['responses']['DeleteWdrReportResponse'];
      404: components['responses']['ResourceNotFound'];
      default: components['responses']['GenericErrorResponse'];
    };
  };
  ListObjects: {
    parameters: {
      query?: {
        'list-type'?: 2;
      };
      header?: never;
      path: {
        /** @description The name of the bucket. */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/xml': components['schemas']['ListObjectsResponse'];
        };
      };
      /** @description Bucket does not exist. */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  CreateBucket: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket. */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: {
      content: {
        'text/xml': components['schemas']['CreateBucketRequest'];
      };
    };
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description BucketAlreadyExists */
      409: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/xml': string;
        };
      };
    };
  };
  DeleteObjects: {
    parameters: {
      query: {
        delete: true;
      };
      header?: never;
      path: {
        /** @description The bucket name. */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        'text/xml': components['schemas']['DeleteObjectsRequest'];
      };
    };
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          'text/xml': components['schemas']['DeleteObjectsResponse'];
        };
      };
    };
  };
  DeleteBucket: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket. */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  HeadBucket: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The name of the bucket. */
        bucketName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description NoSuchBucket */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  GetObject: {
    parameters: {
      query?: {
        uploadId?: string;
      };
      header?: never;
      path: {
        /** @description The bucket name. */
        bucketName: string;
        /** @description The object name. */
        objectName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content: {
          '*/*': string;
        };
      };
      /** @description ObjectNotFound */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  PutObject: {
    parameters: {
      query?: {
        partNumber?: string;
        uploadId?: string;
      };
      header?: {
        'Content-type'?: string;
      };
      path: {
        /** @description The bucket name. */
        bucketName: string;
        /** @description The object name. */
        objectName: string;
      };
      cookie?: never;
    };
    requestBody: {
      content: {
        '*/*': string;
      };
    };
    responses: {
      /** @description Success */
      200: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  DeleteObject: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The bucket name. */
        bucketName: string;
        /** @description The object name. */
        objectName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      204: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
  HeadObject: {
    parameters: {
      query?: never;
      header?: never;
      path: {
        /** @description The bucket name. */
        bucketName: string;
        /** @description The object name. */
        objectName: string;
      };
      cookie?: never;
    };
    requestBody?: never;
    responses: {
      /** @description Success */
      200: {
        headers: {
          Date?: string;
          'Last-Modified'?: string;
          'Content-Length'?: number;
          [name: string]: unknown;
        };
        content?: never;
      };
      /** @description ObjectNotFound */
      404: {
        headers: {
          [name: string]: unknown;
        };
        content?: never;
      };
    };
  };
}
